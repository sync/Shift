diff --git a/node_modules/react-native/Libraries/Renderer/.DS_Store b/node_modules/react-native/Libraries/Renderer/.DS_Store
new file mode 100644
index 0000000..fba6f6c
Binary files /dev/null and b/node_modules/react-native/Libraries/Renderer/.DS_Store differ
diff --git a/node_modules/react-native/Libraries/Renderer/implementations/ReactFabric-dev.js b/node_modules/react-native/Libraries/Renderer/implementations/ReactFabric-dev.js
index 2d08a1c..6044b4b 100644
--- a/node_modules/react-native/Libraries/Renderer/implementations/ReactFabric-dev.js
+++ b/node_modules/react-native/Libraries/Renderer/implementations/ReactFabric-dev.js
@@ -8,7 +8,7 @@
  * @nolint
  * @providesModule ReactFabric-dev
  * @preventMunge
- * @generated SignedSource<<f53cdbb0b9c998fa850933493b683c1f>>
+ * @generated SignedSource<<b2518f8fc782ae207960d73af4bbc7b4>>
  */
 
 "use strict";
@@ -98,292 +98,14 @@ if (__DEV__) {
       }
     }
 
-    var fakeNode = null;
-
-    {
-      if (
-        typeof window !== "undefined" &&
-        typeof window.dispatchEvent === "function" &&
-        typeof document !== "undefined" && // $FlowFixMe[method-unbinding]
-        typeof document.createEvent === "function"
-      ) {
-        fakeNode = document.createElement("react");
-      }
-    }
-
-    function invokeGuardedCallbackImpl(name, func, context) {
-      {
-        // In DEV mode, we use a special version
-        // that plays more nicely with the browser's DevTools. The idea is to preserve
-        // "Pause on exceptions" behavior. Because React wraps all user-provided
-        // functions in invokeGuardedCallback, and the production version of
-        // invokeGuardedCallback uses a try-catch, all user exceptions are treated
-        // like caught exceptions, and the DevTools won't pause unless the developer
-        // takes the extra step of enabling pause on caught exceptions. This is
-        // unintuitive, though, because even though React has caught the error, from
-        // the developer's perspective, the error is uncaught.
-        //
-        // To preserve the expected "Pause on exceptions" behavior, we don't use a
-        // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
-        // DOM node, and call the user-provided callback from inside an event handler
-        // for that fake event. If the callback throws, the error is "captured" using
-        // event loop context, it does not interrupt the normal program flow.
-        // Effectively, this gives us try-catch behavior without actually using
-        // try-catch. Neat!
-        // fakeNode signifies we are in an environment with a document and window object
-        if (fakeNode) {
-          var evt = document.createEvent("Event");
-          var didCall = false; // Keeps track of whether the user-provided callback threw an error. We
-          // set this to true at the beginning, then set it to false right after
-          // calling the function. If the function errors, `didError` will never be
-          // set to false. This strategy works even if the browser is flaky and
-          // fails to call our global error handler, because it doesn't rely on
-          // the error event at all.
-
-          var didError = true; // Keeps track of the value of window.event so that we can reset it
-          // during the callback to let user code access window.event in the
-          // browsers that support it.
-
-          var windowEvent = window.event; // Keeps track of the descriptor of window.event to restore it after event
-          // dispatching: https://github.com/facebook/react/issues/13688
-
-          var windowEventDescriptor = Object.getOwnPropertyDescriptor(
-            window,
-            "event"
-          );
-
-          var restoreAfterDispatch = function () {
-            // We immediately remove the callback from event listeners so that
-            // nested `invokeGuardedCallback` calls do not clash. Otherwise, a
-            // nested call would trigger the fake event handlers of any call higher
-            // in the stack.
-            fakeNode.removeEventListener(evtType, callCallback, false); // We check for window.hasOwnProperty('event') to prevent the
-            // window.event assignment in both IE <= 10 as they throw an error
-            // "Member not found" in strict mode, and in Firefox which does not
-            // support window.event.
-
-            if (
-              typeof window.event !== "undefined" &&
-              window.hasOwnProperty("event")
-            ) {
-              window.event = windowEvent;
-            }
-          }; // Create an event handler for our fake event. We will synchronously
-          // dispatch our fake event using `dispatchEvent`. Inside the handler, we
-          // call the user-provided callback.
-          // $FlowFixMe[method-unbinding]
-
-          var _funcArgs = Array.prototype.slice.call(arguments, 3);
-
-          var callCallback = function () {
-            didCall = true;
-            restoreAfterDispatch(); // $FlowFixMe[incompatible-call] Flow doesn't understand the arguments splicing.
-
-            func.apply(context, _funcArgs);
-            didError = false;
-          }; // Create a global error event handler. We use this to capture the value
-          // that was thrown. It's possible that this error handler will fire more
-          // than once; for example, if non-React code also calls `dispatchEvent`
-          // and a handler for that event throws. We should be resilient to most of
-          // those cases. Even if our error event handler fires more than once, the
-          // last error event is always used. If the callback actually does error,
-          // we know that the last error event is the correct one, because it's not
-          // possible for anything else to have happened in between our callback
-          // erroring and the code that follows the `dispatchEvent` call below. If
-          // the callback doesn't error, but the error event was fired, we know to
-          // ignore it because `didError` will be false, as described above.
-
-          var error; // Use this to track whether the error event is ever called.
-
-          var didSetError = false;
-          var isCrossOriginError = false;
-
-          var handleWindowError = function (event) {
-            error = event.error;
-            didSetError = true;
-
-            if (error === null && event.colno === 0 && event.lineno === 0) {
-              isCrossOriginError = true;
-            }
-
-            if (event.defaultPrevented) {
-              // Some other error handler has prevented default.
-              // Browsers silence the error report if this happens.
-              // We'll remember this to later decide whether to log it or not.
-              if (error != null && typeof error === "object") {
-                try {
-                  error._suppressLogging = true;
-                } catch (inner) {
-                  // Ignore.
-                }
-              }
-            }
-          }; // Create a fake event type.
-
-          var evtType = "react-" + (name ? name : "invokeguardedcallback"); // Attach our event handlers
-
-          window.addEventListener("error", handleWindowError);
-          fakeNode.addEventListener(evtType, callCallback, false); // Synchronously dispatch our fake event. If the user-provided function
-          // errors, it will trigger our global error handler.
-
-          evt.initEvent(evtType, false, false);
-          fakeNode.dispatchEvent(evt);
-
-          if (windowEventDescriptor) {
-            Object.defineProperty(window, "event", windowEventDescriptor);
-          }
-
-          if (didCall && didError) {
-            if (!didSetError) {
-              // The callback errored, but the error event never fired.
-              // eslint-disable-next-line react-internal/prod-error-codes
-              error = new Error(
-                "An error was thrown inside one of your components, but React " +
-                  "doesn't know what it was. This is likely due to browser " +
-                  'flakiness. React does its best to preserve the "Pause on ' +
-                  'exceptions" behavior of the DevTools, which requires some ' +
-                  "DEV-mode only tricks. It's possible that these don't work in " +
-                  "your browser. Try triggering the error in production mode, " +
-                  "or switching to a modern browser. If you suspect that this is " +
-                  "actually an issue with React, please file an issue."
-              );
-            } else if (isCrossOriginError) {
-              // eslint-disable-next-line react-internal/prod-error-codes
-              error = new Error(
-                "A cross-origin error was thrown. React doesn't have access to " +
-                  "the actual error object in development. " +
-                  "See https://reactjs.org/link/crossorigin-error for more information."
-              );
-            }
-
-            this.onError(error);
-          } // Remove our event listeners
-
-          window.removeEventListener("error", handleWindowError);
-
-          if (didCall) {
-            return;
-          } else {
-            // Something went really wrong, and our event was not dispatched.
-            // https://github.com/facebook/react/issues/16734
-            // https://github.com/facebook/react/issues/16585
-            // Fall back to the production implementation.
-            restoreAfterDispatch(); // we fall through and call the prod version instead
-          }
-        } // We only get here if we are in an environment that either does not support the browser
-        // variant or we had trouble getting the browser to emit the error.
-        // $FlowFixMe[method-unbinding]
-
-        var funcArgs = Array.prototype.slice.call(arguments, 3);
-
-        try {
-          // $FlowFixMe[incompatible-call] Flow doesn't understand the arguments splicing.
-          func.apply(context, funcArgs);
-        } catch (error) {
-          this.onError(error);
-        }
-      }
-    }
-
-    var hasError = false;
-    var caughtError = null; // Used by event system to capture/rethrow the first error.
-
-    var hasRethrowError = false;
-    var rethrowError = null;
-    var reporter = {
-      onError: function (error) {
-        hasError = true;
-        caughtError = error;
-      }
-    };
-    /**
-     * Call a function while guarding against errors that happens within it.
-     * Returns an error if it throws, otherwise null.
-     *
-     * In production, this is implemented using a try-catch. The reason we don't
-     * use a try-catch directly is so that we can swap out a different
-     * implementation in DEV mode.
-     *
-     * @param {String} name of the guard to use for logging or debugging
-     * @param {Function} func The function to invoke
-     * @param {*} context The context to use when calling the function
-     * @param {...*} args Arguments for function
-     */
-
-    function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
-      hasError = false;
-      caughtError = null;
-      invokeGuardedCallbackImpl.apply(reporter, arguments);
-    }
-    /**
-     * Same as invokeGuardedCallback, but instead of returning an error, it stores
-     * it in a global so it can be rethrown by `rethrowCaughtError` later.
-     * TODO: See if caughtError and rethrowError can be unified.
-     *
-     * @param {String} name of the guard to use for logging or debugging
-     * @param {Function} func The function to invoke
-     * @param {*} context The context to use when calling the function
-     * @param {...*} args Arguments for function
-     */
-
-    function invokeGuardedCallbackAndCatchFirstError(
-      name,
-      func,
-      context,
-      a,
-      b,
-      c,
-      d,
-      e,
-      f
-    ) {
-      invokeGuardedCallback.apply(this, arguments);
-
-      if (hasError) {
-        var error = clearCaughtError();
-
-        if (!hasRethrowError) {
-          hasRethrowError = true;
-          rethrowError = error;
-        }
-      }
-    }
-    /**
-     * During execution of guarded functions we will capture the first error which
-     * we will rethrow to be handled by the top level error handler.
-     */
-
-    function rethrowCaughtError() {
-      if (hasRethrowError) {
-        var error = rethrowError;
-        hasRethrowError = false;
-        rethrowError = null;
-        throw error;
-      }
-    }
-    function hasCaughtError() {
-      return hasError;
-    }
-    function clearCaughtError() {
-      if (hasError) {
-        var error = caughtError;
-        hasError = false;
-        caughtError = null;
-        return error;
-      } else {
-        throw new Error(
-          "clearCaughtError was called but no error was captured. This error " +
-            "is likely caused by a bug in React. Please file an issue."
-        );
-      }
-    }
-
     var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare
 
     function isArray(a) {
       return isArrayImpl(a);
     }
 
+    var hasError = false;
+    var caughtError = null;
     var getFiberCurrentPropsFromNode$1 = null;
     var getInstanceFromNode$1 = null;
     var getNodeFromInstance$1 = null;
@@ -399,7 +121,7 @@ if (__DEV__) {
       {
         if (!getNodeFromInstance$1 || !getInstanceFromNode$1) {
           error(
-            "EventPluginUtils.setComponentTree(...): Injected " +
+            "Injected " +
               "module is missing getNodeFromInstance or getInstanceFromNode."
           );
         }
@@ -439,9 +161,17 @@ if (__DEV__) {
      */
 
     function executeDispatch(event, listener, inst) {
-      var type = event.type || "unknown-event";
       event.currentTarget = getNodeFromInstance$1(inst);
-      invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
+
+      try {
+        listener(event);
+      } catch (error) {
+        if (!hasError) {
+          hasError = true;
+          caughtError = error;
+        }
+      }
+
       event.currentTarget = null;
     }
     /**
@@ -534,7 +264,7 @@ if (__DEV__) {
       var dispatchInstance = event._dispatchInstances;
 
       if (isArray(dispatchListener)) {
-        throw new Error("executeDirectDispatch(...): Invalid `event`.");
+        throw new Error("Invalid `event`.");
       }
 
       event.currentTarget = dispatchListener
@@ -554,6 +284,14 @@ if (__DEV__) {
     function hasDispatches(event) {
       return !!event._dispatchListeners;
     }
+    function rethrowCaughtError() {
+      if (hasError) {
+        var error = caughtError;
+        hasError = false;
+        caughtError = null;
+        throw error;
+      }
+    }
 
     var assign = Object.assign;
 
@@ -840,7 +578,7 @@ if (__DEV__) {
             "This synthetic event is reused for performance reasons. If you're seeing this, " +
               "you're %s `%s` on a released/nullified synthetic event. %s. " +
               "If you must keep the original synthetic event around, use event.persist(). " +
-              "See https://reactjs.org/link/event-pooling for more information.",
+              "See https://react.dev/link/event-pooling for more information.",
             action,
             propName,
             result
@@ -1160,9 +898,7 @@ if (__DEV__) {
 
     function accumulate(current, next) {
       if (next == null) {
-        throw new Error(
-          "accumulate(...): Accumulated items must not be null or undefined."
-        );
+        throw new Error("Accumulated items must not be null or undefined.");
       }
 
       if (current == null) {
@@ -1200,9 +936,7 @@ if (__DEV__) {
 
     function accumulateInto(current, next) {
       if (next == null) {
-        throw new Error(
-          "accumulateInto(...): Accumulated items must not be null or undefined."
-        );
+        throw new Error("Accumulated items must not be null or undefined.");
       }
 
       if (current == null) {
@@ -3229,6 +2963,7 @@ to return true:wantsResponderID|                            |
       // where it would do it.
     }
 
+    // -----------------------------------------------------------------------------
     var enableSchedulingProfiler = false;
     var enableProfilerTimer = true;
     var enableProfilerCommitHooks = true;
@@ -3239,6 +2974,7 @@ to return true:wantsResponderID|                            |
     var enableLegacyHidden = false;
     var enableAsyncActions = false;
     var passChildrenWhenCloningPersistedNodes = false;
+    var enableBigIntSupport = false;
 
     var NoFlags$1 =
       /*                      */
@@ -3499,7 +3235,7 @@ to return true:wantsResponderID|                            |
           error(
             "The installed version of React DevTools is too old and will not work " +
               "with the current version of React. Please update React DevTools. " +
-              "https://reactjs.org/link/react-devtools"
+              "https://react.dev/link/react-devtools"
           );
         } // DevTools exists, even though it doesn't support Fiber.
 
@@ -4246,7 +3982,7 @@ to return true:wantsResponderID|                            |
 
       return laneMap;
     }
-    function markRootUpdated(root, updateLane) {
+    function markRootUpdated$1(root, updateLane) {
       root.pendingLanes |= updateLane; // If there are any suspended transitions, it's possible this new update
       // could unblock them. Clear the suspended lanes so that we can try rendering
       // them again.
@@ -4283,7 +4019,7 @@ to return true:wantsResponderID|                            |
         markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
       }
     }
-    function markRootPinged(root, pingedLanes) {
+    function markRootPinged$1(root, pingedLanes) {
       root.pingedLanes |= root.suspendedLanes & pingedLanes;
     }
     function markRootFinished(root, remainingLanes, spawnedLane) {
@@ -4895,6 +4631,14 @@ to return true:wantsResponderID|                            |
     function waitForCommitToBeReady() {
       return null;
     }
+    //     Microtasks
+    // -------------------
+
+    var supportsMicrotasks =
+      typeof RN$enableMicrotasksInReact !== "undefined" &&
+      !!RN$enableMicrotasksInReact;
+    var scheduleMicrotask =
+      typeof queueMicrotask === "function" ? queueMicrotask : scheduleTimeout;
 
     // This is ok in DOM because they types are interchangeable, but in React Native
     // they aren't.
@@ -4982,7 +4726,9 @@ to return true:wantsResponderID|                            |
     var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
     var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
     var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
-    var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
+    var REACT_PROVIDER_TYPE = Symbol.for("react.provider"); // TODO: Delete with enableRenderableContext
+
+    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
     var REACT_CONTEXT_TYPE = Symbol.for("react.context");
     var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
     var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
@@ -5082,13 +4828,21 @@ to return true:wantsResponderID|                            |
         }
 
         switch (type.$$typeof) {
+          case REACT_PROVIDER_TYPE: {
+            var provider = type;
+            return getContextName$1(provider._context) + ".Provider";
+          }
+
           case REACT_CONTEXT_TYPE:
             var context = type;
-            return getContextName$1(context) + ".Consumer";
 
-          case REACT_PROVIDER_TYPE:
-            var provider = type;
-            return getContextName$1(provider._context) + ".Provider";
+            {
+              return getContextName$1(context) + ".Consumer";
+            }
+
+          case REACT_CONSUMER_TYPE: {
+            return null;
+          }
 
           case REACT_FORWARD_REF_TYPE:
             return getWrappedName$1(type, type.render, "ForwardRef");
@@ -5141,13 +4895,15 @@ to return true:wantsResponderID|                            |
         case CacheComponent:
           return "Cache";
 
-        case ContextConsumer:
+        case ContextConsumer: {
           var context = type;
           return getContextName(context) + ".Consumer";
+        }
 
-        case ContextProvider:
+        case ContextProvider: {
           var provider = type;
           return getContextName(provider._context) + ".Provider";
+        }
 
         case DehydratedFragment:
           return "DehydratedFragment";
@@ -5261,9 +5017,6 @@ to return true:wantsResponderID|                            |
 
       return null;
     }
-    function isFiberMounted(fiber) {
-      return getNearestMountedFiber(fiber) === fiber;
-    }
     function isMounted(component) {
       {
         var owner = ReactCurrentOwner$3.current;
@@ -5509,214 +5262,6 @@ to return true:wantsResponderID|                            |
       return false;
     }
 
-    function describeBuiltInComponentFrame(name, ownerFn) {
-      {
-        var ownerName = null;
-
-        if (ownerFn) {
-          ownerName = ownerFn.displayName || ownerFn.name || null;
-        }
-
-        return describeComponentFrame(name, ownerName);
-      }
-    }
-
-    {
-      var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
-      new PossiblyWeakMap$1();
-    }
-
-    function describeComponentFrame(name, ownerName) {
-      var sourceInfo = "";
-
-      if (ownerName) {
-        sourceInfo = " (created by " + ownerName + ")";
-      }
-
-      return "\n    in " + (name || "Unknown") + sourceInfo;
-    }
-
-    function describeClassComponentFrame(ctor, ownerFn) {
-      {
-        return describeFunctionComponentFrame(ctor, ownerFn);
-      }
-    }
-    function describeFunctionComponentFrame(fn, ownerFn) {
-      {
-        if (!fn) {
-          return "";
-        }
-
-        var name = fn.displayName || fn.name || null;
-        var ownerName = null;
-
-        if (ownerFn) {
-          ownerName = ownerFn.displayName || ownerFn.name || null;
-        }
-
-        return describeComponentFrame(name, ownerName);
-      }
-    }
-
-    function describeUnknownElementTypeFrameInDEV(type, ownerFn) {
-      if (type == null) {
-        return "";
-      }
-
-      if (typeof type === "function") {
-        {
-          return describeFunctionComponentFrame(type, ownerFn);
-        }
-      }
-
-      if (typeof type === "string") {
-        return describeBuiltInComponentFrame(type, ownerFn);
-      }
-
-      switch (type) {
-        case REACT_SUSPENSE_TYPE:
-          return describeBuiltInComponentFrame("Suspense", ownerFn);
-
-        case REACT_SUSPENSE_LIST_TYPE:
-          return describeBuiltInComponentFrame("SuspenseList", ownerFn);
-      }
-
-      if (typeof type === "object") {
-        switch (type.$$typeof) {
-          case REACT_FORWARD_REF_TYPE:
-            return describeFunctionComponentFrame(type.render, ownerFn);
-
-          case REACT_MEMO_TYPE:
-            // Memo may contain any component type so we recursively resolve it.
-            return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);
-
-          case REACT_LAZY_TYPE: {
-            var lazyComponent = type;
-            var payload = lazyComponent._payload;
-            var init = lazyComponent._init;
-
-            try {
-              // Lazy may contain any component type so we recursively resolve it.
-              return describeUnknownElementTypeFrameInDEV(
-                init(payload),
-                ownerFn
-              );
-            } catch (x) {}
-          }
-        }
-      }
-
-      return "";
-    }
-
-    // $FlowFixMe[method-unbinding]
-    var hasOwnProperty = Object.prototype.hasOwnProperty;
-
-    var loggedTypeFailures = {};
-    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
-
-    function setCurrentlyValidatingElement(element) {
-      {
-        if (element) {
-          var owner = element._owner;
-          var stack = describeUnknownElementTypeFrameInDEV(
-            element.type,
-            owner ? owner.type : null
-          );
-          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
-        } else {
-          ReactDebugCurrentFrame$1.setExtraStackFrame(null);
-        }
-      }
-    }
-
-    function checkPropTypes(
-      typeSpecs,
-      values,
-      location,
-      componentName,
-      element
-    ) {
-      {
-        // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.
-        var has = Function.call.bind(hasOwnProperty);
-
-        for (var typeSpecName in typeSpecs) {
-          if (has(typeSpecs, typeSpecName)) {
-            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
-            // fail the render phase where it didn't fail before. So we log it.
-            // After these have been cleaned up, we'll let them throw.
-
-            try {
-              // This is intentionally an invariant that gets caught. It's the same
-              // behavior as without this statement except with a better message.
-              if (typeof typeSpecs[typeSpecName] !== "function") {
-                // eslint-disable-next-line react-internal/prod-error-codes
-                var err = Error(
-                  (componentName || "React class") +
-                    ": " +
-                    location +
-                    " type `" +
-                    typeSpecName +
-                    "` is invalid; " +
-                    "it must be a function, usually from the `prop-types` package, but received `" +
-                    typeof typeSpecs[typeSpecName] +
-                    "`." +
-                    "This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
-                );
-                err.name = "Invariant Violation";
-                throw err;
-              }
-
-              error$1 = typeSpecs[typeSpecName](
-                values,
-                typeSpecName,
-                componentName,
-                location,
-                null,
-                "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
-              );
-            } catch (ex) {
-              error$1 = ex;
-            }
-
-            if (error$1 && !(error$1 instanceof Error)) {
-              setCurrentlyValidatingElement(element);
-
-              error(
-                "%s: type specification of %s" +
-                  " `%s` is invalid; the type checker " +
-                  "function must return `null` or an `Error` but returned a %s. " +
-                  "You may have forgotten to pass an argument to the type checker " +
-                  "creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and " +
-                  "shape all require an argument).",
-                componentName || "React class",
-                location,
-                typeSpecName,
-                typeof error$1
-              );
-
-              setCurrentlyValidatingElement(null);
-            }
-
-            if (
-              error$1 instanceof Error &&
-              !(error$1.message in loggedTypeFailures)
-            ) {
-              // Only monitor this failure once because there tends to be a lot of the
-              // same error.
-              loggedTypeFailures[error$1.message] = true;
-              setCurrentlyValidatingElement(element);
-
-              error("Failed %s type: %s", location, error$1.message);
-
-              setCurrentlyValidatingElement(null);
-            }
-          }
-        }
-      }
-    }
-
     var valueStack = [];
     var fiberStack;
 
@@ -5768,280 +5313,33 @@ to return true:wantsResponderID|                            |
       cursor.current = value;
     }
 
-    var warnedAboutMissingGetChildContext;
-
-    {
-      warnedAboutMissingGetChildContext = {};
-    }
-
     var emptyContextObject = {};
 
     {
       Object.freeze(emptyContextObject);
     } // A cursor to the current merged context object on the stack.
 
-    var contextStackCursor$1 = createCursor(emptyContextObject); // A cursor to a boolean indicating whether the context has changed.
-
-    var didPerformWorkStackCursor = createCursor(false); // Keep track of the previous context object that was on the stack.
-    // We use this to get access to the parent context after we have already
-    // pushed the next context provider, and now need to merge their contexts.
-
-    var previousContext = emptyContextObject;
-
-    function getUnmaskedContext(
-      workInProgress,
-      Component,
-      didPushOwnContextIfProvider
-    ) {
-      {
-        if (didPushOwnContextIfProvider && isContextProvider(Component)) {
-          // If the fiber is a context provider itself, when we read its context
-          // we may have already pushed its own child context on the stack. A context
-          // provider should not "see" its own child context. Therefore we read the
-          // previous (parent) context instead for a context provider.
-          return previousContext;
-        }
-
-        return contextStackCursor$1.current;
-      }
-    }
-
-    function cacheContext(workInProgress, unmaskedContext, maskedContext) {
-      {
-        var instance = workInProgress.stateNode;
-        instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
-        instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
-      }
-    }
-
-    function getMaskedContext(workInProgress, unmaskedContext) {
-      {
-        var type = workInProgress.type;
-        var contextTypes = type.contextTypes;
-
-        if (!contextTypes) {
-          return emptyContextObject;
-        } // Avoid recreating masked context unless unmasked context has changed.
-        // Failing to do this will result in unnecessary calls to componentWillReceiveProps.
-        // This may trigger infinite loops if componentWillReceiveProps calls setState.
-
-        var instance = workInProgress.stateNode;
-
-        if (
-          instance &&
-          instance.__reactInternalMemoizedUnmaskedChildContext ===
-            unmaskedContext
-        ) {
-          return instance.__reactInternalMemoizedMaskedChildContext;
-        }
-
-        var context = {};
-
-        for (var key in contextTypes) {
-          context[key] = unmaskedContext[key];
-        }
-
-        {
-          var name = getComponentNameFromFiber(workInProgress) || "Unknown";
-          checkPropTypes(contextTypes, context, "context", name);
-        } // Cache unmasked context so we can avoid recreating masked context unless necessary.
-        // Context is created before the class component is instantiated so check for instance.
-
-        if (instance) {
-          cacheContext(workInProgress, unmaskedContext, context);
-        }
-
-        return context;
-      }
-    }
-
     function hasContextChanged() {
       {
-        return didPerformWorkStackCursor.current;
+        return false;
       }
     }
 
     function isContextProvider(type) {
       {
-        var childContextTypes = type.childContextTypes;
-        return childContextTypes !== null && childContextTypes !== undefined;
-      }
-    }
-
-    function popContext(fiber) {
-      {
-        pop(didPerformWorkStackCursor, fiber);
-        pop(contextStackCursor$1, fiber);
-      }
-    }
-
-    function popTopLevelContextObject(fiber) {
-      {
-        pop(didPerformWorkStackCursor, fiber);
-        pop(contextStackCursor$1, fiber);
-      }
-    }
-
-    function pushTopLevelContextObject(fiber, context, didChange) {
-      {
-        if (contextStackCursor$1.current !== emptyContextObject) {
-          throw new Error(
-            "Unexpected context found on stack. " +
-              "This error is likely caused by a bug in React. Please file an issue."
-          );
-        }
-
-        push(contextStackCursor$1, context, fiber);
-        push(didPerformWorkStackCursor, didChange, fiber);
+        return false;
       }
     }
 
     function processChildContext(fiber, type, parentContext) {
       {
-        var instance = fiber.stateNode;
-        var childContextTypes = type.childContextTypes; // TODO (bvaughn) Replace this behavior with an invariant() in the future.
-        // It has only been added in Fiber to match the (unintentional) behavior in Stack.
-
-        if (typeof instance.getChildContext !== "function") {
-          {
-            var componentName = getComponentNameFromFiber(fiber) || "Unknown";
-
-            if (!warnedAboutMissingGetChildContext[componentName]) {
-              warnedAboutMissingGetChildContext[componentName] = true;
-
-              error(
-                "%s.childContextTypes is specified but there is no getChildContext() method " +
-                  "on the instance. You can either define getChildContext() on %s or remove " +
-                  "childContextTypes from it.",
-                componentName,
-                componentName
-              );
-            }
-          }
-
-          return parentContext;
-        }
-
-        var childContext = instance.getChildContext();
-
-        for (var contextKey in childContext) {
-          if (!(contextKey in childContextTypes)) {
-            throw new Error(
-              (getComponentNameFromFiber(fiber) || "Unknown") +
-                '.getChildContext(): key "' +
-                contextKey +
-                '" is not defined in childContextTypes.'
-            );
-          }
-        }
-
-        {
-          var name = getComponentNameFromFiber(fiber) || "Unknown";
-          checkPropTypes(
-            childContextTypes,
-            childContext,
-            "child context",
-            name
-          );
-        }
-
-        return assign({}, parentContext, childContext);
-      }
-    }
-
-    function pushContextProvider(workInProgress) {
-      {
-        var instance = workInProgress.stateNode; // We push the context as early as possible to ensure stack integrity.
-        // If the instance does not exist yet, we will push null at first,
-        // and replace it on the stack later when invalidating the context.
-
-        var memoizedMergedChildContext =
-          (instance && instance.__reactInternalMemoizedMergedChildContext) ||
-          emptyContextObject; // Remember the parent context so we can merge with it later.
-        // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
-
-        previousContext = contextStackCursor$1.current;
-        push(contextStackCursor$1, memoizedMergedChildContext, workInProgress);
-        push(
-          didPerformWorkStackCursor,
-          didPerformWorkStackCursor.current,
-          workInProgress
-        );
-        return true;
-      }
-    }
-
-    function invalidateContextProvider(workInProgress, type, didChange) {
-      {
-        var instance = workInProgress.stateNode;
-
-        if (!instance) {
-          throw new Error(
-            "Expected to have an instance by this point. " +
-              "This error is likely caused by a bug in React. Please file an issue."
-          );
-        }
-
-        if (didChange) {
-          // Merge parent and own context.
-          // Skip this if we're not updating due to sCU.
-          // This avoids unnecessarily recomputing memoized values.
-          var mergedContext = processChildContext(
-            workInProgress,
-            type,
-            previousContext
-          );
-          instance.__reactInternalMemoizedMergedChildContext = mergedContext; // Replace the old (or empty) context with the new one.
-          // It is important to unwind the context in the reverse order.
-
-          pop(didPerformWorkStackCursor, workInProgress);
-          pop(contextStackCursor$1, workInProgress); // Now push the new context and mark that it has changed.
-
-          push(contextStackCursor$1, mergedContext, workInProgress);
-          push(didPerformWorkStackCursor, didChange, workInProgress);
-        } else {
-          pop(didPerformWorkStackCursor, workInProgress);
-          push(didPerformWorkStackCursor, didChange, workInProgress);
-        }
+        return parentContext;
       }
     }
 
     function findCurrentUnmaskedContext(fiber) {
       {
-        // Currently this is only used with renderSubtreeIntoContainer; not sure if it
-        // makes sense elsewhere
-        if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {
-          throw new Error(
-            "Expected subtree parent to be a mounted class component. " +
-              "This error is likely caused by a bug in React. Please file an issue."
-          );
-        }
-
-        var node = fiber;
-
-        do {
-          switch (node.tag) {
-            case HostRoot:
-              return node.stateNode.context;
-
-            case ClassComponent: {
-              var Component = node.type;
-
-              if (isContextProvider(Component)) {
-                return node.stateNode.__reactInternalMemoizedMergedChildContext;
-              }
-
-              break;
-            }
-          } // $FlowFixMe[incompatible-type] we bail out when we get a null
-
-          node = node.return;
-        } while (node !== null);
-
-        throw new Error(
-          "Found unexpected detached subtree parent. " +
-            "This error is likely caused by a bug in React. Please file an issue."
-        );
+        return emptyContextObject;
       }
     }
 
@@ -6160,16 +5458,8 @@ to return true:wantsResponderID|                            |
     }
 
     var isHydrating = false; // This flag allows for warning supression when we expect there to be mismatches
-    // due to earlier mismatches or a suspended fiber.
-
-    var didSuspendOrErrorDEV = false; // Hydration errors that were thrown inside this boundary
 
     var hydrationErrors = null;
-    function didSuspendOrErrorWhileHydratingDEV() {
-      {
-        return didSuspendOrErrorDEV;
-      }
-    }
 
     function prepareToHydrateHostInstance(fiber, hostContext) {
       {
@@ -6829,7 +6119,31 @@ to return true:wantsResponderID|                            |
       } // TODO: Can we land supportsMicrotasks? Which environments don't support it?
       // Alternatively, can we move this check to the host config?
 
-      {
+      if (supportsMicrotasks) {
+        scheduleMicrotask(function () {
+          // In Safari, appending an iframe forces microtasks to run.
+          // https://github.com/facebook/react/issues/22459
+          // We don't support running callbacks in the middle of render
+          // or commit so we need to check against that.
+          var executionContext = getExecutionContext();
+
+          if (
+            (executionContext & (RenderContext | CommitContext)) !==
+            NoContext
+          ) {
+            // Note that this would still prematurely flush the callbacks
+            // if this happens outside render or commit phase (e.g. in an event).
+            // Intentionally using a macrotask instead of a microtask here. This is
+            // wrong semantically but it prevents an infinite loop. The bug is
+            // Safari's, not ours, so we just do our best to not crash even though
+            // the behavior isn't completely correct.
+            scheduleCallback$2(ImmediatePriority, cb);
+            return;
+          }
+
+          cb();
+        });
+      } else {
         // If microtasks are not supported, use Scheduler.
         scheduleCallback$2(ImmediatePriority, cb);
       }
@@ -7511,6 +6825,9 @@ to return true:wantsResponderID|                            |
       }
     }
 
+    // $FlowFixMe[method-unbinding]
+    var hasOwnProperty = Object.prototype.hasOwnProperty;
+
     /**
      * Performs equality by iterating through keys on an object and returning false
      * when any key has values which are not strictly equal between the arguments.
@@ -7552,6 +6869,61 @@ to return true:wantsResponderID|                            |
       return true;
     }
 
+    function describeBuiltInComponentFrame(name, ownerFn) {
+      {
+        var ownerName = null;
+
+        if (ownerFn) {
+          ownerName = ownerFn.displayName || ownerFn.name || null;
+        }
+
+        return describeComponentFrame(name, ownerName);
+      }
+    }
+    function describeDebugInfoFrame(name, env) {
+      return describeBuiltInComponentFrame(
+        name + (env ? " (" + env + ")" : ""),
+        null
+      );
+    }
+
+    {
+      var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
+      new PossiblyWeakMap$1();
+    }
+
+    function describeComponentFrame(name, ownerName) {
+      var sourceInfo = "";
+
+      if (ownerName) {
+        sourceInfo = " (created by " + ownerName + ")";
+      }
+
+      return "\n    in " + (name || "Unknown") + sourceInfo;
+    }
+
+    function describeClassComponentFrame(ctor, ownerFn) {
+      {
+        return describeFunctionComponentFrame(ctor, ownerFn);
+      }
+    }
+    function describeFunctionComponentFrame(fn, ownerFn) {
+      {
+        if (!fn) {
+          return "";
+        }
+
+        var name = fn.displayName || fn.name || null;
+        var ownerName = null;
+
+        if (ownerFn) {
+          ownerName = ownerFn.displayName || ownerFn.name || null;
+        }
+
+        return describeComponentFrame(name, ownerName);
+      }
+    }
+
     function describeFiber(fiber) {
       var owner = fiber._debugOwner ? fiber._debugOwner.type : null;
 
@@ -7592,7 +6964,22 @@ to return true:wantsResponderID|                            |
         var node = workInProgress;
 
         do {
-          info += describeFiber(node); // $FlowFixMe[incompatible-type] we bail out when we get a null
+          info += describeFiber(node);
+
+          if (true) {
+            // Add any Server Component stack frames in reverse order.
+            var debugInfo = node._debugInfo;
+
+            if (debugInfo) {
+              for (var i = debugInfo.length - 1; i >= 0; i--) {
+                var entry = debugInfo[i];
+
+                if (typeof entry.name === "string") {
+                  info += describeDebugInfoFrame(entry.name, entry.env);
+                }
+              }
+            }
+          } // $FlowFixMe[incompatible-type] we bail out when we get a null
 
           node = node.return;
         } while (node);
@@ -7838,7 +7225,7 @@ to return true:wantsResponderID|                            |
 
             error(
               "Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. " +
-                "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n" +
+                "See https://react.dev/link/unsafe-component-lifecycles for details.\n\n" +
                 "* Move code with side effects to componentDidMount, and set initial state in the constructor.\n" +
                 "\nPlease update the following components: %s",
               sortedNames
@@ -7853,11 +7240,11 @@ to return true:wantsResponderID|                            |
             error(
               "Using UNSAFE_componentWillReceiveProps in strict mode is not recommended " +
                 "and may indicate bugs in your code. " +
-                "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n" +
+                "See https://react.dev/link/unsafe-component-lifecycles for details.\n\n" +
                 "* Move data fetching code or side effects to componentDidUpdate.\n" +
                 "* If you're updating state whenever props change, " +
                 "refactor your code to use memoization techniques or move it to " +
-                "static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n" +
+                "static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n" +
                 "\nPlease update the following components: %s",
               _sortedNames
             );
@@ -7871,7 +7258,7 @@ to return true:wantsResponderID|                            |
             error(
               "Using UNSAFE_componentWillUpdate in strict mode is not recommended " +
                 "and may indicate bugs in your code. " +
-                "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n" +
+                "See https://react.dev/link/unsafe-component-lifecycles for details.\n\n" +
                 "* Move data fetching code or side effects to componentDidUpdate.\n" +
                 "\nPlease update the following components: %s",
               _sortedNames2
@@ -7885,7 +7272,7 @@ to return true:wantsResponderID|                            |
 
             warn(
               "componentWillMount has been renamed, and is not recommended for use. " +
-                "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n" +
+                "See https://react.dev/link/unsafe-component-lifecycles for details.\n\n" +
                 "* Move code with side effects to componentDidMount, and set initial state in the constructor.\n" +
                 "* Rename componentWillMount to UNSAFE_componentWillMount to suppress " +
                 "this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. " +
@@ -7903,11 +7290,11 @@ to return true:wantsResponderID|                            |
 
             warn(
               "componentWillReceiveProps has been renamed, and is not recommended for use. " +
-                "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n" +
+                "See https://react.dev/link/unsafe-component-lifecycles for details.\n\n" +
                 "* Move data fetching code or side effects to componentDidUpdate.\n" +
                 "* If you're updating state whenever props change, refactor your " +
                 "code to use memoization techniques or move it to " +
-                "static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n" +
+                "static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n" +
                 "* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress " +
                 "this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. " +
                 "To rename all deprecated lifecycles to their new names, you can run " +
@@ -7924,7 +7311,7 @@ to return true:wantsResponderID|                            |
 
             warn(
               "componentWillUpdate has been renamed, and is not recommended for use. " +
-                "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n" +
+                "See https://react.dev/link/unsafe-component-lifecycles for details.\n\n" +
                 "* Move data fetching code or side effects to componentDidUpdate.\n" +
                 "* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress " +
                 "this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. " +
@@ -7997,7 +7384,7 @@ to return true:wantsResponderID|                            |
                 "\n\nThe old API will be supported in all 16.x releases, but applications " +
                 "using it should migrate to the new version." +
                 "\n\nPlease update the following components: %s" +
-                "\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context",
+                "\n\nLearn more about this warning here: https://react.dev/link/legacy-context",
               sortedNames
             );
           } finally {
@@ -8277,20 +7664,20 @@ to return true:wantsResponderID|                            |
                   rejectedThenable.reason = error;
                 }
               }
-            ); // Check one more time in case the thenable resolved synchronously.
+            );
+          } // Check one more time in case the thenable resolved synchronously.
 
-            switch (thenable.status) {
-              case "fulfilled": {
-                var fulfilledThenable = thenable;
-                return fulfilledThenable.value;
-              }
+          switch (thenable.status) {
+            case "fulfilled": {
+              var fulfilledThenable = thenable;
+              return fulfilledThenable.value;
+            }
 
-              case "rejected": {
-                var rejectedThenable = thenable;
-                var _rejectedError = rejectedThenable.reason;
-                checkIfUseWrappedInAsyncCatch(_rejectedError);
-                throw _rejectedError;
-              }
+            case "rejected": {
+              var rejectedThenable = thenable;
+              var _rejectedError = rejectedThenable.reason;
+              checkIfUseWrappedInAsyncCatch(_rejectedError);
+              throw _rejectedError;
             }
           } // Suspend.
           //
@@ -8368,11 +7755,26 @@ to return true:wantsResponderID|                            |
 
     var thenableState$1 = null;
     var thenableIndexCounter$1 = 0;
+
+    function mergeDebugInfo(outer, inner) {
+      if (inner == null) {
+        return outer;
+      } else if (outer === null) {
+        return inner;
+      } else {
+        // If we have two debugInfo, we need to create a new one. This makes the array no longer
+        // live so we'll miss any future updates if we received more so ideally we should always
+        // do this after both have fully resolved/unsuspended.
+        return outer.concat(inner);
+      }
+    }
+
     var didWarnAboutMaps;
     var didWarnAboutGenerators;
     var didWarnAboutStringRefs;
     var ownerHasKeyUseWarning;
     var ownerHasFunctionTypeWarning;
+    var ownerHasSymbolTypeWarning;
 
     var warnForMissingKey = function (child, returnFiber) {};
 
@@ -8388,6 +7790,7 @@ to return true:wantsResponderID|                            |
 
       ownerHasKeyUseWarning = {};
       ownerHasFunctionTypeWarning = {};
+      ownerHasSymbolTypeWarning = {};
 
       warnForMissingKey = function (child, returnFiber) {
         if (child === null || typeof child !== "object") {
@@ -8417,7 +7820,7 @@ to return true:wantsResponderID|                            |
 
         error(
           "Each child in a list should have a unique " +
-            '"key" prop. See https://reactjs.org/link/warning-keys for ' +
+            '"key" prop. See https://react.dev/link/warning-keys for ' +
             "more information."
         );
       };
@@ -8438,122 +7841,128 @@ to return true:wantsResponderID|                            |
       return trackUsedThenable(thenableState$1, thenable, index);
     }
 
-    function coerceRef(returnFiber, current, element) {
-      var mixedRef = element.ref;
-
-      if (
-        mixedRef !== null &&
-        typeof mixedRef !== "function" &&
-        typeof mixedRef !== "object"
-      ) {
-        {
-          if (
-            // Will already throw with "Function components cannot have string refs"
-            !(element._owner && element._owner.tag !== ClassComponent) && // Will already warn with "Function components cannot be given refs"
-            !(
-              typeof element.type === "function" && !isReactClass(element.type)
-            ) && // Will already throw with "Element ref was specified as a string (someStringRef) but no owner was set"
-            element._owner
-          ) {
-            var componentName =
-              getComponentNameFromFiber(returnFiber) || "Component";
-
-            if (!didWarnAboutStringRefs[componentName]) {
-              error(
-                'Component "%s" contains the string ref "%s". Support for string refs ' +
-                  "will be removed in a future major release. We recommend using " +
-                  "useRef() or createRef() instead. " +
-                  "Learn more about using refs safely here: " +
-                  "https://reactjs.org/link/strict-mode-string-ref",
-                componentName,
-                mixedRef
-              );
-
-              didWarnAboutStringRefs[componentName] = true;
-            }
-          }
-        }
+    function convertStringRefToCallbackRef(
+      returnFiber,
+      current,
+      element,
+      mixedRef
+    ) {
+      {
+        checkPropStringCoercion(mixedRef, "ref");
+      }
 
-        if (element._owner) {
-          var owner = element._owner;
-          var inst;
+      var stringRef = "" + mixedRef;
+      var owner = element._owner;
 
-          if (owner) {
-            var ownerFiber = owner;
+      if (!owner) {
+        throw new Error(
+          "Element ref was specified as a string (" +
+            stringRef +
+            ") but no owner was set. This could happen for one of" +
+            " the following reasons:\n" +
+            "1. You may be adding a ref to a function component\n" +
+            "2. You may be adding a ref to a component that was not created inside a component's render method\n" +
+            "3. You have multiple copies of React loaded\n" +
+            "See https://react.dev/link/refs-must-have-owner for more information."
+        );
+      }
 
-            if (ownerFiber.tag !== ClassComponent) {
-              throw new Error(
-                "Function components cannot have string refs. " +
-                  "We recommend using useRef() instead. " +
-                  "Learn more about using refs safely here: " +
-                  "https://reactjs.org/link/strict-mode-string-ref"
-              );
-            }
+      if (owner.tag !== ClassComponent) {
+        throw new Error(
+          "Function components cannot have string refs. " +
+            "We recommend using useRef() instead. " +
+            "Learn more about using refs safely here: " +
+            "https://react.dev/link/strict-mode-string-ref"
+        );
+      }
 
-            inst = ownerFiber.stateNode;
-          }
+      {
+        if (
+          // Will already warn with "Function components cannot be given refs"
+          !(typeof element.type === "function" && !isReactClass(element.type))
+        ) {
+          var componentName =
+            getComponentNameFromFiber(returnFiber) || "Component";
 
-          if (!inst) {
-            throw new Error(
-              "Missing owner for string ref " +
-                mixedRef +
-                ". This error is likely caused by a " +
-                "bug in React. Please file an issue."
+          if (!didWarnAboutStringRefs[componentName]) {
+            error(
+              'Component "%s" contains the string ref "%s". Support for string refs ' +
+                "will be removed in a future major release. We recommend using " +
+                "useRef() or createRef() instead. " +
+                "Learn more about using refs safely here: " +
+                "https://react.dev/link/strict-mode-string-ref",
+              componentName,
+              stringRef
             );
-          } // Assigning this to a const so Flow knows it won't change in the closure
-
-          var resolvedInst = inst;
 
-          {
-            checkPropStringCoercion(mixedRef, "ref");
+            didWarnAboutStringRefs[componentName] = true;
           }
+        }
+      }
 
-          var stringRef = "" + mixedRef; // Check if previous string ref matches new string ref
+      var inst = owner.stateNode;
 
-          if (
-            current !== null &&
-            current.ref !== null &&
-            typeof current.ref === "function" &&
-            current.ref._stringRef === stringRef
-          ) {
-            return current.ref;
-          }
+      if (!inst) {
+        throw new Error(
+          "Missing owner for string ref " +
+            stringRef +
+            ". This error is likely caused by a " +
+            "bug in React. Please file an issue."
+        );
+      } // Check if previous string ref matches new string ref
 
-          var ref = function (value) {
-            var refs = resolvedInst.refs;
+      if (
+        current !== null &&
+        current.ref !== null &&
+        typeof current.ref === "function" &&
+        current.ref._stringRef === stringRef
+      ) {
+        // Reuse the existing string ref
+        var currentRef = current.ref;
+        return currentRef;
+      } // Create a new string ref
 
-            if (value === null) {
-              delete refs[stringRef];
-            } else {
-              refs[stringRef] = value;
-            }
-          };
+      var ref = function (value) {
+        var refs = inst.refs;
 
-          ref._stringRef = stringRef;
-          return ref;
+        if (value === null) {
+          delete refs[stringRef];
         } else {
-          if (typeof mixedRef !== "string") {
-            throw new Error(
-              "Expected ref to be a function, a string, an object returned by React.createRef(), or null."
-            );
-          }
-
-          if (!element._owner) {
-            throw new Error(
-              "Element ref was specified as a string (" +
-                mixedRef +
-                ") but no owner was set. This could happen for one of" +
-                " the following reasons:\n" +
-                "1. You may be adding a ref to a function component\n" +
-                "2. You may be adding a ref to a component that was not created inside a component's render method\n" +
-                "3. You have multiple copies of React loaded\n" +
-                "See https://reactjs.org/link/refs-must-have-owner for more information."
-            );
-          }
+          refs[stringRef] = value;
         }
+      };
+
+      ref._stringRef = stringRef;
+      return ref;
+    }
+
+    function coerceRef(returnFiber, current, workInProgress, element) {
+      var mixedRef;
+
+      {
+        // Old behavior.
+        mixedRef = element.ref;
       }
 
-      return mixedRef;
+      var coercedRef;
+
+      if (
+        typeof mixedRef === "string" ||
+        typeof mixedRef === "number" ||
+        typeof mixedRef === "boolean"
+      ) {
+        coercedRef = convertStringRefToCallbackRef(
+          returnFiber,
+          current,
+          element,
+          mixedRef
+        );
+      } else {
+        coercedRef = mixedRef;
+      } // TODO: If enableRefAsProp is on, we shouldn't use the `ref` field. We
+      // should always read the ref from the prop.
+
+      workInProgress.ref = coercedRef;
     }
 
     function throwOnInvalidObjectType(returnFiber, newChild) {
@@ -8570,22 +7979,68 @@ to return true:wantsResponderID|                            |
       );
     }
 
-    function warnOnFunctionType(returnFiber) {
+    function warnOnFunctionType(returnFiber, invalidChild) {
       {
-        var componentName =
-          getComponentNameFromFiber(returnFiber) || "Component";
+        var parentName = getComponentNameFromFiber(returnFiber) || "Component";
 
-        if (ownerHasFunctionTypeWarning[componentName]) {
+        if (ownerHasFunctionTypeWarning[parentName]) {
           return;
         }
 
-        ownerHasFunctionTypeWarning[componentName] = true;
+        ownerHasFunctionTypeWarning[parentName] = true;
+        var name = invalidChild.displayName || invalidChild.name || "Component";
 
-        error(
-          "Functions are not valid as a React child. This may happen if " +
-            "you return a Component instead of <Component /> from render. " +
-            "Or maybe you meant to call this function rather than return it."
-        );
+        if (returnFiber.tag === HostRoot) {
+          error(
+            "Functions are not valid as a React child. This may happen if " +
+              "you return %s instead of <%s /> from render. " +
+              "Or maybe you meant to call this function rather than return it.\n" +
+              "  root.render(%s)",
+            name,
+            name,
+            name
+          );
+        } else {
+          error(
+            "Functions are not valid as a React child. This may happen if " +
+              "you return %s instead of <%s /> from render. " +
+              "Or maybe you meant to call this function rather than return it.\n" +
+              "  <%s>{%s}</%s>",
+            name,
+            name,
+            parentName,
+            name,
+            parentName
+          );
+        }
+      }
+    }
+
+    function warnOnSymbolType(returnFiber, invalidChild) {
+      {
+        var parentName = getComponentNameFromFiber(returnFiber) || "Component";
+
+        if (ownerHasSymbolTypeWarning[parentName]) {
+          return;
+        }
+
+        ownerHasSymbolTypeWarning[parentName] = true; // eslint-disable-next-line react-internal/safe-string-coercion
+
+        var name = String(invalidChild);
+
+        if (returnFiber.tag === HostRoot) {
+          error(
+            "Symbols are not valid as a React child.\n" + "  root.render(%s)",
+            name
+          );
+        } else {
+          error(
+            "Symbols are not valid as a React child.\n" + "  <%s>%s</%s>",
+            parentName,
+            name,
+            parentName
+          );
+        }
       }
     }
 
@@ -8632,7 +8087,7 @@ to return true:wantsResponderID|                            |
         return null;
       }
 
-      function mapRemainingChildren(returnFiber, currentFirstChild) {
+      function mapRemainingChildren(currentFirstChild) {
         // Add the remaining children to a temporary map so that we can find them by
         // keys quickly. Implicit (null) keys get added to this set with their index
         // instead.
@@ -8701,7 +8156,13 @@ to return true:wantsResponderID|                            |
         return newFiber;
       }
 
-      function updateTextNode(returnFiber, current, textContent, lanes) {
+      function updateTextNode(
+        returnFiber,
+        current,
+        textContent,
+        lanes,
+        debugInfo
+      ) {
         if (current === null || current.tag !== HostText) {
           // Insert
           var created = createFiberFromText(
@@ -8710,16 +8171,26 @@ to return true:wantsResponderID|                            |
             lanes
           );
           created.return = returnFiber;
+
+          {
+            created._debugInfo = debugInfo;
+          }
+
           return created;
         } else {
           // Update
           var existing = useFiber(current, textContent);
           existing.return = returnFiber;
+
+          {
+            existing._debugInfo = debugInfo;
+          }
+
           return existing;
         }
       }
 
-      function updateElement(returnFiber, current, element, lanes) {
+      function updateElement(returnFiber, current, element, lanes, debugInfo) {
         var elementType = element.type;
 
         if (elementType === REACT_FRAGMENT_TYPE) {
@@ -8728,7 +8199,8 @@ to return true:wantsResponderID|                            |
             current,
             element.props.children,
             lanes,
-            element.key
+            element.key,
+            debugInfo
           );
         }
 
@@ -8746,11 +8218,12 @@ to return true:wantsResponderID|                            |
           ) {
             // Move based on index
             var existing = useFiber(current, element.props);
-            existing.ref = coerceRef(returnFiber, current, element);
+            coerceRef(returnFiber, current, existing, element);
             existing.return = returnFiber;
 
             {
               existing._debugOwner = element._owner;
+              existing._debugInfo = debugInfo;
             }
 
             return existing;
@@ -8758,12 +8231,17 @@ to return true:wantsResponderID|                            |
         } // Insert
 
         var created = createFiberFromElement(element, returnFiber.mode, lanes);
-        created.ref = coerceRef(returnFiber, current, element);
+        coerceRef(returnFiber, current, created, element);
         created.return = returnFiber;
+
+        {
+          created._debugInfo = debugInfo;
+        }
+
         return created;
       }
 
-      function updatePortal(returnFiber, current, portal, lanes) {
+      function updatePortal(returnFiber, current, portal, lanes, debugInfo) {
         if (
           current === null ||
           current.tag !== HostPortal ||
@@ -8773,16 +8251,33 @@ to return true:wantsResponderID|                            |
           // Insert
           var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
           created.return = returnFiber;
+
+          {
+            created._debugInfo = debugInfo;
+          }
+
           return created;
         } else {
           // Update
           var existing = useFiber(current, portal.children || []);
           existing.return = returnFiber;
+
+          {
+            existing._debugInfo = debugInfo;
+          }
+
           return existing;
         }
       }
 
-      function updateFragment(returnFiber, current, fragment, lanes, key) {
+      function updateFragment(
+        returnFiber,
+        current,
+        fragment,
+        lanes,
+        key,
+        debugInfo
+      ) {
         if (current === null || current.tag !== Fragment) {
           // Insert
           var created = createFiberFromFragment(
@@ -8792,29 +8287,46 @@ to return true:wantsResponderID|                            |
             key
           );
           created.return = returnFiber;
+
+          {
+            created._debugInfo = debugInfo;
+          }
+
           return created;
         } else {
           // Update
           var existing = useFiber(current, fragment);
           existing.return = returnFiber;
+
+          {
+            existing._debugInfo = debugInfo;
+          }
+
           return existing;
         }
       }
 
-      function createChild(returnFiber, newChild, lanes) {
+      function createChild(returnFiber, newChild, lanes, debugInfo) {
         if (
           (typeof newChild === "string" && newChild !== "") ||
-          typeof newChild === "number"
+          typeof newChild === "number" ||
+          enableBigIntSupport
         ) {
           // Text nodes don't have keys. If the previous node is implicitly keyed
           // we can continue to replace it without aborting even if it is not a text
           // node.
           var created = createFiberFromText(
+            // $FlowFixMe[unsafe-addition] Flow doesn't want us to use `+` operator with string and bigint
             "" + newChild,
             returnFiber.mode,
             lanes
           );
           created.return = returnFiber;
+
+          {
+            created._debugInfo = debugInfo;
+          }
+
           return created;
         }
 
@@ -8827,8 +8339,16 @@ to return true:wantsResponderID|                            |
                 lanes
               );
 
-              _created.ref = coerceRef(returnFiber, null, newChild);
+              coerceRef(returnFiber, null, _created, newChild);
               _created.return = returnFiber;
+
+              {
+                _created._debugInfo = mergeDebugInfo(
+                  debugInfo,
+                  newChild._debugInfo
+                );
+              }
+
               return _created;
             }
 
@@ -8840,13 +8360,23 @@ to return true:wantsResponderID|                            |
               );
 
               _created2.return = returnFiber;
+
+              {
+                _created2._debugInfo = debugInfo;
+              }
+
               return _created2;
             }
 
             case REACT_LAZY_TYPE: {
               var payload = newChild._payload;
               var init = newChild._init;
-              return createChild(returnFiber, init(payload), lanes);
+              return createChild(
+                returnFiber,
+                init(payload),
+                lanes,
+                mergeDebugInfo(debugInfo, newChild._debugInfo) // call merge after init
+              );
             }
           }
 
@@ -8859,6 +8389,14 @@ to return true:wantsResponderID|                            |
             );
 
             _created3.return = returnFiber;
+
+            {
+              _created3._debugInfo = mergeDebugInfo(
+                debugInfo,
+                newChild._debugInfo
+              );
+            }
+
             return _created3;
           } // Usable node types
           //
@@ -8866,15 +8404,21 @@ to return true:wantsResponderID|                            |
 
           if (typeof newChild.then === "function") {
             var thenable = newChild;
-            return createChild(returnFiber, unwrapThenable(thenable), lanes);
+            return createChild(
+              returnFiber,
+              unwrapThenable(thenable),
+              lanes,
+              mergeDebugInfo(debugInfo, newChild._debugInfo)
+            );
           }
 
           if (newChild.$$typeof === REACT_CONTEXT_TYPE) {
             var context = newChild;
             return createChild(
               returnFiber,
-              readContextDuringReconcilation(returnFiber, context, lanes),
-              lanes
+              readContextDuringReconciliation(returnFiber, context, lanes),
+              lanes,
+              debugInfo
             );
           }
 
@@ -8883,20 +8427,25 @@ to return true:wantsResponderID|                            |
 
         {
           if (typeof newChild === "function") {
-            warnOnFunctionType(returnFiber);
+            warnOnFunctionType(returnFiber, newChild);
+          }
+
+          if (typeof newChild === "symbol") {
+            warnOnSymbolType(returnFiber, newChild);
           }
         }
 
         return null;
       }
 
-      function updateSlot(returnFiber, oldFiber, newChild, lanes) {
+      function updateSlot(returnFiber, oldFiber, newChild, lanes, debugInfo) {
         // Update the fiber if the keys match, otherwise return null.
         var key = oldFiber !== null ? oldFiber.key : null;
 
         if (
           (typeof newChild === "string" && newChild !== "") ||
-          typeof newChild === "number"
+          typeof newChild === "number" ||
+          enableBigIntSupport
         ) {
           // Text nodes don't have keys. If the previous node is implicitly keyed
           // we can continue to replace it without aborting even if it is not a text
@@ -8905,14 +8454,26 @@ to return true:wantsResponderID|                            |
             return null;
           }
 
-          return updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
+          return updateTextNode(
+            returnFiber,
+            oldFiber, // $FlowFixMe[unsafe-addition] Flow doesn't want us to use `+` operator with string and bigint
+            "" + newChild,
+            lanes,
+            debugInfo
+          );
         }
 
         if (typeof newChild === "object" && newChild !== null) {
           switch (newChild.$$typeof) {
             case REACT_ELEMENT_TYPE: {
               if (newChild.key === key) {
-                return updateElement(returnFiber, oldFiber, newChild, lanes);
+                return updateElement(
+                  returnFiber,
+                  oldFiber,
+                  newChild,
+                  lanes,
+                  mergeDebugInfo(debugInfo, newChild._debugInfo)
+                );
               } else {
                 return null;
               }
@@ -8920,7 +8481,13 @@ to return true:wantsResponderID|                            |
 
             case REACT_PORTAL_TYPE: {
               if (newChild.key === key) {
-                return updatePortal(returnFiber, oldFiber, newChild, lanes);
+                return updatePortal(
+                  returnFiber,
+                  oldFiber,
+                  newChild,
+                  lanes,
+                  debugInfo
+                );
               } else {
                 return null;
               }
@@ -8929,7 +8496,13 @@ to return true:wantsResponderID|                            |
             case REACT_LAZY_TYPE: {
               var payload = newChild._payload;
               var init = newChild._init;
-              return updateSlot(returnFiber, oldFiber, init(payload), lanes);
+              return updateSlot(
+                returnFiber,
+                oldFiber,
+                init(payload),
+                lanes,
+                mergeDebugInfo(debugInfo, newChild._debugInfo)
+              );
             }
           }
 
@@ -8938,7 +8511,14 @@ to return true:wantsResponderID|                            |
               return null;
             }
 
-            return updateFragment(returnFiber, oldFiber, newChild, lanes, null);
+            return updateFragment(
+              returnFiber,
+              oldFiber,
+              newChild,
+              lanes,
+              null,
+              mergeDebugInfo(debugInfo, newChild._debugInfo)
+            );
           } // Usable node types
           //
           // Unwrap the inner value and recursively call this function again.
@@ -8949,7 +8529,8 @@ to return true:wantsResponderID|                            |
               returnFiber,
               oldFiber,
               unwrapThenable(thenable),
-              lanes
+              lanes,
+              debugInfo
             );
           }
 
@@ -8958,8 +8539,9 @@ to return true:wantsResponderID|                            |
             return updateSlot(
               returnFiber,
               oldFiber,
-              readContextDuringReconcilation(returnFiber, context, lanes),
-              lanes
+              readContextDuringReconciliation(returnFiber, context, lanes),
+              lanes,
+              debugInfo
             );
           }
 
@@ -8968,7 +8550,11 @@ to return true:wantsResponderID|                            |
 
         {
           if (typeof newChild === "function") {
-            warnOnFunctionType(returnFiber);
+            warnOnFunctionType(returnFiber, newChild);
+          }
+
+          if (typeof newChild === "symbol") {
+            warnOnSymbolType(returnFiber, newChild);
           }
         }
 
@@ -8980,20 +8566,23 @@ to return true:wantsResponderID|                            |
         returnFiber,
         newIdx,
         newChild,
-        lanes
+        lanes,
+        debugInfo
       ) {
         if (
           (typeof newChild === "string" && newChild !== "") ||
-          typeof newChild === "number"
+          typeof newChild === "number" ||
+          enableBigIntSupport
         ) {
           // Text nodes don't have keys, so we neither have to check the old nor
           // new node for the key. If both are text nodes, they match.
           var matchedFiber = existingChildren.get(newIdx) || null;
           return updateTextNode(
             returnFiber,
-            matchedFiber,
+            matchedFiber, // $FlowFixMe[unsafe-addition] Flow doesn't want us to use `+` operator with string and bigint
             "" + newChild,
-            lanes
+            lanes,
+            debugInfo
           );
         }
 
@@ -9005,7 +8594,13 @@ to return true:wantsResponderID|                            |
                   newChild.key === null ? newIdx : newChild.key
                 ) || null;
 
-              return updateElement(returnFiber, _matchedFiber, newChild, lanes);
+              return updateElement(
+                returnFiber,
+                _matchedFiber,
+                newChild,
+                lanes,
+                mergeDebugInfo(debugInfo, newChild._debugInfo)
+              );
             }
 
             case REACT_PORTAL_TYPE: {
@@ -9014,7 +8609,13 @@ to return true:wantsResponderID|                            |
                   newChild.key === null ? newIdx : newChild.key
                 ) || null;
 
-              return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
+              return updatePortal(
+                returnFiber,
+                _matchedFiber2,
+                newChild,
+                lanes,
+                debugInfo
+              );
             }
 
             case REACT_LAZY_TYPE:
@@ -9025,7 +8626,8 @@ to return true:wantsResponderID|                            |
                 returnFiber,
                 newIdx,
                 init(payload),
-                lanes
+                lanes,
+                mergeDebugInfo(debugInfo, newChild._debugInfo)
               );
           }
 
@@ -9037,7 +8639,8 @@ to return true:wantsResponderID|                            |
               _matchedFiber3,
               newChild,
               lanes,
-              null
+              null,
+              mergeDebugInfo(debugInfo, newChild._debugInfo)
             );
           } // Usable node types
           //
@@ -9050,7 +8653,8 @@ to return true:wantsResponderID|                            |
               returnFiber,
               newIdx,
               unwrapThenable(thenable),
-              lanes
+              lanes,
+              debugInfo
             );
           }
 
@@ -9060,8 +8664,9 @@ to return true:wantsResponderID|                            |
               existingChildren,
               returnFiber,
               newIdx,
-              readContextDuringReconcilation(returnFiber, context, lanes),
-              lanes
+              readContextDuringReconciliation(returnFiber, context, lanes),
+              lanes,
+              debugInfo
             );
           }
 
@@ -9070,7 +8675,11 @@ to return true:wantsResponderID|                            |
 
         {
           if (typeof newChild === "function") {
-            warnOnFunctionType(returnFiber);
+            warnOnFunctionType(returnFiber, newChild);
+          }
+
+          if (typeof newChild === "symbol") {
+            warnOnSymbolType(returnFiber, newChild);
           }
         }
 
@@ -9133,7 +8742,8 @@ to return true:wantsResponderID|                            |
         returnFiber,
         currentFirstChild,
         newChildren,
-        lanes
+        lanes,
+        debugInfo
       ) {
         // This algorithm can't optimize by searching from both ends since we
         // don't have backpointers on fibers. I'm trying to see how far we can get
@@ -9179,7 +8789,8 @@ to return true:wantsResponderID|                            |
             returnFiber,
             oldFiber,
             newChildren[newIdx],
-            lanes
+            lanes,
+            debugInfo
           );
 
           if (newFiber === null) {
@@ -9233,7 +8844,8 @@ to return true:wantsResponderID|                            |
             var _newFiber = createChild(
               returnFiber,
               newChildren[newIdx],
-              lanes
+              lanes,
+              debugInfo
             );
 
             if (_newFiber === null) {
@@ -9255,7 +8867,7 @@ to return true:wantsResponderID|                            |
           return resultingFirstChild;
         } // Add all children to a key map for quick lookups.
 
-        var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.
+        var existingChildren = mapRemainingChildren(oldFiber); // Keep scanning and use the map to restore deleted items as moves.
 
         for (; newIdx < newChildren.length; newIdx++) {
           var _newFiber2 = updateFromMap(
@@ -9263,7 +8875,8 @@ to return true:wantsResponderID|                            |
             returnFiber,
             newIdx,
             newChildren[newIdx],
-            lanes
+            lanes,
+            debugInfo
           );
 
           if (_newFiber2 !== null) {
@@ -9306,7 +8919,8 @@ to return true:wantsResponderID|                            |
         returnFiber,
         currentFirstChild,
         newChildrenIterable,
-        lanes
+        lanes,
+        debugInfo
       ) {
         // This is the same implementation as reconcileChildrenArray(),
         // but using the iterator instead.
@@ -9391,7 +9005,13 @@ to return true:wantsResponderID|                            |
             nextOldFiber = oldFiber.sibling;
           }
 
-          var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
+          var newFiber = updateSlot(
+            returnFiber,
+            oldFiber,
+            step.value,
+            lanes,
+            debugInfo
+          );
 
           if (newFiber === null) {
             // TODO: This breaks on empty slots like null children. That's
@@ -9441,7 +9061,12 @@ to return true:wantsResponderID|                            |
           // If we don't have any more existing children we can choose a fast path
           // since the rest will all be insertions.
           for (; !step.done; newIdx++, step = newChildren.next()) {
-            var _newFiber3 = createChild(returnFiber, step.value, lanes);
+            var _newFiber3 = createChild(
+              returnFiber,
+              step.value,
+              lanes,
+              debugInfo
+            );
 
             if (_newFiber3 === null) {
               continue;
@@ -9462,7 +9087,7 @@ to return true:wantsResponderID|                            |
           return resultingFirstChild;
         } // Add all children to a key map for quick lookups.
 
-        var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.
+        var existingChildren = mapRemainingChildren(oldFiber); // Keep scanning and use the map to restore deleted items as moves.
 
         for (; !step.done; newIdx++, step = newChildren.next()) {
           var _newFiber4 = updateFromMap(
@@ -9470,7 +9095,8 @@ to return true:wantsResponderID|                            |
             returnFiber,
             newIdx,
             step.value,
-            lanes
+            lanes,
+            debugInfo
           );
 
           if (_newFiber4 !== null) {
@@ -9537,7 +9163,8 @@ to return true:wantsResponderID|                            |
         returnFiber,
         currentFirstChild,
         element,
-        lanes
+        lanes,
+        debugInfo
       ) {
         var key = element.key;
         var child = currentFirstChild;
@@ -9556,6 +9183,7 @@ to return true:wantsResponderID|                            |
 
                 {
                   existing._debugOwner = element._owner;
+                  existing._debugInfo = debugInfo;
                 }
 
                 return existing;
@@ -9576,11 +9204,12 @@ to return true:wantsResponderID|                            |
 
                 var _existing = useFiber(child, element.props);
 
-                _existing.ref = coerceRef(returnFiber, child, element);
+                coerceRef(returnFiber, child, _existing, element);
                 _existing.return = returnFiber;
 
                 {
                   _existing._debugOwner = element._owner;
+                  _existing._debugInfo = debugInfo;
                 }
 
                 return _existing;
@@ -9604,6 +9233,11 @@ to return true:wantsResponderID|                            |
             element.key
           );
           created.return = returnFiber;
+
+          {
+            created._debugInfo = debugInfo;
+          }
+
           return created;
         } else {
           var _created4 = createFiberFromElement(
@@ -9612,8 +9246,13 @@ to return true:wantsResponderID|                            |
             lanes
           );
 
-          _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
+          coerceRef(returnFiber, currentFirstChild, _created4, element);
           _created4.return = returnFiber;
+
+          {
+            _created4._debugInfo = debugInfo;
+          }
+
           return _created4;
         }
       }
@@ -9622,7 +9261,8 @@ to return true:wantsResponderID|                            |
         returnFiber,
         currentFirstChild,
         portal,
-        lanes
+        lanes,
+        debugInfo
       ) {
         var key = portal.key;
         var child = currentFirstChild;
@@ -9662,7 +9302,8 @@ to return true:wantsResponderID|                            |
         returnFiber,
         currentFirstChild,
         newChild,
-        lanes
+        lanes,
+        debugInfo
       ) {
         // This function is not recursive.
         // If the top level item is an array, we treat it as a set of children,
@@ -9690,7 +9331,8 @@ to return true:wantsResponderID|                            |
                   returnFiber,
                   currentFirstChild,
                   newChild,
-                  lanes
+                  lanes,
+                  mergeDebugInfo(debugInfo, newChild._debugInfo)
                 )
               );
 
@@ -9706,13 +9348,13 @@ to return true:wantsResponderID|                            |
 
             case REACT_LAZY_TYPE:
               var payload = newChild._payload;
-              var init = newChild._init; // TODO: This function is supposed to be non-recursive.
-
-              return reconcileChildFibers(
+              var init = newChild._init;
+              return reconcileChildFibersImpl(
                 returnFiber,
                 currentFirstChild,
                 init(payload),
-                lanes
+                lanes,
+                mergeDebugInfo(debugInfo, newChild._debugInfo)
               );
           }
 
@@ -9721,7 +9363,8 @@ to return true:wantsResponderID|                            |
               returnFiber,
               currentFirstChild,
               newChild,
-              lanes
+              lanes,
+              mergeDebugInfo(debugInfo, newChild._debugInfo)
             );
           }
 
@@ -9730,7 +9373,8 @@ to return true:wantsResponderID|                            |
               returnFiber,
               currentFirstChild,
               newChild,
-              lanes
+              lanes,
+              mergeDebugInfo(debugInfo, newChild._debugInfo)
             );
           } // Usables are a valid React node type. When React encounters a Usable in
           // a child position, it unwraps it using the same algorithm as `use`. For
@@ -9755,7 +9399,8 @@ to return true:wantsResponderID|                            |
               returnFiber,
               currentFirstChild,
               unwrapThenable(thenable),
-              lanes
+              lanes,
+              mergeDebugInfo(debugInfo, thenable._debugInfo)
             );
           }
 
@@ -9764,8 +9409,9 @@ to return true:wantsResponderID|                            |
             return reconcileChildFibersImpl(
               returnFiber,
               currentFirstChild,
-              readContextDuringReconcilation(returnFiber, context, lanes),
-              lanes
+              readContextDuringReconciliation(returnFiber, context, lanes),
+              lanes,
+              debugInfo
             );
           }
 
@@ -9774,12 +9420,13 @@ to return true:wantsResponderID|                            |
 
         if (
           (typeof newChild === "string" && newChild !== "") ||
-          typeof newChild === "number"
+          typeof newChild === "number" ||
+          enableBigIntSupport
         ) {
           return placeSingleChild(
             reconcileSingleTextNode(
               returnFiber,
-              currentFirstChild,
+              currentFirstChild, // $FlowFixMe[unsafe-addition] Flow doesn't want us to use `+` operator with string and bigint
               "" + newChild,
               lanes
             )
@@ -9788,7 +9435,11 @@ to return true:wantsResponderID|                            |
 
         {
           if (typeof newChild === "function") {
-            warnOnFunctionType(returnFiber);
+            warnOnFunctionType(returnFiber, newChild);
+          }
+
+          if (typeof newChild === "symbol") {
+            warnOnSymbolType(returnFiber, newChild);
           }
         } // Remaining cases are all treated as empty.
 
@@ -9808,7 +9459,8 @@ to return true:wantsResponderID|                            |
           returnFiber,
           currentFirstChild,
           newChild,
-          lanes
+          lanes,
+          null // debugInfo
         );
         thenableState$1 = null; // Don't bother to reset `thenableIndexCounter` to 0 because it always gets
         // set at the beginning.
@@ -10244,7 +9896,7 @@ to return true:wantsResponderID|                            |
             error(
               "React has detected a change in the order of Hooks called by %s. " +
                 "This will lead to bugs and errors if not fixed. " +
-                "For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n" +
+                "For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\n\n" +
                 "   Previous render            Next render\n" +
                 "   ------------------------------------------------------\n" +
                 "%s" +
@@ -10295,7 +9947,7 @@ to return true:wantsResponderID|                            |
           "1. You might have mismatching versions of React and the renderer (such as React DOM)\n" +
           "2. You might be breaking the Rules of Hooks\n" +
           "3. You might have more than one copy of React in the same app\n" +
-          "See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem."
+          "See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
       );
     }
 
@@ -11867,8 +11519,8 @@ to return true:wantsResponderID|                            |
     }
 
     function updateTransition() {
-      var _updateState = updateState(),
-        booleanOrThenable = _updateState[0];
+      var _updateState2 = updateState(),
+        booleanOrThenable = _updateState2[0];
 
       var hook = updateWorkInProgressHook();
       var start = hook.memoizedState;
@@ -12127,7 +11779,7 @@ to return true:wantsResponderID|                            |
           "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. " +
             "You can only call Hooks at the top level of your React function. " +
             "For more information, see " +
-            "https://reactjs.org/link/rules-of-hooks"
+            "https://react.dev/link/rules-of-hooks"
         );
       };
 
@@ -13156,7 +12808,6 @@ to return true:wantsResponderID|                            |
     var didWarnAboutLegacyLifecyclesAndDerivedState;
     var didWarnAboutUndefinedDerivedState;
     var didWarnAboutDirectlyAssigningPropsToState;
-    var didWarnAboutContextTypeAndContextTypes;
     var didWarnAboutInvalidateContextType;
     var didWarnOnInvalidCallback;
 
@@ -13167,7 +12818,6 @@ to return true:wantsResponderID|                            |
       didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
       didWarnAboutDirectlyAssigningPropsToState = new Set();
       didWarnAboutUndefinedDerivedState = new Set();
-      didWarnAboutContextTypeAndContextTypes = new Set();
       didWarnAboutInvalidateContextType = new Set();
       didWarnOnInvalidCallback = new Set(); // This is so gross but it's at least non-critical and can be removed if
       // it causes problems. This is meant to give a nicer error message for
@@ -13191,21 +12841,20 @@ to return true:wantsResponderID|                            |
       Object.freeze(fakeInternalInstance);
     }
 
-    function warnOnInvalidCallback(callback, callerName) {
+    function warnOnInvalidCallback(callback) {
       {
         if (callback === null || typeof callback === "function") {
           return;
-        }
+        } // eslint-disable-next-line react-internal/safe-string-coercion
 
-        var key = callerName + "_" + callback;
+        var key = String(callback);
 
         if (!didWarnOnInvalidCallback.has(key)) {
           didWarnOnInvalidCallback.add(key);
 
           error(
-            "%s(...): Expected the last optional `callback` argument to be a " +
+            "Expected the last optional `callback` argument to be a " +
               "function. Instead received: %s.",
-            callerName,
             callback
           );
         }
@@ -13279,7 +12928,7 @@ to return true:wantsResponderID|                            |
 
         if (callback !== undefined && callback !== null) {
           {
-            warnOnInvalidCallback(callback, "setState");
+            warnOnInvalidCallback(callback);
           }
 
           update.callback = callback;
@@ -13301,7 +12950,7 @@ to return true:wantsResponderID|                            |
 
         if (callback !== undefined && callback !== null) {
           {
-            warnOnInvalidCallback(callback, "replaceState");
+            warnOnInvalidCallback(callback);
           }
 
           update.callback = callback;
@@ -13323,7 +12972,7 @@ to return true:wantsResponderID|                            |
 
         if (callback !== undefined && callback !== null) {
           {
-            warnOnInvalidCallback(callback, "forceUpdate");
+            warnOnInvalidCallback(callback);
           }
 
           update.callback = callback;
@@ -13403,13 +13052,13 @@ to return true:wantsResponderID|                            |
         if (!renderPresent) {
           if (ctor.prototype && typeof ctor.prototype.render === "function") {
             error(
-              "%s(...): No `render` method found on the returned component " +
+              "No `render` method found on the %s " +
                 "instance: did you accidentally return an object from the constructor?",
               name
             );
           } else {
             error(
-              "%s(...): No `render` method found on the returned component " +
+              "No `render` method found on the %s " +
                 "instance: you may have forgotten to define `render`.",
               name
             );
@@ -13458,24 +13107,18 @@ to return true:wantsResponderID|                            |
         }
 
         {
-          if (instance.contextTypes) {
+          if (ctor.childContextTypes) {
             error(
-              "contextTypes was defined as an instance property on %s. Use a static " +
-                "property to define contextTypes instead.",
+              "%s uses the legacy childContextTypes API which is no longer supported. " +
+                "Use React.createContext() instead.",
               name
             );
           }
 
-          if (
-            ctor.contextType &&
-            ctor.contextTypes &&
-            !didWarnAboutContextTypeAndContextTypes.has(ctor)
-          ) {
-            didWarnAboutContextTypeAndContextTypes.add(ctor);
-
+          if (ctor.contextTypes) {
             error(
-              "%s declares both contextTypes and contextType static properties. " +
-                "The legacy contextTypes property will be ignored.",
+              "%s uses the legacy contextTypes API which is no longer supported. " +
+                "Use React.createContext() with static contextType instead.",
               name
             );
           }
@@ -13544,9 +13187,8 @@ to return true:wantsResponderID|                            |
 
         if (instance.props !== undefined && hasMutatedProps) {
           error(
-            "%s(...): When calling super() in `%s`, make sure to pass " +
+            "When calling super() in `%s`, make sure to pass " +
               "up the same props that your component's constructor was passed.",
-            name,
             name
           );
         }
@@ -13629,8 +13271,6 @@ to return true:wantsResponderID|                            |
     }
 
     function constructClassInstance(workInProgress, ctor, props) {
-      var isLegacyContextConsumer = false;
-      var unmaskedContext = emptyContextObject;
       var context = emptyContextObject;
       var contextType = ctor.contextType;
 
@@ -13639,8 +13279,7 @@ to return true:wantsResponderID|                            |
           var isValid = // Allow null for conditional declaration
             contextType === null ||
             (contextType !== undefined &&
-              contextType.$$typeof === REACT_CONTEXT_TYPE &&
-              contextType._context === undefined); // Not a <Context.Consumer>
+              contextType.$$typeof === REACT_CONTEXT_TYPE);
 
           if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
             didWarnAboutInvalidateContextType.add(ctor);
@@ -13654,11 +13293,7 @@ to return true:wantsResponderID|                            |
                 "try moving the createContext() call to a separate file.";
             } else if (typeof contextType !== "object") {
               addendum = " However, it is set to a " + typeof contextType + ".";
-            } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
-              addendum =
-                " Did you accidentally pass the Context.Provider instead?";
-            } else if (contextType._context !== undefined) {
-              // <Context.Consumer>
+            } else if (contextType.$$typeof === REACT_CONSUMER_TYPE) {
               addendum =
                 " Did you accidentally pass the Context.Consumer instead?";
             } else {
@@ -13680,14 +13315,6 @@ to return true:wantsResponderID|                            |
 
       if (typeof contextType === "object" && contextType !== null) {
         context = readContext(contextType);
-      } else {
-        unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
-        var contextTypes = ctor.contextTypes;
-        isLegacyContextConsumer =
-          contextTypes !== null && contextTypes !== undefined;
-        context = isLegacyContextConsumer
-          ? getMaskedContext(workInProgress, unmaskedContext)
-          : emptyContextObject;
       }
 
       var instance = new ctor(props, context); // Instantiate twice to help detect side-effects.
@@ -13795,7 +13422,7 @@ to return true:wantsResponderID|                            |
                 "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n" +
                   "%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n" +
                   "The above lifecycles should be removed. Learn more about this warning here:\n" +
-                  "https://reactjs.org/link/unsafe-component-lifecycles",
+                  "https://react.dev/link/unsafe-component-lifecycles",
                 _componentName,
                 newApiName,
                 foundWillMountName !== null ? "\n  " + foundWillMountName : "",
@@ -13808,11 +13435,6 @@ to return true:wantsResponderID|                            |
           }
         }
       } // Cache unmasked context so we can avoid recreating masked context unless necessary.
-      // ReactFiberContext usually updates this cache but can't for newly-created instances.
-
-      if (isLegacyContextConsumer) {
-        cacheContext(workInProgress, unmaskedContext, context);
-      }
 
       return instance;
     }
@@ -13902,8 +13524,7 @@ to return true:wantsResponderID|                            |
       if (typeof contextType === "object" && contextType !== null) {
         instance.context = readContext(contextType);
       } else {
-        var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
-        instance.context = getMaskedContext(workInProgress, unmaskedContext);
+        instance.context = emptyContextObject;
       }
 
       {
@@ -13981,22 +13602,12 @@ to return true:wantsResponderID|                            |
       var instance = workInProgress.stateNode;
       var oldProps = workInProgress.memoizedProps;
       instance.props = oldProps;
-      var oldContext = instance.context;
-      var contextType = ctor.contextType;
-      var nextContext = emptyContextObject;
-
-      if (typeof contextType === "object" && contextType !== null) {
-        nextContext = readContext(contextType);
-      } else {
-        var nextLegacyUnmaskedContext = getUnmaskedContext(
-          workInProgress,
-          ctor,
-          true
-        );
-        nextContext = getMaskedContext(
-          workInProgress,
-          nextLegacyUnmaskedContext
-        );
+      var oldContext = instance.context;
+      var contextType = ctor.contextType;
+      var nextContext = emptyContextObject;
+
+      if (typeof contextType === "object" && contextType !== null) {
+        nextContext = readContext(contextType);
       }
 
       var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
@@ -14140,13 +13751,6 @@ to return true:wantsResponderID|                            |
 
       if (typeof contextType === "object" && contextType !== null) {
         nextContext = readContext(contextType);
-      } else {
-        var nextUnmaskedContext = getUnmaskedContext(
-          workInProgress,
-          ctor,
-          true
-        );
-        nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);
       }
 
       var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
@@ -14300,17 +13904,37 @@ to return true:wantsResponderID|                            |
       return shouldUpdate;
     }
 
+    var CapturedStacks = new WeakMap();
     function createCapturedValueAtFiber(value, source) {
       // If the value is an error, call this function immediately after it is thrown
       // so the stack is accurate.
+      var stack;
+
+      if (typeof value === "object" && value !== null) {
+        var capturedStack = CapturedStacks.get(value);
+
+        if (typeof capturedStack === "string") {
+          stack = capturedStack;
+        } else {
+          stack = getStackByFiberInDevAndProd(source);
+          CapturedStacks.set(value, stack);
+        }
+      } else {
+        stack = getStackByFiberInDevAndProd(source);
+      }
+
       return {
         value: value,
         source: source,
-        stack: getStackByFiberInDevAndProd(source),
+        stack: stack,
         digest: null
       };
     }
-    function createCapturedValue(value, digest, stack) {
+    function createCapturedValueFromError(value, digest, stack) {
+      if (typeof stack === "string") {
+        CapturedStacks.set(value, stack);
+      }
+
       return {
         value: value,
         source: null,
@@ -14356,25 +13980,8 @@ to return true:wantsResponderID|                            |
         if (true) {
           var source = errorInfo.source;
           var stack = errorInfo.stack;
-          var componentStack = stack !== null ? stack : ""; // Browsers support silencing uncaught errors by calling
-          // `preventDefault()` in window `error` handler.
-          // We record this information as an expando on the error.
-
-          if (error != null && error._suppressLogging) {
-            if (boundary.tag === ClassComponent) {
-              // The error is recoverable and was silenced.
-              // Ignore it and don't print the stack addendum.
-              // This is handy for testing error boundaries without noise.
-              return;
-            } // The error is fatal. Since the silencing might have
-            // been accidental, we'll surface it anyway.
-            // However, the browser would have silenced the original error
-            // so we'll print it first, and then print the stack addendum.
-
-            console["error"](error); // Don't transform to our wrapper
-            // For a more detailed description of this block, see:
-            // https://github.com/facebook/react/pull/13384
-          }
+          var componentStack = stack !== null ? stack : ""; // TODO: There's no longer a way to silence these warnings e.g. for tests.
+          // See https://github.com/facebook/react/pull/13384
 
           var componentName = source ? getComponentNameFromFiber(source) : null;
           var componentNameMessage = componentName
@@ -14387,7 +13994,7 @@ to return true:wantsResponderID|                            |
           if (boundary.tag === HostRoot) {
             errorBoundaryMessage =
               "Consider adding an error boundary to your tree to customize error handling behavior.\n" +
-              "Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.";
+              "Visit https://react.dev/link/error-boundaries to learn more about error boundaries.";
           } else {
             var errorBoundaryName =
               getComponentNameFromFiber(boundary) || "Anonymous";
@@ -14396,19 +14003,17 @@ to return true:wantsResponderID|                            |
               ("using the error boundary you provided, " +
                 errorBoundaryName +
                 ".");
-          }
-
-          var combinedMessage =
-            componentNameMessage +
-            "\n" +
-            componentStack +
-            "\n\n" +
-            ("" + errorBoundaryMessage); // In development, we provide our own message with just the component stack.
-          // We don't include the original error message and JS stack because the browser
-          // has already printed it. Even if the application swallows the error, it is still
-          // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
-
-          console["error"](combinedMessage); // Don't transform to our wrapper
+          } // In development, we provide our own message which includes the component stack
+          // in addition to the error.
+
+          console["error"](
+            // Don't transform to our wrapper
+            "%o\n\n%s\n%s\n\n%s",
+            error,
+            componentNameMessage,
+            componentStack,
+            errorBoundaryMessage
+          );
         }
       } catch (e) {
         // This method must not throw, or React internal state will get messed up.
@@ -14999,25 +14604,13 @@ to return true:wantsResponderID|                            |
       // TODO: current can be non-null here even if the component
       // hasn't yet mounted. This happens after the first render suspends.
       // We'll need to figure out if this is fine or can cause issues.
-      {
-        if (workInProgress.type !== workInProgress.elementType) {
-          // Lazy component props can't be validated in createElement
-          // because they're only guaranteed to be resolved here.
-          var innerPropTypes = Component.propTypes;
-
-          if (innerPropTypes) {
-            checkPropTypes(
-              innerPropTypes,
-              nextProps, // Resolved props
-              "prop",
-              getComponentNameFromType(Component)
-            );
-          }
-        }
-      }
-
       var render = Component.render;
-      var ref = workInProgress.ref; // The rest is a fork of updateFunctionComponent
+      var ref = workInProgress.ref;
+      var propsWithoutRef;
+
+      {
+        propsWithoutRef = nextProps;
+      } // The rest is a fork of updateFunctionComponent
 
       var nextChildren;
       prepareToReadContext(workInProgress, renderLanes);
@@ -15029,7 +14622,7 @@ to return true:wantsResponderID|                            |
           current,
           workInProgress,
           render,
-          nextProps,
+          propsWithoutRef,
           ref,
           renderLanes
         );
@@ -15090,19 +14683,6 @@ to return true:wantsResponderID|                            |
         }
 
         {
-          var innerPropTypes = type.propTypes;
-
-          if (innerPropTypes) {
-            // Inner memo component props aren't currently validated in createElement.
-            // We could move it there, but we'd still need this for lazy code path.
-            checkPropTypes(
-              innerPropTypes,
-              nextProps, // Resolved props
-              "prop",
-              getComponentNameFromType(type)
-            );
-          }
-
           if (Component.defaultProps !== undefined) {
             var componentName = getComponentNameFromType(type) || "Unknown";
 
@@ -15132,22 +14712,6 @@ to return true:wantsResponderID|                            |
         return child;
       }
 
-      {
-        var _type = Component.type;
-        var _innerPropTypes = _type.propTypes;
-
-        if (_innerPropTypes) {
-          // Inner memo component props aren't currently validated in createElement.
-          // We could move it there, but we'd still need this for lazy code path.
-          checkPropTypes(
-            _innerPropTypes,
-            nextProps, // Resolved props
-            "prop",
-            getComponentNameFromType(_type)
-          );
-        }
-      }
-
       var currentChild = current.child; // This is always exactly one child
 
       var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(
@@ -15193,40 +14757,6 @@ to return true:wantsResponderID|                            |
       // TODO: current can be non-null here even if the component
       // hasn't yet mounted. This happens when the inner render suspends.
       // We'll need to figure out if this is fine or can cause issues.
-      {
-        if (workInProgress.type !== workInProgress.elementType) {
-          // Lazy component props can't be validated in createElement
-          // because they're only guaranteed to be resolved here.
-          var outerMemoType = workInProgress.elementType;
-
-          if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
-            // We warn when you define propTypes on lazy()
-            // so let's just skip over it to find memo() outer wrapper.
-            // Inner props for memo are validated later.
-            var lazyComponent = outerMemoType;
-            var payload = lazyComponent._payload;
-            var init = lazyComponent._init;
-
-            try {
-              outerMemoType = init(payload);
-            } catch (x) {
-              outerMemoType = null;
-            } // Inner propTypes will be validated in the function component path.
-
-            var outerPropTypes = outerMemoType && outerMemoType.propTypes;
-
-            if (outerPropTypes) {
-              checkPropTypes(
-                outerPropTypes,
-                nextProps, // Resolved (SimpleMemoComponent has no defaultProps)
-                "prop",
-                getComponentNameFromType(outerMemoType)
-              );
-            }
-          }
-        }
-      }
-
       if (current !== null) {
         var prevProps = current.memoizedProps;
 
@@ -15299,7 +14829,7 @@ to return true:wantsResponderID|                            |
       var nextIsDetached =
         (workInProgress.stateNode._pendingVisibility & OffscreenDetached) !== 0;
       var prevState = current !== null ? current.memoizedState : null;
-      markRef$1(current, workInProgress);
+      markRef(current, workInProgress);
 
       if (nextProps.mode === "hidden" || enableLegacyHidden || nextIsDetached) {
         // Rendering a hidden tree.
@@ -15464,16 +14994,26 @@ to return true:wantsResponderID|                            |
       return workInProgress.child;
     }
 
-    function markRef$1(current, workInProgress) {
+    function markRef(current, workInProgress) {
+      // TODO: Check props.ref instead of fiber.ref when enableRefAsProp is on.
       var ref = workInProgress.ref;
 
-      if (
-        (current === null && ref !== null) ||
-        (current !== null && current.ref !== ref)
-      ) {
-        // Schedule a Ref effect
-        workInProgress.flags |= Ref;
-        workInProgress.flags |= RefStatic;
+      if (ref === null) {
+        if (current !== null && current.ref !== null) {
+          // Schedule a Ref effect
+          workInProgress.flags |= Ref | RefStatic;
+        }
+      } else {
+        if (typeof ref !== "function" && typeof ref !== "object") {
+          throw new Error(
+            "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
+          );
+        }
+
+        if (current === null || current.ref !== ref) {
+          // Schedule a Ref effect
+          workInProgress.flags |= Ref | RefStatic;
+        }
       }
     }
 
@@ -15484,34 +15024,8 @@ to return true:wantsResponderID|                            |
       nextProps,
       renderLanes
     ) {
-      {
-        if (workInProgress.type !== workInProgress.elementType) {
-          // Lazy component props can't be validated in createElement
-          // because they're only guaranteed to be resolved here.
-          var innerPropTypes = Component.propTypes;
-
-          if (innerPropTypes) {
-            checkPropTypes(
-              innerPropTypes,
-              nextProps, // Resolved props
-              "prop",
-              getComponentNameFromType(Component)
-            );
-          }
-        }
-      }
-
       var context;
 
-      {
-        var unmaskedContext = getUnmaskedContext(
-          workInProgress,
-          Component,
-          true
-        );
-        context = getMaskedContext(workInProgress, unmaskedContext);
-      }
-
       var nextChildren;
       prepareToReadContext(workInProgress, renderLanes);
 
@@ -15621,30 +15135,14 @@ to return true:wantsResponderID|                            |
             break;
           }
         }
-
-        if (workInProgress.type !== workInProgress.elementType) {
-          // Lazy component props can't be validated in createElement
-          // because they're only guaranteed to be resolved here.
-          var innerPropTypes = Component.propTypes;
-
-          if (innerPropTypes) {
-            checkPropTypes(
-              innerPropTypes,
-              nextProps, // Resolved props
-              "prop",
-              getComponentNameFromType(Component)
-            );
-          }
-        }
       } // Push context providers early to prevent context stack mismatches.
       // During mounting we don't know the child context yet as the instance doesn't exist.
       // We will invalidate the child context in finishClassComponent() right after rendering.
 
       var hasContext;
 
-      if (isContextProvider(Component)) {
+      if (isContextProvider()) {
         hasContext = true;
-        pushContextProvider(workInProgress);
       } else {
         hasContext = false;
       }
@@ -15714,15 +15212,10 @@ to return true:wantsResponderID|                            |
       renderLanes
     ) {
       // Refs should update even if shouldComponentUpdate returns false
-      markRef$1(current, workInProgress);
+      markRef(current, workInProgress);
       var didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags$1;
 
       if (!shouldUpdate && !didCaptureError) {
-        // Context providers should defer to sCU for rendering
-        if (hasContext) {
-          invalidateContextProvider(workInProgress, Component, false);
-        }
-
         return bailoutOnAlreadyFinishedWork(
           current,
           workInProgress,
@@ -15788,27 +15281,12 @@ to return true:wantsResponderID|                            |
 
       workInProgress.memoizedState = instance.state; // The context might have changed so we need to recalculate it.
 
-      if (hasContext) {
-        invalidateContextProvider(workInProgress, Component, true);
-      }
-
       return workInProgress.child;
     }
 
     function pushHostRootContext(workInProgress) {
       var root = workInProgress.stateNode;
 
-      if (root.pendingContext) {
-        pushTopLevelContextObject(
-          workInProgress,
-          root.pendingContext,
-          root.pendingContext !== root.context
-        );
-      } else if (root.context) {
-        // Should always be set
-        pushTopLevelContextObject(workInProgress, root.context, false);
-      }
-
       pushHostContainer(workInProgress, root.containerInfo);
     }
 
@@ -15860,7 +15338,7 @@ to return true:wantsResponderID|                            |
         workInProgress.flags |= ContentReset;
       }
 
-      markRef$1(current, workInProgress);
+      markRef(current, workInProgress);
       reconcileChildren(current, workInProgress, nextChildren, renderLanes);
       return workInProgress.child;
     }
@@ -15941,21 +15419,6 @@ to return true:wantsResponderID|                            |
         }
 
         case MemoComponent: {
-          {
-            if (workInProgress.type !== workInProgress.elementType) {
-              var outerPropTypes = Component.propTypes;
-
-              if (outerPropTypes) {
-                checkPropTypes(
-                  outerPropTypes,
-                  resolvedProps, // Resolved for outer only
-                  "prop",
-                  getComponentNameFromType(Component)
-                );
-              }
-            }
-          }
-
           child = updateMemoComponent(
             null,
             workInProgress,
@@ -16005,9 +15468,8 @@ to return true:wantsResponderID|                            |
 
       var hasContext;
 
-      if (isContextProvider(Component)) {
+      if (isContextProvider()) {
         hasContext = true;
-        pushContextProvider(workInProgress);
       } else {
         hasContext = false;
       }
@@ -16035,15 +15497,6 @@ to return true:wantsResponderID|                            |
       var props = workInProgress.pendingProps;
       var context;
 
-      {
-        var unmaskedContext = getUnmaskedContext(
-          workInProgress,
-          Component,
-          false
-        );
-        context = getMaskedContext(workInProgress, unmaskedContext);
-      }
-
       prepareToReadContext(workInProgress, renderLanes);
       var value;
 
@@ -16153,9 +15606,8 @@ to return true:wantsResponderID|                            |
 
         var hasContext = false;
 
-        if (isContextProvider(Component)) {
+        if (isContextProvider()) {
           hasContext = true;
-          pushContextProvider(workInProgress);
         } else {
           hasContext = false;
         }
@@ -16179,6 +15631,16 @@ to return true:wantsResponderID|                            |
         // Proceed under the assumption that this is a function component
         workInProgress.tag = FunctionComponent;
 
+        {
+          if (Component.contextTypes) {
+            error(
+              "%s uses the legacy contextTypes API which is no longer supported. " +
+                "Use React.createContext() with React.useContext() instead.",
+              getComponentNameFromType(Component) || "Unknown"
+            );
+          }
+        }
+
         reconcileChildren(null, workInProgress, value, renderLanes);
 
         {
@@ -16194,7 +15656,8 @@ to return true:wantsResponderID|                            |
         if (Component) {
           if (Component.childContextTypes) {
             error(
-              "%s(...): childContextTypes cannot be defined on a function component.",
+              "childContextTypes cannot be defined on a function component.\n" +
+                "  %s.childContextTypes = ...",
               Component.displayName || Component.name || "Component"
             );
           }
@@ -16828,7 +16291,7 @@ to return true:wantsResponderID|                            |
             }
 
             error.digest = digest;
-            capturedValue = createCapturedValue(error, digest, stack);
+            capturedValue = createCapturedValueFromError(error, digest, stack);
           }
 
           return retrySuspenseComponentWithoutHydrating(
@@ -16938,7 +16401,7 @@ to return true:wantsResponderID|                            |
           pushPrimaryTreeSuspenseHandler(workInProgress);
           workInProgress.flags &= ~ForceClientRender;
 
-          var _capturedValue = createCapturedValue(
+          var _capturedValue = createCapturedValueFromError(
             new Error(
               "There was an error while hydrating this Suspense boundary. " +
                 "Switched to client rendering."
@@ -17427,8 +16890,12 @@ to return true:wantsResponderID|                            |
     var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
 
     function updateContextProvider(current, workInProgress, renderLanes) {
-      var providerType = workInProgress.type;
-      var context = providerType._context;
+      var context;
+
+      {
+        context = workInProgress.type._context;
+      }
+
       var newProps = workInProgress.pendingProps;
       var oldProps = workInProgress.memoizedProps;
       var newValue = newProps.value;
@@ -17443,17 +16910,6 @@ to return true:wantsResponderID|                            |
             );
           }
         }
-
-        var providerPropTypes = workInProgress.type.propTypes;
-
-        if (providerPropTypes) {
-          checkPropTypes(
-            providerPropTypes,
-            newProps,
-            "prop",
-            "Context.Provider"
-          );
-        }
       }
 
       pushProvider(workInProgress, context, newValue);
@@ -17487,34 +16943,16 @@ to return true:wantsResponderID|                            |
       return workInProgress.child;
     }
 
-    var hasWarnedAboutUsingContextAsConsumer = false;
-
     function updateContextConsumer(current, workInProgress, renderLanes) {
-      var context = workInProgress.type; // The logic below for Context differs depending on PROD or DEV mode. In
-      // DEV mode, we create a separate object for Context.Consumer that acts
-      // like a proxy to Context. This proxy object adds unnecessary code in PROD
-      // so we use the old behaviour (Context.Consumer references Context) to
-      // reduce size and overhead. The separate object references context via
-      // a property called "_context", which also gives us the ability to check
-      // in DEV mode if this property exists or not and warn if it does not.
+      var context;
 
       {
-        if (context._context === undefined) {
-          // This may be because it's a Context (rather than a Consumer).
-          // Or it may be because it's older React where they're the same thing.
-          // We only want to warn if we're sure it's a new React.
-          if (context !== context.Consumer) {
-            if (!hasWarnedAboutUsingContextAsConsumer) {
-              hasWarnedAboutUsingContextAsConsumer = true;
+        context = workInProgress.type;
 
-              error(
-                "Rendering <Context> directly is not supported and will be removed in " +
-                  "a future major release. Did you mean to render <Context.Consumer> instead?"
-              );
-            }
+        {
+          if (context._context !== undefined) {
+            context = context._context;
           }
-        } else {
-          context = context._context;
         }
       }
 
@@ -17615,7 +17053,11 @@ to return true:wantsResponderID|                            |
         newWorkInProgress.index = oldWorkInProgress.index;
         newWorkInProgress.sibling = oldWorkInProgress.sibling;
         newWorkInProgress.return = oldWorkInProgress.return;
-        newWorkInProgress.ref = oldWorkInProgress.ref; // Replace the child/sibling pointers above it.
+        newWorkInProgress.ref = oldWorkInProgress.ref;
+
+        {
+          newWorkInProgress._debugInfo = oldWorkInProgress._debugInfo;
+        } // Replace the child/sibling pointers above it.
 
         if (oldWorkInProgress === returnFiber.child) {
           returnFiber.child = newWorkInProgress;
@@ -17687,12 +17129,6 @@ to return true:wantsResponderID|                            |
           break;
 
         case ClassComponent: {
-          var Component = workInProgress.type;
-
-          if (isContextProvider(Component)) {
-            pushContextProvider(workInProgress);
-          }
-
           break;
         }
 
@@ -17705,7 +17141,12 @@ to return true:wantsResponderID|                            |
 
         case ContextProvider: {
           var newValue = workInProgress.memoizedProps.value;
-          var context = workInProgress.type._context;
+          var context;
+
+          {
+            context = workInProgress.type._context;
+          }
+
           pushProvider(workInProgress, context, newValue);
           break;
         }
@@ -17863,7 +17304,7 @@ to return true:wantsResponderID|                            |
       return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
     }
 
-    function beginWork$1(current, workInProgress, renderLanes) {
+    function beginWork(current, workInProgress, renderLanes) {
       {
         if (workInProgress._debugNeedsRemount && current !== null) {
           // This will restart the begin phase with a new fiber.
@@ -18049,31 +17490,16 @@ to return true:wantsResponderID|                            |
           return updateContextConsumer(current, workInProgress, renderLanes);
 
         case MemoComponent: {
-          var _type2 = workInProgress.type;
+          var _type = workInProgress.type;
           var _unresolvedProps3 = workInProgress.pendingProps; // Resolve outer props first, then resolve inner props.
 
-          var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
-
-          {
-            if (workInProgress.type !== workInProgress.elementType) {
-              var outerPropTypes = _type2.propTypes;
-
-              if (outerPropTypes) {
-                checkPropTypes(
-                  outerPropTypes,
-                  _resolvedProps3, // Resolved for outer only
-                  "prop",
-                  getComponentNameFromType(_type2)
-                );
-              }
-            }
-          }
+          var _resolvedProps3 = resolveDefaultProps(_type, _unresolvedProps3);
 
-          _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
+          _resolvedProps3 = resolveDefaultProps(_type.type, _resolvedProps3);
           return updateMemoComponent(
             current,
             workInProgress,
-            _type2,
+            _type,
             _resolvedProps3,
             renderLanes
           );
@@ -18437,7 +17863,7 @@ to return true:wantsResponderID|                            |
 
       return readContextForConsumer(currentlyRenderingFiber, context);
     }
-    function readContextDuringReconcilation(consumer, context, renderLanes) {
+    function readContextDuringReconciliation(consumer, context, renderLanes) {
       if (currentlyRenderingFiber === null) {
         prepareToReadContext(consumer, renderLanes);
       }
@@ -18486,6 +17912,10 @@ to return true:wantsResponderID|                            |
       var transition = ReactCurrentBatchConfig$1.transition;
 
       if (transition !== null) {
+        if (!transition._callbacks) {
+          transition._callbacks = new Set();
+        }
+
         // Whenever a transition update is scheduled, register a callback on the
         // transition object so we can get the return value of the scope function.
         transition._callbacks.add(handleAsyncAction);
@@ -18516,10 +17946,6 @@ to return true:wantsResponderID|                            |
     function markUpdate(workInProgress) {
       workInProgress.flags |= Update;
     }
-
-    function markRef(workInProgress) {
-      workInProgress.flags |= Ref | RefStatic;
-    }
     /**
      * In persistent mode, return whether this update needs to clone the subtree.
      */
@@ -19159,12 +18585,6 @@ to return true:wantsResponderID|                            |
           return null;
 
         case ClassComponent: {
-          var Component = workInProgress.type;
-
-          if (isContextProvider(Component)) {
-            popContext(workInProgress);
-          }
-
           bubbleProperties(workInProgress);
           return null;
         }
@@ -19172,7 +18592,6 @@ to return true:wantsResponderID|                            |
         case HostRoot: {
           var fiberRoot = workInProgress.stateNode;
           popHostContainer(workInProgress);
-          popTopLevelContextObject(workInProgress);
 
           if (fiberRoot.pendingContext) {
             fiberRoot.context = fiberRoot.pendingContext;
@@ -19229,10 +18648,6 @@ to return true:wantsResponderID|                            |
 
           if (current !== null && workInProgress.stateNode != null) {
             updateHostComponent(current, workInProgress, _type2, newProps);
-
-            if (current.ref !== workInProgress.ref) {
-              markRef(workInProgress);
-            }
           } else {
             if (!newProps) {
               if (workInProgress.stateNode === null) {
@@ -19272,11 +18687,6 @@ to return true:wantsResponderID|                            |
               appendAllChildren(_instance3, workInProgress, false, false);
               workInProgress.stateNode = _instance3; // Certain renderers require commit-time effects for initial mount.
             }
-
-            if (workInProgress.ref !== null) {
-              // If there is a ref on a host node we need to schedule a callback
-              markRef(workInProgress);
-            }
           }
 
           bubbleProperties(workInProgress); // This must come at the very end of the complete phase, because it might
@@ -19331,7 +18741,6 @@ to return true:wantsResponderID|                            |
         }
 
         case SuspenseComponent: {
-          popSuspenseHandler(workInProgress);
           var nextState = workInProgress.memoizedState; // Special path for dehydrated boundaries. We may eventually move this
           // to its own fiber type so that we can add other kinds of hydration
           // boundaries that aren't associated with a Suspense tree. In anticipation
@@ -19352,17 +18761,21 @@ to return true:wantsResponderID|                            |
 
             if (!fallthroughToNormalSuspensePath) {
               if (workInProgress.flags & ForceClientRender) {
-                // Special case. There were remaining unhydrated nodes. We treat
+                popSuspenseHandler(workInProgress); // Special case. There were remaining unhydrated nodes. We treat
                 // this as a mismatch. Revert to client rendering.
+
                 return workInProgress;
               } else {
-                // Did not finish hydrating, either because this is the initial
+                popSuspenseHandler(workInProgress); // Did not finish hydrating, either because this is the initial
                 // render or because something suspended.
+
                 return null;
               }
             } // Continue with the normal Suspense path.
           }
 
+          popSuspenseHandler(workInProgress);
+
           if ((workInProgress.flags & DidCapture) !== NoFlags$1) {
             // Something suspended. Re-render with the fallback children.
             workInProgress.lanes = renderLanes; // Do not reset the effect list.
@@ -19429,20 +18842,17 @@ to return true:wantsResponderID|                            |
 
         case ContextProvider:
           // Pop provider fiber
-          var context = workInProgress.type._context;
+          var context;
+
+          {
+            context = workInProgress.type._context;
+          }
+
           popProvider(context, workInProgress);
           bubbleProperties(workInProgress);
           return null;
 
         case IncompleteClassComponent: {
-          // Same as class component case. I put it down here so that the tags are
-          // sequential to ensure this switch is compiled to a jump table.
-          var _Component = workInProgress.type;
-
-          if (isContextProvider(_Component)) {
-            popContext(workInProgress);
-          }
-
           bubbleProperties(workInProgress);
           return null;
         }
@@ -19734,12 +19144,6 @@ to return true:wantsResponderID|                            |
     function unwindWork(current, workInProgress, renderLanes) {
       switch (workInProgress.tag) {
         case ClassComponent: {
-          var Component = workInProgress.type;
-
-          if (isContextProvider(Component)) {
-            popContext(workInProgress);
-          }
-
           var flags = workInProgress.flags;
 
           if (flags & ShouldCapture) {
@@ -19757,7 +19161,6 @@ to return true:wantsResponderID|                            |
 
         case HostRoot: {
           popHostContainer(workInProgress);
-          popTopLevelContextObject(workInProgress);
           var _flags = workInProgress.flags;
 
           if (
@@ -19821,7 +19224,12 @@ to return true:wantsResponderID|                            |
           return null;
 
         case ContextProvider:
-          var context = workInProgress.type._context;
+          var context;
+
+          {
+            context = workInProgress.type._context;
+          }
+
           popProvider(context, workInProgress);
           return null;
 
@@ -19858,18 +19266,11 @@ to return true:wantsResponderID|                            |
     function unwindInterruptedWork(current, interruptedWork, renderLanes) {
       switch (interruptedWork.tag) {
         case ClassComponent: {
-          var childContextTypes = interruptedWork.type.childContextTypes;
-
-          if (childContextTypes !== null && childContextTypes !== undefined) {
-            popContext(interruptedWork);
-          }
-
           break;
         }
 
         case HostRoot: {
           popHostContainer(interruptedWork);
-          popTopLevelContextObject(interruptedWork);
           break;
         }
 
@@ -19893,7 +19294,12 @@ to return true:wantsResponderID|                            |
           break;
 
         case ContextProvider:
-          var context = interruptedWork.type._context;
+          var context;
+
+          {
+            context = interruptedWork.type._context;
+          }
+
           popProvider(context, interruptedWork);
           break;
 
@@ -19927,20 +19333,6 @@ to return true:wantsResponderID|                            |
       );
     }
 
-    function reportUncaughtErrorInDEV(error) {
-      // Wrapping each small part of the commit phase into a guarded
-      // callback is a bit too slow (https://github.com/facebook/react/pull/21666).
-      // But we rely on it to surface errors to DEV tools like overlays
-      // (https://github.com/facebook/react/issues/21712).
-      // As a compromise, rethrow only caught errors in a guard.
-      {
-        invokeGuardedCallback(null, function () {
-          throw error;
-        });
-        clearCaughtError();
-      }
-    }
-
     function callComponentWillUnmountWithTimer(current, instance) {
       instance.props = current.memoizedProps;
       instance.state = current.memoizedState;
@@ -20317,7 +19709,7 @@ to return true:wantsResponderID|                            |
                     "  }\n" +
                     "  fetchData();\n" +
                     "}, [someId]); // Or [] if effect doesn't need props or state\n\n" +
-                    "Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching";
+                    "Learn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching";
                 } else {
                   addendum = " You returned: " + destroy;
                 }
@@ -20866,6 +20258,8 @@ to return true:wantsResponderID|                            |
           }
         } else {
           {
+            // TODO: We should move these warnings to happen during the render
+            // phase (markRef).
             if (!ref.hasOwnProperty("current")) {
               error(
                 "Unexpected ref object provided for %s. " +
@@ -22806,7 +22200,9 @@ to return true:wantsResponderID|                            |
     var workInProgressRootConcurrentErrors = null; // These are errors that we recovered from without surfacing them to the UI.
     // We will log them once the tree commits.
 
-    var workInProgressRootRecoverableErrors = null; // The most recent time we either committed a fallback, or when a fallback was
+    var workInProgressRootRecoverableErrors = null; // Tracks when an update occurs during the render phase.
+
+    var workInProgressRootDidIncludeRecursiveRenderUpdate = false; // Thacks when an update occurs during the commit phase. It's a separate
     // filled in with the resolved UI. This lets us throttle the appearance of new
     // content as it streams in, to minimize jank.
     // TODO: Think of a better name for this variable?
@@ -22830,7 +22226,7 @@ to return true:wantsResponderID|                            |
     }
     var hasUncaughtError = false;
     var firstUncaughtError = null;
-    var legacyErrorBoundariesThatAlreadyFailed = null; // Only used when enableProfilerNestedUpdateScheduledHook is true;
+    var legacyErrorBoundariesThatAlreadyFailed = null;
     var rootDoesHavePassiveEffects = false;
     var rootWithPendingPassiveEffects = null;
     var pendingPassiveEffectsLanes = NoLanes;
@@ -23322,6 +22718,7 @@ to return true:wantsResponderID|                            |
           root,
           workInProgressRootRecoverableErrors,
           workInProgressTransitions,
+          workInProgressRootDidIncludeRecursiveRenderUpdate,
           workInProgressDeferredLane
         );
       } else {
@@ -23352,6 +22749,7 @@ to return true:wantsResponderID|                            |
                 finishedWork,
                 workInProgressRootRecoverableErrors,
                 workInProgressTransitions,
+                workInProgressRootDidIncludeRecursiveRenderUpdate,
                 lanes,
                 workInProgressDeferredLane
               ),
@@ -23366,6 +22764,7 @@ to return true:wantsResponderID|                            |
           finishedWork,
           workInProgressRootRecoverableErrors,
           workInProgressTransitions,
+          workInProgressRootDidIncludeRecursiveRenderUpdate,
           lanes,
           workInProgressDeferredLane
         );
@@ -23377,6 +22776,7 @@ to return true:wantsResponderID|                            |
       finishedWork,
       recoverableErrors,
       transitions,
+      didIncludeRenderPhaseUpdate,
       lanes,
       spawnedLane
     ) {
@@ -23401,14 +22801,26 @@ to return true:wantsResponderID|                            |
           // us that it's ready. This will be canceled if we start work on the
           // root again.
           root.cancelPendingCommit = schedulePendingCommit(
-            commitRoot.bind(null, root, recoverableErrors, transitions)
+            commitRoot.bind(
+              null,
+              root,
+              recoverableErrors,
+              transitions,
+              didIncludeRenderPhaseUpdate
+            )
           );
           markRootSuspended(root, lanes, spawnedLane);
           return;
         }
       } // Otherwise, commit immediately.
 
-      commitRoot(root, recoverableErrors, transitions, spawnedLane);
+      commitRoot(
+        root,
+        recoverableErrors,
+        transitions,
+        didIncludeRenderPhaseUpdate,
+        spawnedLane
+      );
     }
 
     function isRenderConsistentWithExternalStores(finishedWork) {
@@ -23471,13 +22883,23 @@ to return true:wantsResponderID|                            |
       // eslint-disable-next-line no-unreachable
 
       return true;
+    } // The extra indirections around markRootUpdated and markRootSuspended is
+    // needed to avoid a circular dependency between this module and
+    // ReactFiberLane. There's probably a better way to split up these modules and
+    // avoid this problem. Perhaps all the root-marking functions should move into
+    // the work loop.
+
+    function markRootUpdated(root, updatedLanes) {
+      markRootUpdated$1(root, updatedLanes);
+    }
+
+    function markRootPinged(root, pingedLanes) {
+      markRootPinged$1(root, pingedLanes);
     }
 
     function markRootSuspended(root, suspendedLanes, spawnedLane) {
       // When suspending, we should always exclude lanes that were pinged or (more
       // rarely, since we try to avoid it) updated during the render phase.
-      // TODO: Lol maybe there's a better way to factor this besides this
-      // obnoxiously named function :)
       suspendedLanes = removeLanes(
         suspendedLanes,
         workInProgressRootPingedLanes
@@ -23486,6 +22908,7 @@ to return true:wantsResponderID|                            |
         suspendedLanes,
         workInProgressRootInterleavedUpdatedLanes
       );
+
       markRootSuspended$1(root, suspendedLanes, spawnedLane);
     } // This is the entry point for synchronous tasks that don't go
     // through Scheduler
@@ -23560,6 +22983,7 @@ to return true:wantsResponderID|                            |
         root,
         workInProgressRootRecoverableErrors,
         workInProgressTransitions,
+        workInProgressRootDidIncludeRecursiveRenderUpdate,
         workInProgressDeferredLane
       ); // Before exiting, make sure there's a callback scheduled for the next
       // pending level.
@@ -23704,7 +23128,8 @@ to return true:wantsResponderID|                            |
       workInProgressRootPingedLanes = NoLanes;
       workInProgressDeferredLane = NoLane;
       workInProgressRootConcurrentErrors = null;
-      workInProgressRootRecoverableErrors = null; // Get the lanes that are entangled with whatever we're about to render. We
+      workInProgressRootRecoverableErrors = null;
+      workInProgressRootDidIncludeRecursiveRenderUpdate = false; // Get the lanes that are entangled with whatever we're about to render. We
       // track these separately so we can distinguish the priority of the render
       // task from the priority of the lanes it is entangled with. For example, a
       // transition may not be allowed to finish unless it includes the Sync lane,
@@ -24379,15 +23804,6 @@ to return true:wantsResponderID|                            |
               : resolveDefaultProps(Component, unresolvedProps);
           var context;
 
-          {
-            var unmaskedContext = getUnmaskedContext(
-              unitOfWork,
-              Component,
-              true
-            );
-            context = getMaskedContext(unitOfWork, unmaskedContext);
-          }
-
           next = replayFunctionComponent(
             current,
             unitOfWork,
@@ -24668,7 +24084,13 @@ to return true:wantsResponderID|                            |
       workInProgress = null;
     }
 
-    function commitRoot(root, recoverableErrors, transitions, spawnedLane) {
+    function commitRoot(
+      root,
+      recoverableErrors,
+      transitions,
+      didIncludeRenderPhaseUpdate,
+      spawnedLane
+    ) {
       // TODO: This no longer makes any sense. We already wrap the mutation and
       // layout phases. Should be able to remove.
       var previousUpdateLanePriority = getCurrentUpdatePriority();
@@ -24681,6 +24103,7 @@ to return true:wantsResponderID|                            |
           root,
           recoverableErrors,
           transitions,
+          didIncludeRenderPhaseUpdate,
           previousUpdateLanePriority,
           spawnedLane
         );
@@ -24696,6 +24119,7 @@ to return true:wantsResponderID|                            |
       root,
       recoverableErrors,
       transitions,
+      didIncludeRenderPhaseUpdate,
       renderPriorityLevel,
       spawnedLane
     ) {
@@ -24755,7 +24179,7 @@ to return true:wantsResponderID|                            |
 
       var concurrentlyUpdatedLanes = getConcurrentlyUpdatedLanes();
       remainingLanes = mergeLanes(remainingLanes, concurrentlyUpdatedLanes);
-      markRootFinished(root, remainingLanes, spawnedLane);
+      markRootFinished(root, remainingLanes, spawnedLane); // Reset this before firing side effects so we can detect recursive updates.
 
       if (root === workInProgressRoot) {
         // We can reset these now that they are finished.
@@ -24818,7 +24242,7 @@ to return true:wantsResponderID|                            |
           // Mark the current commit time to be shared by all Profilers in this
           // batch. This enables them to be grouped later.
           recordCommitTime();
-        }
+        } // The next phase is the mutation phase, where we mutate the host tree.
 
         commitMutationEffects(root, finishedWork, lanes);
         // the mutation phase, so that the previous tree is still current during
@@ -24937,6 +24361,9 @@ to return true:wantsResponderID|                            |
       // hydration is conceptually not an update.
 
       if (
+        // Check if there was a recursive update spawned by this render, in either
+        // the render phase or the commit phase. We track these explicitly because
+        // we can't infer from the remaining lanes alone.
         // Was the finished render the result of an update (not hydration)?
         includesSomeLane(lanes, UpdateLanes) && // Did it schedule a sync update?
         includesSomeLane(remainingLanes, SyncUpdateLanes)
@@ -25136,7 +24563,6 @@ to return true:wantsResponderID|                            |
       error$1
     ) {
       {
-        reportUncaughtErrorInDEV(error$1);
         setIsRunningInsertionEffect(false);
       }
 
@@ -25358,6 +24784,7 @@ to return true:wantsResponderID|                            |
         nestedPassiveUpdateCount = 0;
         rootWithNestedUpdates = null;
         rootWithPassiveNestedUpdates = null;
+
         throw new Error(
           "Maximum update depth exceeded. This can happen when a component " +
             "repeatedly calls setState inside componentWillUpdate or " +
@@ -25514,81 +24941,6 @@ to return true:wantsResponderID|                            |
         }
       }
     }
-    var beginWork;
-
-    {
-      var dummyFiber = null;
-
-      beginWork = function (current, unitOfWork, lanes) {
-        // If a component throws an error, we replay it again in a synchronously
-        // dispatched event, so that the debugger will treat it as an uncaught
-        // error See ReactErrorUtils for more information.
-        // Before entering the begin phase, copy the work-in-progress onto a dummy
-        // fiber. If beginWork throws, we'll use this to reset the state.
-        var originalWorkInProgressCopy = assignFiberPropertiesInDEV(
-          dummyFiber,
-          unitOfWork
-        );
-
-        try {
-          return beginWork$1(current, unitOfWork, lanes);
-        } catch (originalError) {
-          if (
-            didSuspendOrErrorWhileHydratingDEV() ||
-            originalError === SuspenseException ||
-            originalError === SelectiveHydrationException ||
-            (originalError !== null &&
-              typeof originalError === "object" &&
-              typeof originalError.then === "function")
-          ) {
-            // Don't replay promises.
-            // Don't replay errors if we are hydrating and have already suspended or handled an error
-            throw originalError;
-          } // Don't reset current debug fiber, since we're about to work on the
-          // same fiber again.
-          // Unwind the failed stack frame
-
-          resetSuspendedWorkLoopOnUnwind(unitOfWork);
-          unwindInterruptedWork(current, unitOfWork); // Restore the original properties of the fiber.
-
-          assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
-
-          if (unitOfWork.mode & ProfileMode) {
-            // Reset the profiler timer.
-            startProfilerTimer(unitOfWork);
-          } // Run beginWork again.
-
-          invokeGuardedCallback(
-            null,
-            beginWork$1,
-            null,
-            current,
-            unitOfWork,
-            lanes
-          );
-
-          if (hasCaughtError()) {
-            var replayError = clearCaughtError();
-
-            if (
-              typeof replayError === "object" &&
-              replayError !== null &&
-              replayError._suppressLogging &&
-              typeof originalError === "object" &&
-              originalError !== null &&
-              !originalError._suppressLogging
-            ) {
-              // If suppressed, let the flag carry over to the original error which is the one we'll rethrow.
-              originalError._suppressLogging = true;
-            }
-          } // We always throw the original error in case the second render pass is not idempotent.
-          // This can happen if a memoized function or CommonJS module doesn't throw after first invocation.
-
-          throw originalError;
-        }
-      };
-    }
-
     var didWarnAboutUpdateInRender = false;
     var didWarnAboutUpdateInRenderForAnotherComponent;
 
@@ -25619,7 +24971,7 @@ to return true:wantsResponderID|                            |
                 error(
                   "Cannot update a component (`%s`) while rendering a " +
                     "different component (`%s`). To locate the bad setState() call inside `%s`, " +
-                    "follow the stack trace as described in https://reactjs.org/link/setstate-in-render",
+                    "follow the stack trace as described in https://react.dev/link/setstate-in-render",
                   setStateComponentName,
                   renderingComponentName,
                   renderingComponentName
@@ -25728,7 +25080,7 @@ to return true:wantsResponderID|                            |
                 "/* assert on the output */\n\n" +
                 "This ensures that you're testing the behavior the user would see " +
                 "in the browser." +
-                " Learn more at https://reactjs.org/link/wrap-tests-with-act",
+                " Learn more at https://react.dev/link/wrap-tests-with-act",
               getComponentNameFromFiber(fiber)
             );
           } finally {
@@ -25760,7 +25112,7 @@ to return true:wantsResponderID|                            |
               "/* assert on the output */\n\n" +
               "This ensures that you're testing the behavior the user would see " +
               "in the browser." +
-              " Learn more at https://reactjs.org/link/wrap-tests-with-act"
+              " Learn more at https://react.dev/link/wrap-tests-with-act"
           );
         }
       }
@@ -26297,6 +25649,7 @@ to return true:wantsResponderID|                            |
 
       {
         // This isn't directly used but is handy for debugging internals:
+        this._debugInfo = null;
         this._debugOwner = null;
         this._debugNeedsRemount = false;
         this._debugHookTypes = null;
@@ -26435,6 +25788,7 @@ to return true:wantsResponderID|                            |
       }
 
       {
+        workInProgress._debugInfo = current._debugInfo;
         workInProgress._debugNeedsRemount = current._debugNeedsRemount;
 
         switch (workInProgress.tag) {
@@ -26633,14 +25987,21 @@ to return true:wantsResponderID|                            |
           default: {
             if (typeof type === "object" && type !== null) {
               switch (type.$$typeof) {
-                case REACT_PROVIDER_TYPE:
+                case REACT_PROVIDER_TYPE: {
                   fiberTag = ContextProvider;
                   break getTag;
+                }
 
-                case REACT_CONTEXT_TYPE:
-                  // This is a consumer
+                // Fall through
+
+                case REACT_CONTEXT_TYPE: {
                   fiberTag = ContextConsumer;
                   break getTag;
+                }
+
+                case REACT_CONSUMER_TYPE:
+
+                // Fall through
 
                 case REACT_FORWARD_REF_TYPE:
                   fiberTag = ForwardRef;
@@ -26809,54 +26170,6 @@ to return true:wantsResponderID|                            |
         implementation: portal.implementation
       };
       return fiber;
-    } // Used for stashing WIP properties to replay failed work in DEV.
-
-    function assignFiberPropertiesInDEV(target, source) {
-      if (target === null) {
-        // This Fiber's initial properties will always be overwritten.
-        // We only use a Fiber to ensure the same hidden class so DEV isn't slow.
-        target = createFiber(IndeterminateComponent, null, null, NoMode);
-      } // This is intentionally written as a list of all properties.
-      // We tried to use Object.assign() instead but this is called in
-      // the hottest path, and Object.assign() was too slow:
-      // https://github.com/facebook/react/issues/12502
-      // This code is DEV-only so size is not a concern.
-
-      target.tag = source.tag;
-      target.key = source.key;
-      target.elementType = source.elementType;
-      target.type = source.type;
-      target.stateNode = source.stateNode;
-      target.return = source.return;
-      target.child = source.child;
-      target.sibling = source.sibling;
-      target.index = source.index;
-      target.ref = source.ref;
-      target.refCleanup = source.refCleanup;
-      target.pendingProps = source.pendingProps;
-      target.memoizedProps = source.memoizedProps;
-      target.updateQueue = source.updateQueue;
-      target.memoizedState = source.memoizedState;
-      target.dependencies = source.dependencies;
-      target.mode = source.mode;
-      target.flags = source.flags;
-      target.subtreeFlags = source.subtreeFlags;
-      target.deletions = source.deletions;
-      target.lanes = source.lanes;
-      target.childLanes = source.childLanes;
-      target.alternate = source.alternate;
-
-      {
-        target.actualDuration = source.actualDuration;
-        target.actualStartTime = source.actualStartTime;
-        target.selfBaseDuration = source.selfBaseDuration;
-        target.treeBaseDuration = source.treeBaseDuration;
-      }
-
-      target._debugOwner = source._debugOwner;
-      target._debugNeedsRemount = source._debugNeedsRemount;
-      target._debugHookTypes = source._debugHookTypes;
-      return target;
     }
 
     function FiberRootNode(
@@ -26968,7 +26281,7 @@ to return true:wantsResponderID|                            |
       return root;
     }
 
-    var ReactVersion = "18.3.0-canary-03d6f7cf0-20240209";
+    var ReactVersion = "18.3.0-canary-9372c6311-20240315";
 
     function createPortal$1(
       children,
@@ -27010,12 +26323,12 @@ to return true:wantsResponderID|                            |
       }
 
       var fiber = get(parentComponent);
-      var parentContext = findCurrentUnmaskedContext(fiber);
+      var parentContext = findCurrentUnmaskedContext();
 
       if (fiber.tag === ClassComponent) {
         var Component = fiber.type;
 
-        if (isContextProvider(Component)) {
+        if (isContextProvider()) {
           return processChildContext(fiber, Component, parentContext);
         }
       }
@@ -27060,7 +26373,7 @@ to return true:wantsResponderID|                            |
                     "%s was passed an instance of %s which is inside StrictMode. " +
                     "Instead, add a ref directly to the element you want to reference. " +
                     "Learn more about using refs safely here: " +
-                    "https://reactjs.org/link/strict-mode-find-node",
+                    "https://react.dev/link/strict-mode-find-node",
                   methodName,
                   methodName,
                   componentName
@@ -27071,7 +26384,7 @@ to return true:wantsResponderID|                            |
                     "%s was passed an instance of %s which renders StrictMode children. " +
                     "Instead, add a ref directly to the element you want to reference. " +
                     "Learn more about using refs safely here: " +
-                    "https://reactjs.org/link/strict-mode-find-node",
+                    "https://react.dev/link/strict-mode-find-node",
                   methodName,
                   methodName,
                   componentName
@@ -27161,7 +26474,7 @@ to return true:wantsResponderID|                            |
         {
           if (typeof callback !== "function") {
             error(
-              "render(...): Expected the last optional `callback` argument to be a " +
+              "Expected the last optional `callback` argument to be a " +
                 "function. Instead received: %s.",
               callback
             );
diff --git a/node_modules/react-native/Libraries/Renderer/implementations/ReactFabric-prod.js b/node_modules/react-native/Libraries/Renderer/implementations/ReactFabric-prod.js
index 6753ca0..565bc8c 100644
--- a/node_modules/react-native/Libraries/Renderer/implementations/ReactFabric-prod.js
+++ b/node_modules/react-native/Libraries/Renderer/implementations/ReactFabric-prod.js
@@ -8,76 +8,33 @@
  * @nolint
  * @providesModule ReactFabric-prod
  * @preventMunge
- * @generated SignedSource<<dd10c8324912bc8df4b15cfbfdd5d9ff>>
+ * @generated SignedSource<<9a40170807089a671035525b144e9dcd>>
  */
 
 "use strict";
 require("react-native/Libraries/ReactPrivate/ReactNativePrivateInitializeCore");
 var ReactNativePrivateInterface = require("react-native/Libraries/ReactPrivate/ReactNativePrivateInterface"),
   React = require("react"),
-  Scheduler = require("scheduler");
-function invokeGuardedCallbackImpl(name, func, context) {
-  var funcArgs = Array.prototype.slice.call(arguments, 3);
-  try {
-    func.apply(context, funcArgs);
-  } catch (error) {
-    this.onError(error);
-  }
-}
-var hasError = !1,
+  Scheduler = require("scheduler"),
+  isArrayImpl = Array.isArray,
+  hasError = !1,
   caughtError = null,
-  hasRethrowError = !1,
-  rethrowError = null,
-  reporter = {
-    onError: function (error) {
-      hasError = !0;
-      caughtError = error;
-    }
-  };
-function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
-  hasError = !1;
-  caughtError = null;
-  invokeGuardedCallbackImpl.apply(reporter, arguments);
-}
-function invokeGuardedCallbackAndCatchFirstError(
-  name,
-  func,
-  context,
-  a,
-  b,
-  c,
-  d,
-  e,
-  f
-) {
-  invokeGuardedCallback.apply(this, arguments);
-  if (hasError) {
-    if (hasError) {
-      var error = caughtError;
-      hasError = !1;
-      caughtError = null;
-    } else
-      throw Error(
-        "clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue."
-      );
-    hasRethrowError || ((hasRethrowError = !0), (rethrowError = error));
-  }
-}
-var isArrayImpl = Array.isArray,
   getFiberCurrentPropsFromNode$1 = null,
   getInstanceFromNode$1 = null,
   getNodeFromInstance$1 = null;
 function executeDispatch(event, listener, inst) {
-  var type = event.type || "unknown-event";
   event.currentTarget = getNodeFromInstance$1(inst);
-  invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event);
+  try {
+    listener(event);
+  } catch (error) {
+    hasError || ((hasError = !0), (caughtError = error));
+  }
   event.currentTarget = null;
 }
 function executeDirectDispatch(event) {
   var dispatchListener = event._dispatchListeners,
     dispatchInstance = event._dispatchInstances;
-  if (isArrayImpl(dispatchListener))
-    throw Error("executeDirectDispatch(...): Invalid `event`.");
+  if (isArrayImpl(dispatchListener)) throw Error("Invalid `event`.");
   event.currentTarget = dispatchListener
     ? getNodeFromInstance$1(dispatchInstance)
     : null;
@@ -336,9 +293,7 @@ var instrumentationCallback,
   };
 function accumulate(current, next) {
   if (null == next)
-    throw Error(
-      "accumulate(...): Accumulated items must not be null or undefined."
-    );
+    throw Error("Accumulated items must not be null or undefined.");
   return null == current
     ? next
     : isArrayImpl(current)
@@ -349,9 +304,7 @@ function accumulate(current, next) {
 }
 function accumulateInto(current, next) {
   if (null == next)
-    throw Error(
-      "accumulateInto(...): Accumulated items must not be null or undefined."
-    );
+    throw Error("Accumulated items must not be null or undefined.");
   if (null == current) return next;
   if (isArrayImpl(current)) {
     if (isArrayImpl(next)) return current.push.apply(current, next), current;
@@ -940,7 +893,7 @@ eventPluginOrder = Array.prototype.slice.call([
   "ReactNativeBridgeEventPlugin"
 ]);
 recomputePluginOrdering();
-var injectedNamesToPlugins$jscomp$inline_232 = {
+var injectedNamesToPlugins$jscomp$inline_227 = {
     ResponderEventPlugin: ResponderEventPlugin,
     ReactNativeBridgeEventPlugin: {
       eventTypes: {},
@@ -986,32 +939,32 @@ var injectedNamesToPlugins$jscomp$inline_232 = {
       }
     }
   },
-  isOrderingDirty$jscomp$inline_233 = !1,
-  pluginName$jscomp$inline_234;
-for (pluginName$jscomp$inline_234 in injectedNamesToPlugins$jscomp$inline_232)
+  isOrderingDirty$jscomp$inline_228 = !1,
+  pluginName$jscomp$inline_229;
+for (pluginName$jscomp$inline_229 in injectedNamesToPlugins$jscomp$inline_227)
   if (
-    injectedNamesToPlugins$jscomp$inline_232.hasOwnProperty(
-      pluginName$jscomp$inline_234
+    injectedNamesToPlugins$jscomp$inline_227.hasOwnProperty(
+      pluginName$jscomp$inline_229
     )
   ) {
-    var pluginModule$jscomp$inline_235 =
-      injectedNamesToPlugins$jscomp$inline_232[pluginName$jscomp$inline_234];
+    var pluginModule$jscomp$inline_230 =
+      injectedNamesToPlugins$jscomp$inline_227[pluginName$jscomp$inline_229];
     if (
-      !namesToPlugins.hasOwnProperty(pluginName$jscomp$inline_234) ||
-      namesToPlugins[pluginName$jscomp$inline_234] !==
-        pluginModule$jscomp$inline_235
+      !namesToPlugins.hasOwnProperty(pluginName$jscomp$inline_229) ||
+      namesToPlugins[pluginName$jscomp$inline_229] !==
+        pluginModule$jscomp$inline_230
     ) {
-      if (namesToPlugins[pluginName$jscomp$inline_234])
+      if (namesToPlugins[pluginName$jscomp$inline_229])
         throw Error(
           "EventPluginRegistry: Cannot inject two different event plugins using the same name, `" +
-            (pluginName$jscomp$inline_234 + "`.")
+            (pluginName$jscomp$inline_229 + "`.")
         );
-      namesToPlugins[pluginName$jscomp$inline_234] =
-        pluginModule$jscomp$inline_235;
-      isOrderingDirty$jscomp$inline_233 = !0;
+      namesToPlugins[pluginName$jscomp$inline_229] =
+        pluginModule$jscomp$inline_230;
+      isOrderingDirty$jscomp$inline_228 = !0;
     }
   }
-isOrderingDirty$jscomp$inline_233 && recomputePluginOrdering();
+isOrderingDirty$jscomp$inline_228 && recomputePluginOrdering();
 var emptyObject = {},
   removedKeys = null,
   removedKeyCount = 0,
@@ -1304,12 +1257,9 @@ function dispatchEvent(target, topLevelType, nativeEvent) {
         throw Error(
           "processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented."
         );
-      if (hasRethrowError)
+      if (hasError)
         throw (
-          ((event = rethrowError),
-          (hasRethrowError = !1),
-          (rethrowError = null),
-          event)
+          ((event = caughtError), (hasError = !1), (caughtError = null), event)
         );
     }
   });
@@ -1491,7 +1441,7 @@ function createLaneMap(initial) {
   for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
   return laneMap;
 }
-function markRootUpdated(root, updateLane) {
+function markRootUpdated$1(root, updateLane) {
   root.pendingLanes |= updateLane;
   268435456 !== updateLane &&
     ((root.suspendedLanes = 0), (root.pingedLanes = 0));
@@ -1624,6 +1574,11 @@ function cloneHiddenInstance(instance) {
     canonical: instance.canonical
   };
 }
+var supportsMicrotasks =
+    "undefined" !== typeof RN$enableMicrotasksInReact &&
+    !!RN$enableMicrotasksInReact,
+  scheduleMicrotask =
+    "function" === typeof queueMicrotask ? queueMicrotask : scheduleTimeout;
 function getInstanceFromNode(node) {
   return null != node.canonical && null != node.canonical.internalInstanceHandle
     ? node.canonical.internalInstanceHandle
@@ -1662,6 +1617,7 @@ var REACT_ELEMENT_TYPE = Symbol.for("react.element"),
   REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
   REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
   REACT_PROVIDER_TYPE = Symbol.for("react.provider"),
+  REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
   REACT_CONTEXT_TYPE = Symbol.for("react.context"),
   REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
   REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
@@ -1682,115 +1638,7 @@ function getIteratorFn(maybeIterable) {
     maybeIterable["@@iterator"];
   return "function" === typeof maybeIterable ? maybeIterable : null;
 }
-var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
-function getComponentNameFromType(type) {
-  if (null == type) return null;
-  if ("function" === typeof type)
-    return type.$$typeof === REACT_CLIENT_REFERENCE
-      ? null
-      : type.displayName || type.name || null;
-  if ("string" === typeof type) return type;
-  switch (type) {
-    case REACT_FRAGMENT_TYPE:
-      return "Fragment";
-    case REACT_PORTAL_TYPE:
-      return "Portal";
-    case REACT_PROFILER_TYPE:
-      return "Profiler";
-    case REACT_STRICT_MODE_TYPE:
-      return "StrictMode";
-    case REACT_SUSPENSE_TYPE:
-      return "Suspense";
-    case REACT_SUSPENSE_LIST_TYPE:
-      return "SuspenseList";
-  }
-  if ("object" === typeof type)
-    switch (type.$$typeof) {
-      case REACT_CONTEXT_TYPE:
-        return (type.displayName || "Context") + ".Consumer";
-      case REACT_PROVIDER_TYPE:
-        return (type._context.displayName || "Context") + ".Provider";
-      case REACT_FORWARD_REF_TYPE:
-        var innerType = type.render;
-        type = type.displayName;
-        type ||
-          ((type = innerType.displayName || innerType.name || ""),
-          (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
-        return type;
-      case REACT_MEMO_TYPE:
-        return (
-          (innerType = type.displayName || null),
-          null !== innerType
-            ? innerType
-            : getComponentNameFromType(type.type) || "Memo"
-        );
-      case REACT_LAZY_TYPE:
-        innerType = type._payload;
-        type = type._init;
-        try {
-          return getComponentNameFromType(type(innerType));
-        } catch (x) {}
-    }
-  return null;
-}
-function getComponentNameFromFiber(fiber) {
-  var type = fiber.type;
-  switch (fiber.tag) {
-    case 24:
-      return "Cache";
-    case 9:
-      return (type.displayName || "Context") + ".Consumer";
-    case 10:
-      return (type._context.displayName || "Context") + ".Provider";
-    case 18:
-      return "DehydratedFragment";
-    case 11:
-      return (
-        (fiber = type.render),
-        (fiber = fiber.displayName || fiber.name || ""),
-        type.displayName ||
-          ("" !== fiber ? "ForwardRef(" + fiber + ")" : "ForwardRef")
-      );
-    case 7:
-      return "Fragment";
-    case 26:
-    case 27:
-    case 5:
-      return type;
-    case 4:
-      return "Portal";
-    case 3:
-      return "Root";
-    case 6:
-      return "Text";
-    case 16:
-      return getComponentNameFromType(type);
-    case 8:
-      return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
-    case 22:
-      return "Offscreen";
-    case 12:
-      return "Profiler";
-    case 21:
-      return "Scope";
-    case 13:
-      return "Suspense";
-    case 19:
-      return "SuspenseList";
-    case 25:
-      return "TracingMarker";
-    case 1:
-    case 0:
-    case 17:
-    case 2:
-    case 14:
-    case 15:
-      if ("function" === typeof type)
-        return type.displayName || type.name || null;
-      if ("string" === typeof type) return type;
-  }
-  return null;
-}
+Symbol.for("react.client.reference");
 function getNearestMountedFiber(fiber) {
   var node = fiber,
     nearestMounted = fiber;
@@ -1899,18 +1747,7 @@ function findCurrentHostFiberImpl(node) {
   }
   return null;
 }
-function describeComponentFrame(name, ownerName) {
-  var sourceInfo = "";
-  ownerName && (sourceInfo = " (created by " + ownerName + ")");
-  return "\n    in " + (name || "Unknown") + sourceInfo;
-}
-function describeFunctionComponentFrame(fn) {
-  return fn
-    ? describeComponentFrame(fn.displayName || fn.name || null, null)
-    : "";
-}
-var hasOwnProperty = Object.prototype.hasOwnProperty,
-  valueStack = [],
+var valueStack = [],
   index = -1;
 function createCursor(defaultValue) {
   return { current: defaultValue };
@@ -1924,89 +1761,7 @@ function push(cursor, value) {
   valueStack[index] = cursor.current;
   cursor.current = value;
 }
-var emptyContextObject = {},
-  contextStackCursor$1 = createCursor(emptyContextObject),
-  didPerformWorkStackCursor = createCursor(!1),
-  previousContext = emptyContextObject;
-function getMaskedContext(workInProgress, unmaskedContext) {
-  var contextTypes = workInProgress.type.contextTypes;
-  if (!contextTypes) return emptyContextObject;
-  var instance = workInProgress.stateNode;
-  if (
-    instance &&
-    instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext
-  )
-    return instance.__reactInternalMemoizedMaskedChildContext;
-  var context = {},
-    key;
-  for (key in contextTypes) context[key] = unmaskedContext[key];
-  instance &&
-    ((workInProgress = workInProgress.stateNode),
-    (workInProgress.__reactInternalMemoizedUnmaskedChildContext =
-      unmaskedContext),
-    (workInProgress.__reactInternalMemoizedMaskedChildContext = context));
-  return context;
-}
-function isContextProvider(type) {
-  type = type.childContextTypes;
-  return null !== type && void 0 !== type;
-}
-function popContext() {
-  pop(didPerformWorkStackCursor);
-  pop(contextStackCursor$1);
-}
-function pushTopLevelContextObject(fiber, context, didChange) {
-  if (contextStackCursor$1.current !== emptyContextObject)
-    throw Error(
-      "Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue."
-    );
-  push(contextStackCursor$1, context);
-  push(didPerformWorkStackCursor, didChange);
-}
-function processChildContext(fiber, type, parentContext) {
-  var instance = fiber.stateNode;
-  type = type.childContextTypes;
-  if ("function" !== typeof instance.getChildContext) return parentContext;
-  instance = instance.getChildContext();
-  for (var contextKey in instance)
-    if (!(contextKey in type))
-      throw Error(
-        (getComponentNameFromFiber(fiber) || "Unknown") +
-          '.getChildContext(): key "' +
-          contextKey +
-          '" is not defined in childContextTypes.'
-      );
-  return assign({}, parentContext, instance);
-}
-function pushContextProvider(workInProgress) {
-  workInProgress =
-    ((workInProgress = workInProgress.stateNode) &&
-      workInProgress.__reactInternalMemoizedMergedChildContext) ||
-    emptyContextObject;
-  previousContext = contextStackCursor$1.current;
-  push(contextStackCursor$1, workInProgress);
-  push(didPerformWorkStackCursor, didPerformWorkStackCursor.current);
-  return !0;
-}
-function invalidateContextProvider(workInProgress, type, didChange) {
-  var instance = workInProgress.stateNode;
-  if (!instance)
-    throw Error(
-      "Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue."
-    );
-  didChange
-    ? ((workInProgress = processChildContext(
-        workInProgress,
-        type,
-        previousContext
-      )),
-      (instance.__reactInternalMemoizedMergedChildContext = workInProgress),
-      pop(didPerformWorkStackCursor),
-      pop(contextStackCursor$1),
-      push(contextStackCursor$1, workInProgress))
-    : pop(didPerformWorkStackCursor);
-  push(didPerformWorkStackCursor, didChange);
-}
+var emptyContextObject = {};
 function is(x, y) {
   return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
 }
@@ -2143,7 +1898,7 @@ function ensureRootIsScheduled(root) {
   mightHavePendingSyncWork = !0;
   didScheduleMicrotask ||
     ((didScheduleMicrotask = !0),
-    scheduleCallback$2(ImmediatePriority, processRootScheduleInMicrotask));
+    scheduleImmediateTask(processRootScheduleInMicrotask));
   scheduleTaskForRootDuringMicrotask(root, now());
 }
 function flushSyncWorkAcrossRoots_impl(onlyLegacy) {
@@ -2212,6 +1967,7 @@ function flushSyncWorkAcrossRoots_impl(onlyLegacy) {
                       workInProgressRootRenderLanes$9,
                       workInProgressRootRecoverableErrors,
                       workInProgressTransitions,
+                      workInProgressRootDidIncludeRecursiveRenderUpdate,
                       workInProgressDeferredLane
                     ));
               }
@@ -2229,8 +1985,7 @@ function flushSyncWorkAcrossRoots_impl(onlyLegacy) {
         if ("function" === typeof AggregateError)
           throw new AggregateError(errors);
         for (onlyLegacy = 1; onlyLegacy < errors.length; onlyLegacy++)
-          (didPerformSomeWork = throwError.bind(null, errors[onlyLegacy])),
-            scheduleCallback$2(ImmediatePriority, didPerformSomeWork);
+          scheduleImmediateTask(throwError.bind(null, errors[onlyLegacy]));
       }
       throw errors[0];
     }
@@ -2330,6 +2085,15 @@ function scheduleTaskForRootDuringMicrotask(root, currentTime) {
   root.callbackNode = suspendedLanes;
   return currentTime;
 }
+function scheduleImmediateTask(cb) {
+  supportsMicrotasks
+    ? scheduleMicrotask(function () {
+        0 !== (executionContext & 6)
+          ? scheduleCallback$2(ImmediatePriority, cb)
+          : cb();
+      })
+    : scheduleCallback$2(ImmediatePriority, cb);
+}
 var hasForceUpdate = !1;
 function initializeUpdateQueue(fiber) {
   fiber.updateQueue = {
@@ -2566,6 +2330,7 @@ function commitCallbacks(updateQueue, context) {
     )
       callCallback(callbacks[updateQueue], context);
 }
+var hasOwnProperty = Object.prototype.hasOwnProperty;
 function shallowEqual(objA, objB) {
   if (objectIs(objA, objB)) return !0;
   if (
@@ -2588,6 +2353,16 @@ function shallowEqual(objA, objB) {
   }
   return !0;
 }
+function describeComponentFrame(name, ownerName) {
+  var sourceInfo = "";
+  ownerName && (sourceInfo = " (created by " + ownerName + ")");
+  return "\n    in " + (name || "Unknown") + sourceInfo;
+}
+function describeFunctionComponentFrame(fn) {
+  return fn
+    ? describeComponentFrame(fn.displayName || fn.name || null, null)
+    : "";
+}
 function describeFiber(fiber) {
   switch (fiber.tag) {
     case 26:
@@ -2612,6 +2387,18 @@ function describeFiber(fiber) {
       return "";
   }
 }
+function getStackByFiberInDevAndProd(workInProgress) {
+  try {
+    var info = "";
+    do
+      (info += describeFiber(workInProgress)),
+        (workInProgress = workInProgress.return);
+    while (workInProgress);
+    return info;
+  } catch (x) {
+    return "\nError generating stack: " + x.message + "\n" + x.stack;
+  }
+}
 var SuspenseException = Error(
     "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`"
   ),
@@ -2664,16 +2451,16 @@ function trackUsedThenable(thenableState, thenable, index) {
             }
           }
         );
-        switch (thenable.status) {
-          case "fulfilled":
-            return thenable.value;
-          case "rejected":
-            throw (
-              ((thenableState = thenable.reason),
-              checkIfUseWrappedInAsyncCatch(thenableState),
-              thenableState)
-            );
-        }
+      }
+      switch (thenable.status) {
+        case "fulfilled":
+          return thenable.value;
+        case "rejected":
+          throw (
+            ((thenableState = thenable.reason),
+            checkIfUseWrappedInAsyncCatch(thenableState),
+            thenableState)
+          );
       }
       suspendedThenable = thenable;
       throw SuspenseException;
@@ -2703,56 +2490,54 @@ function unwrapThenable(thenable) {
   null === thenableState$1 && (thenableState$1 = []);
   return trackUsedThenable(thenableState$1, thenable, index);
 }
-function coerceRef(returnFiber, current, element) {
-  returnFiber = element.ref;
-  if (
-    null !== returnFiber &&
-    "function" !== typeof returnFiber &&
-    "object" !== typeof returnFiber
-  ) {
-    if (element._owner) {
-      element = element._owner;
-      if (element) {
-        if (1 !== element.tag)
-          throw Error(
-            "Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref"
-          );
-        var inst = element.stateNode;
-      }
-      if (!inst)
-        throw Error(
-          "Missing owner for string ref " +
-            returnFiber +
-            ". This error is likely caused by a bug in React. Please file an issue."
-        );
-      var resolvedInst = inst,
-        stringRef = "" + returnFiber;
-      if (
-        null !== current &&
-        null !== current.ref &&
-        "function" === typeof current.ref &&
-        current.ref._stringRef === stringRef
-      )
-        return current.ref;
-      current = function (value) {
-        var refs = resolvedInst.refs;
-        null === value ? delete refs[stringRef] : (refs[stringRef] = value);
-      };
-      current._stringRef = stringRef;
-      return current;
-    }
-    if ("string" !== typeof returnFiber)
-      throw Error(
-        "Expected ref to be a function, a string, an object returned by React.createRef(), or null."
-      );
-    if (!element._owner)
-      throw Error(
-        "Element ref was specified as a string (" +
-          returnFiber +
-          ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information."
-      );
+function convertStringRefToCallbackRef(
+  returnFiber,
+  current,
+  element,
+  mixedRef
+) {
+  function ref(value) {
+    var refs = inst.refs;
+    null === value ? delete refs[stringRef] : (refs[stringRef] = value);
   }
-  return returnFiber;
+  var stringRef = "" + mixedRef;
+  returnFiber = element._owner;
+  if (!returnFiber)
+    throw Error(
+      "Element ref was specified as a string (" +
+        stringRef +
+        ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://react.dev/link/refs-must-have-owner for more information."
+    );
+  if (1 !== returnFiber.tag)
+    throw Error(
+      "Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://react.dev/link/strict-mode-string-ref"
+    );
+  var inst = returnFiber.stateNode;
+  if (!inst)
+    throw Error(
+      "Missing owner for string ref " +
+        stringRef +
+        ". This error is likely caused by a bug in React. Please file an issue."
+    );
+  if (
+    null !== current &&
+    null !== current.ref &&
+    "function" === typeof current.ref &&
+    current.ref._stringRef === stringRef
+  )
+    return current.ref;
+  ref._stringRef = stringRef;
+  return ref;
+}
+function coerceRef(returnFiber, current, workInProgress, element) {
+  var mixedRef = element.ref;
+  returnFiber =
+    "string" === typeof mixedRef ||
+    "number" === typeof mixedRef ||
+    "boolean" === typeof mixedRef
+      ? convertStringRefToCallbackRef(returnFiber, current, element, mixedRef)
+      : mixedRef;
+  workInProgress.ref = returnFiber;
 }
 function throwOnInvalidObjectType(returnFiber, newChild) {
   returnFiber = Object.prototype.toString.call(newChild);
@@ -2784,13 +2569,13 @@ function createChildReconciler(shouldTrackSideEffects) {
         (currentFirstChild = currentFirstChild.sibling);
     return null;
   }
-  function mapRemainingChildren(returnFiber, currentFirstChild) {
-    for (returnFiber = new Map(); null !== currentFirstChild; )
+  function mapRemainingChildren(currentFirstChild) {
+    for (var existingChildren = new Map(); null !== currentFirstChild; )
       null !== currentFirstChild.key
-        ? returnFiber.set(currentFirstChild.key, currentFirstChild)
-        : returnFiber.set(currentFirstChild.index, currentFirstChild),
+        ? existingChildren.set(currentFirstChild.key, currentFirstChild)
+        : existingChildren.set(currentFirstChild.index, currentFirstChild),
         (currentFirstChild = currentFirstChild.sibling);
-    return returnFiber;
+    return existingChildren;
   }
   function useFiber(fiber, pendingProps) {
     fiber = createWorkInProgress(fiber, pendingProps);
@@ -2850,7 +2635,7 @@ function createChildReconciler(shouldTrackSideEffects) {
     )
       return (
         (lanes = useFiber(current, element.props)),
-        (lanes.ref = coerceRef(returnFiber, current, element)),
+        coerceRef(returnFiber, current, lanes, element),
         (lanes.return = returnFiber),
         lanes
       );
@@ -2862,7 +2647,7 @@ function createChildReconciler(shouldTrackSideEffects) {
       returnFiber.mode,
       lanes
     );
-    lanes.ref = coerceRef(returnFiber, current, element);
+    coerceRef(returnFiber, current, lanes, element);
     lanes.return = returnFiber;
     return lanes;
   }
@@ -2924,7 +2709,7 @@ function createChildReconciler(shouldTrackSideEffects) {
               returnFiber.mode,
               lanes
             )),
-            (lanes.ref = coerceRef(returnFiber, null, newChild)),
+            coerceRef(returnFiber, null, lanes, newChild),
             (lanes.return = returnFiber),
             lanes
           );
@@ -2958,7 +2743,7 @@ function createChildReconciler(shouldTrackSideEffects) {
       if (newChild.$$typeof === REACT_CONTEXT_TYPE)
         return createChild(
           returnFiber,
-          readContextDuringReconcilation(returnFiber, newChild, lanes),
+          readContextDuringReconciliation(returnFiber, newChild, lanes),
           lanes
         );
       throwOnInvalidObjectType(returnFiber, newChild);
@@ -3005,7 +2790,7 @@ function createChildReconciler(shouldTrackSideEffects) {
         return updateSlot(
           returnFiber,
           oldFiber,
-          readContextDuringReconcilation(returnFiber, newChild, lanes),
+          readContextDuringReconciliation(returnFiber, newChild, lanes),
           lanes
         );
       throwOnInvalidObjectType(returnFiber, newChild);
@@ -3073,7 +2858,7 @@ function createChildReconciler(shouldTrackSideEffects) {
           existingChildren,
           returnFiber,
           newIdx,
-          readContextDuringReconcilation(returnFiber, newChild, lanes),
+          readContextDuringReconciliation(returnFiber, newChild, lanes),
           lanes
         );
       throwOnInvalidObjectType(returnFiber, newChild);
@@ -3139,7 +2924,7 @@ function createChildReconciler(shouldTrackSideEffects) {
       return resultingFirstChild;
     }
     for (
-      oldFiber = mapRemainingChildren(returnFiber, oldFiber);
+      oldFiber = mapRemainingChildren(oldFiber);
       newIdx < newChildren.length;
       newIdx++
     )
@@ -3227,7 +3012,7 @@ function createChildReconciler(shouldTrackSideEffects) {
       return iteratorFn;
     }
     for (
-      oldFiber = mapRemainingChildren(returnFiber, oldFiber);
+      oldFiber = mapRemainingChildren(oldFiber);
       !step.done;
       newIdx++, step = newChildrenIterable.next()
     )
@@ -3289,11 +3074,7 @@ function createChildReconciler(shouldTrackSideEffects) {
                 ) {
                   deleteRemainingChildren(returnFiber, child.sibling);
                   currentFirstChild = useFiber(child, newChild.props);
-                  currentFirstChild.ref = coerceRef(
-                    returnFiber,
-                    child,
-                    newChild
-                  );
+                  coerceRef(returnFiber, child, currentFirstChild, newChild);
                   currentFirstChild.return = returnFiber;
                   returnFiber = currentFirstChild;
                   break a;
@@ -3320,11 +3101,7 @@ function createChildReconciler(shouldTrackSideEffects) {
                   returnFiber.mode,
                   lanes
                 )),
-                (lanes.ref = coerceRef(
-                  returnFiber,
-                  currentFirstChild,
-                  newChild
-                )),
+                coerceRef(returnFiber, currentFirstChild, lanes, newChild),
                 (lanes.return = returnFiber),
                 (returnFiber = lanes));
           }
@@ -3370,7 +3147,7 @@ function createChildReconciler(shouldTrackSideEffects) {
         case REACT_LAZY_TYPE:
           return (
             (child = newChild._init),
-            reconcileChildFibers(
+            reconcileChildFibersImpl(
               returnFiber,
               currentFirstChild,
               child(newChild._payload),
@@ -3403,7 +3180,7 @@ function createChildReconciler(shouldTrackSideEffects) {
         return reconcileChildFibersImpl(
           returnFiber,
           currentFirstChild,
-          readContextDuringReconcilation(returnFiber, newChild, lanes),
+          readContextDuringReconciliation(returnFiber, newChild, lanes),
           lanes
         );
       throwOnInvalidObjectType(returnFiber, newChild);
@@ -3427,12 +3204,7 @@ function createChildReconciler(shouldTrackSideEffects) {
         placeSingleChild(returnFiber))
       : deleteRemainingChildren(returnFiber, currentFirstChild);
   }
-  function reconcileChildFibers(
-    returnFiber,
-    currentFirstChild,
-    newChild,
-    lanes
-  ) {
+  return function (returnFiber, currentFirstChild, newChild, lanes) {
     thenableIndexCounter$1 = 0;
     returnFiber = reconcileChildFibersImpl(
       returnFiber,
@@ -3442,8 +3214,7 @@ function createChildReconciler(shouldTrackSideEffects) {
     );
     thenableState$1 = null;
     return returnFiber;
-  }
-  return reconcileChildFibers;
+  };
 }
 var reconcileChildFibers = createChildReconciler(!0),
   mountChildFibers = createChildReconciler(!1),
@@ -3536,7 +3307,7 @@ var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher,
   globalClientIdCounter = 0;
 function throwInvalidHookError() {
   throw Error(
-    "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem."
+    "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
   );
 }
 function areHookInputsEqual(nextDeps, prevDeps) {
@@ -4425,30 +4196,17 @@ function checkShouldComponentUpdate(
     : !0;
 }
 function constructClassInstance(workInProgress, ctor, props) {
-  var isLegacyContextConsumer = !1,
-    unmaskedContext = emptyContextObject;
-  var context = ctor.contextType;
-  "object" === typeof context && null !== context
-    ? (context = readContext(context))
-    : ((unmaskedContext = isContextProvider(ctor)
-        ? previousContext
-        : contextStackCursor$1.current),
-      (isLegacyContextConsumer = ctor.contextTypes),
-      (context = (isLegacyContextConsumer =
-        null !== isLegacyContextConsumer && void 0 !== isLegacyContextConsumer)
-        ? getMaskedContext(workInProgress, unmaskedContext)
-        : emptyContextObject));
+  var context = emptyContextObject,
+    contextType = ctor.contextType;
+  "object" === typeof contextType &&
+    null !== contextType &&
+    (context = readContext(contextType));
   ctor = new ctor(props, context);
   workInProgress.memoizedState =
     null !== ctor.state && void 0 !== ctor.state ? ctor.state : null;
   ctor.updater = classComponentUpdater;
   workInProgress.stateNode = ctor;
   ctor._reactInternals = workInProgress;
-  isLegacyContextConsumer &&
-    ((workInProgress = workInProgress.stateNode),
-    (workInProgress.__reactInternalMemoizedUnmaskedChildContext =
-      unmaskedContext),
-    (workInProgress.__reactInternalMemoizedMaskedChildContext = context));
   return ctor;
 }
 function callComponentWillReceiveProps(
@@ -4472,12 +4230,10 @@ function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {
   instance.refs = {};
   initializeUpdateQueue(workInProgress);
   var contextType = ctor.contextType;
-  "object" === typeof contextType && null !== contextType
-    ? (instance.context = readContext(contextType))
-    : ((contextType = isContextProvider(ctor)
-        ? previousContext
-        : contextStackCursor$1.current),
-      (instance.context = getMaskedContext(workInProgress, contextType)));
+  instance.context =
+    "object" === typeof contextType && null !== contextType
+      ? readContext(contextType)
+      : emptyContextObject;
   instance.state = workInProgress.memoizedState;
   contextType = ctor.getDerivedStateFromProps;
   "function" === typeof contextType &&
@@ -4499,22 +4255,23 @@ function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {
   "function" === typeof instance.componentDidMount &&
     (workInProgress.flags |= 4194308);
 }
+var CapturedStacks = new WeakMap();
 function createCapturedValueAtFiber(value, source) {
-  try {
-    var info = "",
-      node = source;
-    do (info += describeFiber(node)), (node = node.return);
-    while (node);
-    var JSCompiler_inline_result = info;
-  } catch (x) {
-    JSCompiler_inline_result =
-      "\nError generating stack: " + x.message + "\n" + x.stack;
-  }
+  if ("object" === typeof value && null !== value) {
+    var stack = CapturedStacks.get(value);
+    "string" !== typeof stack &&
+      ((stack = getStackByFiberInDevAndProd(source)),
+      CapturedStacks.set(value, stack));
+  } else stack = getStackByFiberInDevAndProd(source);
+  return { value: value, source: source, stack: stack, digest: null };
+}
+function createCapturedValueFromError(value, digest, stack) {
+  "string" === typeof stack && CapturedStacks.set(value, stack);
   return {
     value: value,
-    source: source,
-    stack: JSCompiler_inline_result,
-    digest: null
+    source: null,
+    stack: null != stack ? stack : null,
+    digest: null != digest ? digest : null
   };
 }
 if (
@@ -4860,7 +4617,7 @@ function updateOffscreenComponent(current, workInProgress, renderLanes) {
     nextChildren = nextProps.children,
     nextIsDetached = 0 !== (workInProgress.stateNode._pendingVisibility & 2),
     prevState = null !== current ? current.memoizedState : null;
-  markRef$1(current, workInProgress);
+  markRef(current, workInProgress);
   if ("hidden" === nextProps.mode || nextIsDetached) {
     if (0 !== (workInProgress.flags & 128)) {
       renderLanes =
@@ -4914,13 +4671,20 @@ function deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes) {
   pushOffscreenSuspenseHandler(workInProgress);
   return null;
 }
-function markRef$1(current, workInProgress) {
+function markRef(current, workInProgress) {
   var ref = workInProgress.ref;
-  if (
-    (null === current && null !== ref) ||
-    (null !== current && current.ref !== ref)
-  )
-    (workInProgress.flags |= 512), (workInProgress.flags |= 2097152);
+  if (null === ref)
+    null !== current &&
+      null !== current.ref &&
+      (workInProgress.flags |= 2097664);
+  else {
+    if ("function" !== typeof ref && "object" !== typeof ref)
+      throw Error(
+        "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
+      );
+    if (null === current || current.ref !== ref)
+      workInProgress.flags |= 2097664;
+  }
 }
 function updateFunctionComponent(
   current,
@@ -4929,17 +4693,13 @@ function updateFunctionComponent(
   nextProps,
   renderLanes
 ) {
-  var context = isContextProvider(Component)
-    ? previousContext
-    : contextStackCursor$1.current;
-  context = getMaskedContext(workInProgress, context);
   prepareToReadContext(workInProgress, renderLanes);
   Component = renderWithHooks(
     current,
     workInProgress,
     Component,
     nextProps,
-    context,
+    void 0,
     renderLanes
   );
   if (null !== current && !didReceiveUpdate)
@@ -4983,10 +4743,6 @@ function updateClassComponent(
   nextProps,
   renderLanes
 ) {
-  if (isContextProvider(Component)) {
-    var hasContext = !0;
-    pushContextProvider(workInProgress);
-  } else hasContext = !1;
   prepareToReadContext(workInProgress, renderLanes);
   if (null === workInProgress.stateNode)
     resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress),
@@ -4998,36 +4754,30 @@ function updateClassComponent(
       oldProps = workInProgress.memoizedProps;
     instance.props = oldProps;
     var oldContext = instance.context,
-      contextType = Component.contextType;
-    "object" === typeof contextType && null !== contextType
-      ? (contextType = readContext(contextType))
-      : ((contextType = isContextProvider(Component)
-          ? previousContext
-          : contextStackCursor$1.current),
-        (contextType = getMaskedContext(workInProgress, contextType)));
-    var getDerivedStateFromProps = Component.getDerivedStateFromProps,
-      hasNewLifecycles =
-        "function" === typeof getDerivedStateFromProps ||
-        "function" === typeof instance.getSnapshotBeforeUpdate;
-    hasNewLifecycles ||
+      contextType = Component.contextType,
+      nextContext = emptyContextObject;
+    "object" === typeof contextType &&
+      null !== contextType &&
+      (nextContext = readContext(contextType));
+    var getDerivedStateFromProps = Component.getDerivedStateFromProps;
+    (contextType =
+      "function" === typeof getDerivedStateFromProps ||
+      "function" === typeof instance.getSnapshotBeforeUpdate) ||
       ("function" !== typeof instance.UNSAFE_componentWillReceiveProps &&
         "function" !== typeof instance.componentWillReceiveProps) ||
-      ((oldProps !== nextProps || oldContext !== contextType) &&
+      ((oldProps !== nextProps || oldContext !== nextContext) &&
         callComponentWillReceiveProps(
           workInProgress,
           instance,
           nextProps,
-          contextType
+          nextContext
         ));
     hasForceUpdate = !1;
     var oldState = workInProgress.memoizedState;
     instance.state = oldState;
     processUpdateQueue(workInProgress, nextProps, instance, renderLanes);
     oldContext = workInProgress.memoizedState;
-    oldProps !== nextProps ||
-    oldState !== oldContext ||
-    didPerformWorkStackCursor.current ||
-    hasForceUpdate
+    oldProps !== nextProps || oldState !== oldContext || hasForceUpdate
       ? ("function" === typeof getDerivedStateFromProps &&
           (applyDerivedStateFromProps(
             workInProgress,
@@ -5045,9 +4795,9 @@ function updateClassComponent(
             nextProps,
             oldState,
             oldContext,
-            contextType
+            nextContext
           ))
-          ? (hasNewLifecycles ||
+          ? (contextType ||
               ("function" !== typeof instance.UNSAFE_componentWillMount &&
                 "function" !== typeof instance.componentWillMount) ||
               ("function" === typeof instance.componentWillMount &&
@@ -5062,7 +4812,7 @@ function updateClassComponent(
             (workInProgress.memoizedState = oldContext)),
         (instance.props = nextProps),
         (instance.state = oldContext),
-        (instance.context = contextType),
+        (instance.context = nextContext),
         (nextProps = oldProps))
       : ("function" === typeof instance.componentDidMount &&
           (workInProgress.flags |= 4194308),
@@ -5070,48 +4820,46 @@ function updateClassComponent(
   } else {
     instance = workInProgress.stateNode;
     cloneUpdateQueue(current, workInProgress);
-    oldProps = workInProgress.memoizedProps;
+    nextContext = workInProgress.memoizedProps;
     contextType =
       workInProgress.type === workInProgress.elementType
-        ? oldProps
-        : resolveDefaultProps(workInProgress.type, oldProps);
+        ? nextContext
+        : resolveDefaultProps(workInProgress.type, nextContext);
     instance.props = contextType;
-    hasNewLifecycles = workInProgress.pendingProps;
-    oldState = instance.context;
+    getDerivedStateFromProps = workInProgress.pendingProps;
+    var oldContext$jscomp$0 = instance.context;
     oldContext = Component.contextType;
-    "object" === typeof oldContext && null !== oldContext
-      ? (oldContext = readContext(oldContext))
-      : ((oldContext = isContextProvider(Component)
-          ? previousContext
-          : contextStackCursor$1.current),
-        (oldContext = getMaskedContext(workInProgress, oldContext)));
-    var getDerivedStateFromProps$jscomp$0 = Component.getDerivedStateFromProps;
-    (getDerivedStateFromProps =
-      "function" === typeof getDerivedStateFromProps$jscomp$0 ||
+    oldProps = emptyContextObject;
+    "object" === typeof oldContext &&
+      null !== oldContext &&
+      (oldProps = readContext(oldContext));
+    oldState = Component.getDerivedStateFromProps;
+    (oldContext =
+      "function" === typeof oldState ||
       "function" === typeof instance.getSnapshotBeforeUpdate) ||
       ("function" !== typeof instance.UNSAFE_componentWillReceiveProps &&
         "function" !== typeof instance.componentWillReceiveProps) ||
-      ((oldProps !== hasNewLifecycles || oldState !== oldContext) &&
+      ((nextContext !== getDerivedStateFromProps ||
+        oldContext$jscomp$0 !== oldProps) &&
         callComponentWillReceiveProps(
           workInProgress,
           instance,
           nextProps,
-          oldContext
+          oldProps
         ));
     hasForceUpdate = !1;
-    oldState = workInProgress.memoizedState;
-    instance.state = oldState;
+    oldContext$jscomp$0 = workInProgress.memoizedState;
+    instance.state = oldContext$jscomp$0;
     processUpdateQueue(workInProgress, nextProps, instance, renderLanes);
     var newState = workInProgress.memoizedState;
-    oldProps !== hasNewLifecycles ||
-    oldState !== newState ||
-    didPerformWorkStackCursor.current ||
+    nextContext !== getDerivedStateFromProps ||
+    oldContext$jscomp$0 !== newState ||
     hasForceUpdate
-      ? ("function" === typeof getDerivedStateFromProps$jscomp$0 &&
+      ? ("function" === typeof oldState &&
           (applyDerivedStateFromProps(
             workInProgress,
             Component,
-            getDerivedStateFromProps$jscomp$0,
+            oldState,
             nextProps
           ),
           (newState = workInProgress.memoizedState)),
@@ -5122,47 +4870,47 @@ function updateClassComponent(
             Component,
             contextType,
             nextProps,
-            oldState,
+            oldContext$jscomp$0,
             newState,
-            oldContext
+            oldProps
           ) ||
           !1)
-          ? (getDerivedStateFromProps ||
+          ? (oldContext ||
               ("function" !== typeof instance.UNSAFE_componentWillUpdate &&
                 "function" !== typeof instance.componentWillUpdate) ||
               ("function" === typeof instance.componentWillUpdate &&
-                instance.componentWillUpdate(nextProps, newState, oldContext),
+                instance.componentWillUpdate(nextProps, newState, oldProps),
               "function" === typeof instance.UNSAFE_componentWillUpdate &&
                 instance.UNSAFE_componentWillUpdate(
                   nextProps,
                   newState,
-                  oldContext
+                  oldProps
                 )),
             "function" === typeof instance.componentDidUpdate &&
               (workInProgress.flags |= 4),
             "function" === typeof instance.getSnapshotBeforeUpdate &&
               (workInProgress.flags |= 1024))
           : ("function" !== typeof instance.componentDidUpdate ||
-              (oldProps === current.memoizedProps &&
-                oldState === current.memoizedState) ||
+              (nextContext === current.memoizedProps &&
+                oldContext$jscomp$0 === current.memoizedState) ||
               (workInProgress.flags |= 4),
             "function" !== typeof instance.getSnapshotBeforeUpdate ||
-              (oldProps === current.memoizedProps &&
-                oldState === current.memoizedState) ||
+              (nextContext === current.memoizedProps &&
+                oldContext$jscomp$0 === current.memoizedState) ||
               (workInProgress.flags |= 1024),
             (workInProgress.memoizedProps = nextProps),
             (workInProgress.memoizedState = newState)),
         (instance.props = nextProps),
         (instance.state = newState),
-        (instance.context = oldContext),
+        (instance.context = oldProps),
         (nextProps = contextType))
       : ("function" !== typeof instance.componentDidUpdate ||
-          (oldProps === current.memoizedProps &&
-            oldState === current.memoizedState) ||
+          (nextContext === current.memoizedProps &&
+            oldContext$jscomp$0 === current.memoizedState) ||
           (workInProgress.flags |= 4),
         "function" !== typeof instance.getSnapshotBeforeUpdate ||
-          (oldProps === current.memoizedProps &&
-            oldState === current.memoizedState) ||
+          (nextContext === current.memoizedProps &&
+            oldContext$jscomp$0 === current.memoizedState) ||
           (workInProgress.flags |= 1024),
         (nextProps = !1));
   }
@@ -5171,7 +4919,7 @@ function updateClassComponent(
     workInProgress,
     Component,
     nextProps,
-    hasContext,
+    !1,
     renderLanes
   );
 }
@@ -5183,21 +4931,18 @@ function finishClassComponent(
   hasContext,
   renderLanes
 ) {
-  markRef$1(current, workInProgress);
-  var didCaptureError = 0 !== (workInProgress.flags & 128);
-  if (!shouldUpdate && !didCaptureError)
-    return (
-      hasContext && invalidateContextProvider(workInProgress, Component, !1),
-      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
-    );
+  markRef(current, workInProgress);
+  hasContext = 0 !== (workInProgress.flags & 128);
+  if (!shouldUpdate && !hasContext)
+    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
   shouldUpdate = workInProgress.stateNode;
   ReactCurrentOwner$1.current = workInProgress;
-  var nextChildren =
-    didCaptureError && "function" !== typeof Component.getDerivedStateFromError
+  Component =
+    hasContext && "function" !== typeof Component.getDerivedStateFromError
       ? null
       : shouldUpdate.render();
   workInProgress.flags |= 1;
-  null !== current && didCaptureError
+  null !== current && hasContext
     ? ((workInProgress.child = reconcileChildFibers(
         workInProgress,
         current.child,
@@ -5207,26 +4952,13 @@ function finishClassComponent(
       (workInProgress.child = reconcileChildFibers(
         workInProgress,
         null,
-        nextChildren,
+        Component,
         renderLanes
       )))
-    : reconcileChildren(current, workInProgress, nextChildren, renderLanes);
+    : reconcileChildren(current, workInProgress, Component, renderLanes);
   workInProgress.memoizedState = shouldUpdate.state;
-  hasContext && invalidateContextProvider(workInProgress, Component, !0);
   return workInProgress.child;
 }
-function pushHostRootContext(workInProgress) {
-  var root = workInProgress.stateNode;
-  root.pendingContext
-    ? pushTopLevelContextObject(
-        workInProgress,
-        root.pendingContext,
-        root.pendingContext !== root.context
-      )
-    : root.context &&
-      pushTopLevelContextObject(workInProgress, root.context, !1);
-  pushHostContainer(workInProgress, root.containerInfo);
-}
 var SUSPENDED_MARKER = { dehydrated: null, treeContext: null, retryLane: 0 };
 function mountSuspenseOffscreenState(renderLanes) {
   return { baseLanes: renderLanes, cachePool: null };
@@ -5418,18 +5150,16 @@ function updateDehydratedSuspenseComponent(
       return (
         pushPrimaryTreeSuspenseHandler(workInProgress),
         (workInProgress.flags &= -257),
+        (didPrimaryChildrenDefer = createCapturedValueFromError(
+          Error(
+            "There was an error while hydrating this Suspense boundary. Switched to client rendering."
+          )
+        )),
         retrySuspenseComponentWithoutHydrating(
           current,
           workInProgress,
           renderLanes,
-          {
-            value: Error(
-              "There was an error while hydrating this Suspense boundary. Switched to client rendering."
-            ),
-            source: null,
-            stack: null,
-            digest: null
-          }
+          didPrimaryChildrenDefer
         )
       );
     if (null !== workInProgress.memoizedState)
@@ -5486,17 +5216,16 @@ function updateDehydratedSuspenseComponent(
         "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."
       )),
       (suspenseState.digest = didPrimaryChildrenDefer),
+      (didPrimaryChildrenDefer = createCapturedValueFromError(
+        suspenseState,
+        didPrimaryChildrenDefer,
+        void 0
+      )),
       retrySuspenseComponentWithoutHydrating(
         current,
         workInProgress,
         renderLanes,
-        {
-          value: suspenseState,
-          source: null,
-          stack: null,
-          digest:
-            null != didPrimaryChildrenDefer ? didPrimaryChildrenDefer : null
-        }
+        didPrimaryChildrenDefer
       )
     );
   didPrimaryChildrenDefer = 0 !== (renderLanes & current.childLanes);
@@ -5726,29 +5455,25 @@ function attemptEarlyBailoutIfNoScheduledUpdate(
 ) {
   switch (workInProgress.tag) {
     case 3:
-      pushHostRootContext(workInProgress);
+      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
       break;
     case 27:
     case 5:
       pushHostContext(workInProgress);
       break;
-    case 1:
-      isContextProvider(workInProgress.type) &&
-        pushContextProvider(workInProgress);
-      break;
     case 4:
       pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
       break;
     case 10:
-      var context = workInProgress.type._context,
-        nextValue = workInProgress.memoizedProps.value;
+      var newValue = workInProgress.memoizedProps.value,
+        context = workInProgress.type._context;
       push(valueCursor, context._currentValue2);
-      context._currentValue2 = nextValue;
+      context._currentValue2 = newValue;
       break;
     case 13:
-      context = workInProgress.memoizedState;
-      if (null !== context) {
-        if (null !== context.dehydrated)
+      newValue = workInProgress.memoizedState;
+      if (null !== newValue) {
+        if (null !== newValue.dehydrated)
           return (
             pushPrimaryTreeSuspenseHandler(workInProgress),
             (workInProgress.flags |= 128),
@@ -5767,9 +5492,9 @@ function attemptEarlyBailoutIfNoScheduledUpdate(
       pushPrimaryTreeSuspenseHandler(workInProgress);
       break;
     case 19:
-      context = 0 !== (renderLanes & workInProgress.childLanes);
+      newValue = 0 !== (renderLanes & workInProgress.childLanes);
       if (0 !== (current.flags & 128)) {
-        if (context)
+        if (newValue)
           return updateSuspenseListComponent(
             current,
             workInProgress,
@@ -5777,13 +5502,13 @@ function attemptEarlyBailoutIfNoScheduledUpdate(
           );
         workInProgress.flags |= 128;
       }
-      nextValue = workInProgress.memoizedState;
-      null !== nextValue &&
-        ((nextValue.rendering = null),
-        (nextValue.tail = null),
-        (nextValue.lastEffect = null));
+      context = workInProgress.memoizedState;
+      null !== context &&
+        ((context.rendering = null),
+        (context.tail = null),
+        (context.lastEffect = null));
       push(suspenseStackCursor, suspenseStackCursor.current);
-      if (context) break;
+      if (newValue) break;
       else return null;
     case 22:
     case 23:
@@ -5794,3107 +5519,3086 @@ function attemptEarlyBailoutIfNoScheduledUpdate(
   }
   return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
 }
-var valueCursor = createCursor(null),
-  currentlyRenderingFiber = null,
-  lastContextDependency = null,
-  lastFullyObservedContext = null;
-function resetContextDependencies() {
-  lastFullyObservedContext =
-    lastContextDependency =
-    currentlyRenderingFiber =
-      null;
-}
-function popProvider(context) {
-  context._currentValue2 = valueCursor.current;
-  pop(valueCursor);
-}
-function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {
-  for (; null !== parent; ) {
-    var alternate = parent.alternate;
-    (parent.childLanes & renderLanes) !== renderLanes
-      ? ((parent.childLanes |= renderLanes),
-        null !== alternate && (alternate.childLanes |= renderLanes))
-      : null !== alternate &&
-        (alternate.childLanes & renderLanes) !== renderLanes &&
-        (alternate.childLanes |= renderLanes);
-    if (parent === propagationRoot) break;
-    parent = parent.return;
-  }
-}
-function prepareToReadContext(workInProgress, renderLanes) {
-  currentlyRenderingFiber = workInProgress;
-  lastFullyObservedContext = lastContextDependency = null;
-  workInProgress = workInProgress.dependencies;
-  null !== workInProgress &&
-    null !== workInProgress.firstContext &&
-    (0 !== (workInProgress.lanes & renderLanes) && (didReceiveUpdate = !0),
-    (workInProgress.firstContext = null));
-}
-function readContext(context) {
-  return readContextForConsumer(currentlyRenderingFiber, context);
-}
-function readContextDuringReconcilation(consumer, context, renderLanes) {
-  null === currentlyRenderingFiber &&
-    prepareToReadContext(consumer, renderLanes);
-  return readContextForConsumer(consumer, context);
-}
-function readContextForConsumer(consumer, context) {
-  var value = context._currentValue2;
-  if (lastFullyObservedContext !== context)
-    if (
-      ((context = { context: context, memoizedValue: value, next: null }),
-      null === lastContextDependency)
-    ) {
-      if (null === consumer)
-        throw Error(
-          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
+function beginWork(current, workInProgress, renderLanes) {
+  if (null !== current)
+    if (current.memoizedProps !== workInProgress.pendingProps)
+      didReceiveUpdate = !0;
+    else {
+      if (
+        0 === (current.lanes & renderLanes) &&
+        0 === (workInProgress.flags & 128)
+      )
+        return (
+          (didReceiveUpdate = !1),
+          attemptEarlyBailoutIfNoScheduledUpdate(
+            current,
+            workInProgress,
+            renderLanes
+          )
         );
-      lastContextDependency = context;
-      consumer.dependencies = { lanes: 0, firstContext: context };
-    } else lastContextDependency = lastContextDependency.next = context;
-  return value;
-}
-var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
-function handleAsyncAction() {}
-function doesRequireClone(current, completedWork) {
-  if (null !== current && current.child === completedWork.child) return !1;
-  if (0 !== (completedWork.flags & 16)) return !0;
-  for (current = completedWork.child; null !== current; ) {
-    if (0 !== (current.flags & 12854) || 0 !== (current.subtreeFlags & 12854))
-      return !0;
-    current = current.sibling;
-  }
-  return !1;
-}
-function appendAllChildren(
-  parent,
-  workInProgress,
-  needsVisibilityToggle,
-  isHidden
-) {
-  for (var node = workInProgress.child; null !== node; ) {
-    if (5 === node.tag) {
-      var instance = node.stateNode;
-      needsVisibilityToggle &&
-        isHidden &&
-        (instance = cloneHiddenInstance(instance));
-      appendChildNode(parent.node, instance.node);
-    } else if (6 === node.tag) {
-      instance = node.stateNode;
-      if (needsVisibilityToggle && isHidden)
-        throw Error("Not yet implemented.");
-      appendChildNode(parent.node, instance.node);
-    } else if (4 !== node.tag)
-      if (22 === node.tag && null !== node.memoizedState)
-        (instance = node.child),
-          null !== instance && (instance.return = node),
-          appendAllChildren(parent, node, !0, !0);
-      else if (null !== node.child) {
-        node.child.return = node;
-        node = node.child;
-        continue;
-      }
-    if (node === workInProgress) break;
-    for (; null === node.sibling; ) {
-      if (null === node.return || node.return === workInProgress) return;
-      node = node.return;
-    }
-    node.sibling.return = node.return;
-    node = node.sibling;
-  }
-}
-function appendAllChildrenToContainer(
-  containerChildSet,
-  workInProgress,
-  needsVisibilityToggle,
-  isHidden
-) {
-  for (var node = workInProgress.child; null !== node; ) {
-    if (5 === node.tag) {
-      var instance = node.stateNode;
-      needsVisibilityToggle &&
-        isHidden &&
-        (instance = cloneHiddenInstance(instance));
-      appendChildNodeToSet(containerChildSet, instance.node);
-    } else if (6 === node.tag) {
-      instance = node.stateNode;
-      if (needsVisibilityToggle && isHidden)
-        throw Error("Not yet implemented.");
-      appendChildNodeToSet(containerChildSet, instance.node);
-    } else if (4 !== node.tag)
-      if (22 === node.tag && null !== node.memoizedState)
-        (instance = node.child),
-          null !== instance && (instance.return = node),
-          appendAllChildrenToContainer(
-            containerChildSet,
-            node,
-            !(
-              null !== node.memoizedProps &&
-              "manual" === node.memoizedProps.mode
-            ),
-            !0
-          );
-      else if (null !== node.child) {
-        node.child.return = node;
-        node = node.child;
-        continue;
-      }
-    if (node === workInProgress) break;
-    for (; null === node.sibling; ) {
-      if (null === node.return || node.return === workInProgress) return;
-      node = node.return;
+      didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;
     }
-    node.sibling.return = node.return;
-    node = node.sibling;
-  }
-}
-function updateHostContainer(current, workInProgress) {
-  if (doesRequireClone(current, workInProgress)) {
-    current = workInProgress.stateNode;
-    var container = current.containerInfo,
-      newChildSet = createChildNodeSet();
-    appendAllChildrenToContainer(newChildSet, workInProgress, !1, !1);
-    current.pendingChildren = newChildSet;
-    workInProgress.flags |= 4;
-    completeRoot(container, newChildSet);
-  }
-}
-function scheduleRetryEffect(workInProgress, retryQueue) {
-  null !== retryQueue
-    ? (workInProgress.flags |= 4)
-    : workInProgress.flags & 16384 &&
-      ((retryQueue =
-        22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),
-      (workInProgress.lanes |= retryQueue));
-}
-function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
-  switch (renderState.tailMode) {
-    case "hidden":
-      hasRenderedATailFallback = renderState.tail;
-      for (var lastTailNode = null; null !== hasRenderedATailFallback; )
-        null !== hasRenderedATailFallback.alternate &&
-          (lastTailNode = hasRenderedATailFallback),
-          (hasRenderedATailFallback = hasRenderedATailFallback.sibling);
-      null === lastTailNode
-        ? (renderState.tail = null)
-        : (lastTailNode.sibling = null);
-      break;
-    case "collapsed":
-      lastTailNode = renderState.tail;
-      for (var lastTailNode$61 = null; null !== lastTailNode; )
-        null !== lastTailNode.alternate && (lastTailNode$61 = lastTailNode),
-          (lastTailNode = lastTailNode.sibling);
-      null === lastTailNode$61
-        ? hasRenderedATailFallback || null === renderState.tail
-          ? (renderState.tail = null)
-          : (renderState.tail.sibling = null)
-        : (lastTailNode$61.sibling = null);
-  }
-}
-function bubbleProperties(completedWork) {
-  var didBailout =
-      null !== completedWork.alternate &&
-      completedWork.alternate.child === completedWork.child,
-    newChildLanes = 0,
-    subtreeFlags = 0;
-  if (didBailout)
-    for (var child$62 = completedWork.child; null !== child$62; )
-      (newChildLanes |= child$62.lanes | child$62.childLanes),
-        (subtreeFlags |= child$62.subtreeFlags & 31457280),
-        (subtreeFlags |= child$62.flags & 31457280),
-        (child$62.return = completedWork),
-        (child$62 = child$62.sibling);
-  else
-    for (child$62 = completedWork.child; null !== child$62; )
-      (newChildLanes |= child$62.lanes | child$62.childLanes),
-        (subtreeFlags |= child$62.subtreeFlags),
-        (subtreeFlags |= child$62.flags),
-        (child$62.return = completedWork),
-        (child$62 = child$62.sibling);
-  completedWork.subtreeFlags |= subtreeFlags;
-  completedWork.childLanes = newChildLanes;
-  return didBailout;
-}
-function completeWork(current, workInProgress, renderLanes) {
-  var newProps = workInProgress.pendingProps;
+  else didReceiveUpdate = !1;
+  workInProgress.lanes = 0;
   switch (workInProgress.tag) {
     case 2:
+      var Component = workInProgress.type;
+      resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress);
+      current = workInProgress.pendingProps;
+      prepareToReadContext(workInProgress, renderLanes);
+      var value = renderWithHooks(
+        null,
+        workInProgress,
+        Component,
+        current,
+        void 0,
+        renderLanes
+      );
+      workInProgress.flags |= 1;
+      "object" === typeof value &&
+      null !== value &&
+      "function" === typeof value.render &&
+      void 0 === value.$$typeof
+        ? ((workInProgress.tag = 1),
+          (workInProgress.memoizedState = null),
+          (workInProgress.updateQueue = null),
+          (workInProgress.memoizedState =
+            null !== value.state && void 0 !== value.state
+              ? value.state
+              : null),
+          initializeUpdateQueue(workInProgress),
+          (value.updater = classComponentUpdater),
+          (workInProgress.stateNode = value),
+          (value._reactInternals = workInProgress),
+          mountClassInstance(workInProgress, Component, current, renderLanes),
+          (workInProgress = finishClassComponent(
+            null,
+            workInProgress,
+            Component,
+            !0,
+            !1,
+            renderLanes
+          )))
+        : ((workInProgress.tag = 0),
+          reconcileChildren(null, workInProgress, value, renderLanes),
+          (workInProgress = workInProgress.child));
+      return workInProgress;
     case 16:
-    case 15:
+      Component = workInProgress.elementType;
+      a: {
+        resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress);
+        current = workInProgress.pendingProps;
+        value = Component._init;
+        Component = value(Component._payload);
+        workInProgress.type = Component;
+        value = workInProgress.tag = resolveLazyComponentTag(Component);
+        current = resolveDefaultProps(Component, current);
+        switch (value) {
+          case 0:
+            workInProgress = updateFunctionComponent(
+              null,
+              workInProgress,
+              Component,
+              current,
+              renderLanes
+            );
+            break a;
+          case 1:
+            workInProgress = updateClassComponent(
+              null,
+              workInProgress,
+              Component,
+              current,
+              renderLanes
+            );
+            break a;
+          case 11:
+            workInProgress = updateForwardRef(
+              null,
+              workInProgress,
+              Component,
+              current,
+              renderLanes
+            );
+            break a;
+          case 14:
+            workInProgress = updateMemoComponent(
+              null,
+              workInProgress,
+              Component,
+              resolveDefaultProps(Component.type, current),
+              renderLanes
+            );
+            break a;
+        }
+        throw Error(
+          "Element type is invalid. Received a promise that resolves to: " +
+            Component +
+            ". Lazy element type must resolve to a class or function."
+        );
+      }
+      return workInProgress;
     case 0:
-    case 11:
-    case 7:
-    case 8:
-    case 12:
-    case 9:
-    case 14:
-      return bubbleProperties(workInProgress), null;
+      return (
+        (Component = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === Component
+            ? value
+            : resolveDefaultProps(Component, value)),
+        updateFunctionComponent(
+          current,
+          workInProgress,
+          Component,
+          value,
+          renderLanes
+        )
+      );
     case 1:
       return (
-        isContextProvider(workInProgress.type) && popContext(),
-        bubbleProperties(workInProgress),
-        null
+        (Component = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === Component
+            ? value
+            : resolveDefaultProps(Component, value)),
+        updateClassComponent(
+          current,
+          workInProgress,
+          Component,
+          value,
+          renderLanes
+        )
       );
     case 3:
-      return (
-        (newProps = workInProgress.stateNode),
-        popHostContainer(),
-        pop(didPerformWorkStackCursor),
-        pop(contextStackCursor$1),
-        newProps.pendingContext &&
-          ((newProps.context = newProps.pendingContext),
-          (newProps.pendingContext = null)),
-        (null !== current && null !== current.child) ||
-          null === current ||
-          (current.memoizedState.isDehydrated &&
-            0 === (workInProgress.flags & 256)) ||
-          ((workInProgress.flags |= 1024),
-          null !== hydrationErrors &&
-            (queueRecoverableErrors(hydrationErrors),
-            (hydrationErrors = null))),
-        updateHostContainer(current, workInProgress),
-        bubbleProperties(workInProgress),
-        null
-      );
+      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
+      if (null === current)
+        throw Error("Should have a current fiber. This is a bug in React.");
+      value = workInProgress.pendingProps;
+      Component = workInProgress.memoizedState.element;
+      cloneUpdateQueue(current, workInProgress);
+      processUpdateQueue(workInProgress, value, null, renderLanes);
+      value = workInProgress.memoizedState.element;
+      value === Component
+        ? (workInProgress = bailoutOnAlreadyFinishedWork(
+            current,
+            workInProgress,
+            renderLanes
+          ))
+        : (reconcileChildren(current, workInProgress, value, renderLanes),
+          (workInProgress = workInProgress.child));
+      return workInProgress;
     case 26:
     case 27:
     case 5:
-      popHostContext(workInProgress);
-      renderLanes = workInProgress.type;
-      if (null !== current && null != workInProgress.stateNode) {
-        renderLanes = current.stateNode;
-        var oldProps = current.memoizedProps,
-          requiresClone = doesRequireClone(current, workInProgress);
-        if (requiresClone || oldProps !== newProps) {
-          b: {
-            oldProps = diffProperties(
-              null,
-              oldProps,
-              newProps,
-              renderLanes.canonical.viewConfig.validAttributes
-            );
-            renderLanes.canonical.currentProps = newProps;
-            newProps = renderLanes.node;
-            if (requiresClone)
-              newProps =
-                null !== oldProps
-                  ? cloneNodeWithNewChildrenAndProps(newProps, oldProps)
-                  : cloneNodeWithNewChildren(newProps);
-            else if (null !== oldProps)
-              newProps = cloneNodeWithNewProps(newProps, oldProps);
-            else {
-              newProps = renderLanes;
-              break b;
-            }
-            newProps = { node: newProps, canonical: renderLanes.canonical };
-          }
-          newProps === renderLanes
-            ? (workInProgress.stateNode = renderLanes)
-            : ((workInProgress.stateNode = newProps),
-              requiresClone
-                ? appendAllChildren(newProps, workInProgress, !1, !1)
-                : (workInProgress.flags |= 4));
-        } else workInProgress.stateNode = renderLanes;
-        current.ref !== workInProgress.ref && (workInProgress.flags |= 2097664);
-      } else {
-        if (!newProps) {
-          if (null === workInProgress.stateNode)
-            throw Error(
-              "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
-            );
-          bubbleProperties(workInProgress);
-          return null;
-        }
-        requiresClone = rootInstanceStackCursor.current;
-        current = nextReactTag;
-        nextReactTag += 2;
-        renderLanes = getViewConfigForType(renderLanes);
-        oldProps = diffProperties(
-          null,
-          emptyObject,
-          newProps,
-          renderLanes.validAttributes
-        );
-        requiresClone = createNode(
-          current,
-          renderLanes.uiViewClassName,
-          requiresClone,
-          oldProps,
-          workInProgress
-        );
-        oldProps = ReactNativePrivateInterface.createPublicInstance(
-          current,
-          renderLanes,
-          workInProgress
-        );
-        current = {
-          node: requiresClone,
-          canonical: {
-            nativeTag: current,
-            viewConfig: renderLanes,
-            currentProps: newProps,
-            internalInstanceHandle: workInProgress,
-            publicInstance: oldProps
-          }
-        };
-        appendAllChildren(current, workInProgress, !1, !1);
-        workInProgress.stateNode = current;
-        null !== workInProgress.ref && (workInProgress.flags |= 2097664);
-      }
-      bubbleProperties(workInProgress);
-      workInProgress.flags &= -16777217;
-      return null;
+      return (
+        pushHostContext(workInProgress),
+        (Component = workInProgress.pendingProps.children),
+        markRef(current, workInProgress),
+        reconcileChildren(current, workInProgress, Component, renderLanes),
+        workInProgress.child
+      );
     case 6:
-      if (current && null != workInProgress.stateNode)
-        current.memoizedProps !== newProps
-          ? ((workInProgress.stateNode = createTextInstance(
-              newProps,
-              rootInstanceStackCursor.current,
-              contextStackCursor.current,
-              workInProgress
-            )),
-            (workInProgress.flags |= 4))
-          : (workInProgress.stateNode = current.stateNode);
-      else {
-        if ("string" !== typeof newProps && null === workInProgress.stateNode)
-          throw Error(
-            "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
-          );
-        workInProgress.stateNode = createTextInstance(
-          newProps,
-          rootInstanceStackCursor.current,
-          contextStackCursor.current,
-          workInProgress
-        );
-      }
-      bubbleProperties(workInProgress);
       return null;
     case 13:
-      popSuspenseHandler(workInProgress);
-      newProps = workInProgress.memoizedState;
-      if (
-        null === current ||
-        (null !== current.memoizedState &&
-          null !== current.memoizedState.dehydrated)
-      ) {
-        if (null !== newProps && null !== newProps.dehydrated) {
-          if (null === current) {
-            throw Error(
-              "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
-            );
-            throw Error(
-              "Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
-            );
-          }
-          0 === (workInProgress.flags & 128) &&
-            (workInProgress.memoizedState = null);
-          workInProgress.flags |= 4;
-          bubbleProperties(workInProgress);
-          requiresClone = !1;
-        } else
-          null !== hydrationErrors &&
-            (queueRecoverableErrors(hydrationErrors), (hydrationErrors = null)),
-            (requiresClone = !0);
-        if (!requiresClone)
-          return workInProgress.flags & 256 ? workInProgress : null;
-      }
-      if (0 !== (workInProgress.flags & 128))
-        return (workInProgress.lanes = renderLanes), workInProgress;
-      newProps = null !== newProps;
-      newProps !== (null !== current && null !== current.memoizedState) &&
-        newProps &&
-        (workInProgress.child.flags |= 8192);
-      scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
-      bubbleProperties(workInProgress);
-      return null;
+      return updateSuspenseComponent(current, workInProgress, renderLanes);
     case 4:
       return (
-        popHostContainer(),
-        updateHostContainer(current, workInProgress),
-        bubbleProperties(workInProgress),
-        null
+        pushHostContainer(
+          workInProgress,
+          workInProgress.stateNode.containerInfo
+        ),
+        (Component = workInProgress.pendingProps),
+        null === current
+          ? (workInProgress.child = reconcileChildFibers(
+              workInProgress,
+              null,
+              Component,
+              renderLanes
+            ))
+          : reconcileChildren(current, workInProgress, Component, renderLanes),
+        workInProgress.child
       );
-    case 10:
+    case 11:
       return (
-        popProvider(workInProgress.type._context),
-        bubbleProperties(workInProgress),
-        null
+        (Component = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === Component
+            ? value
+            : resolveDefaultProps(Component, value)),
+        updateForwardRef(current, workInProgress, Component, value, renderLanes)
       );
-    case 17:
+    case 7:
       return (
-        isContextProvider(workInProgress.type) && popContext(),
-        bubbleProperties(workInProgress),
-        null
+        reconcileChildren(
+          current,
+          workInProgress,
+          workInProgress.pendingProps,
+          renderLanes
+        ),
+        workInProgress.child
       );
-    case 19:
-      pop(suspenseStackCursor);
-      requiresClone = workInProgress.memoizedState;
-      if (null === requiresClone) return bubbleProperties(workInProgress), null;
-      newProps = 0 !== (workInProgress.flags & 128);
-      oldProps = requiresClone.rendering;
-      if (null === oldProps)
-        if (newProps) cutOffTailIfNeeded(requiresClone, !1);
-        else {
-          if (
-            0 !== workInProgressRootExitStatus ||
-            (null !== current && 0 !== (current.flags & 128))
-          )
-            for (current = workInProgress.child; null !== current; ) {
-              oldProps = findFirstSuspended(current);
-              if (null !== oldProps) {
-                workInProgress.flags |= 128;
-                cutOffTailIfNeeded(requiresClone, !1);
-                current = oldProps.updateQueue;
-                workInProgress.updateQueue = current;
-                scheduleRetryEffect(workInProgress, current);
-                workInProgress.subtreeFlags = 0;
-                current = renderLanes;
-                for (newProps = workInProgress.child; null !== newProps; )
-                  resetWorkInProgress(newProps, current),
-                    (newProps = newProps.sibling);
-                push(
-                  suspenseStackCursor,
-                  (suspenseStackCursor.current & 1) | 2
-                );
-                return workInProgress.child;
-              }
-              current = current.sibling;
+    case 8:
+      return (
+        reconcileChildren(
+          current,
+          workInProgress,
+          workInProgress.pendingProps.children,
+          renderLanes
+        ),
+        workInProgress.child
+      );
+    case 12:
+      return (
+        reconcileChildren(
+          current,
+          workInProgress,
+          workInProgress.pendingProps.children,
+          renderLanes
+        ),
+        workInProgress.child
+      );
+    case 10:
+      a: {
+        Component = workInProgress.type._context;
+        value = workInProgress.pendingProps;
+        var oldProps = workInProgress.memoizedProps,
+          newValue = value.value;
+        push(valueCursor, Component._currentValue2);
+        Component._currentValue2 = newValue;
+        if (null !== oldProps)
+          if (objectIs(oldProps.value, newValue)) {
+            if (oldProps.children === value.children) {
+              workInProgress = bailoutOnAlreadyFinishedWork(
+                current,
+                workInProgress,
+                renderLanes
+              );
+              break a;
             }
-          null !== requiresClone.tail &&
-            now() > workInProgressRootRenderTargetTime &&
-            ((workInProgress.flags |= 128),
-            (newProps = !0),
-            cutOffTailIfNeeded(requiresClone, !1),
-            (workInProgress.lanes = 4194304));
-        }
-      else {
-        if (!newProps)
-          if (((current = findFirstSuspended(oldProps)), null !== current)) {
-            if (
-              ((workInProgress.flags |= 128),
-              (newProps = !0),
-              (current = current.updateQueue),
-              (workInProgress.updateQueue = current),
-              scheduleRetryEffect(workInProgress, current),
-              cutOffTailIfNeeded(requiresClone, !0),
-              null === requiresClone.tail &&
-                "hidden" === requiresClone.tailMode &&
-                !oldProps.alternate)
-            )
-              return bubbleProperties(workInProgress), null;
           } else
-            2 * now() - requiresClone.renderingStartTime >
-              workInProgressRootRenderTargetTime &&
-              536870912 !== renderLanes &&
-              ((workInProgress.flags |= 128),
-              (newProps = !0),
-              cutOffTailIfNeeded(requiresClone, !1),
-              (workInProgress.lanes = 4194304));
-        requiresClone.isBackwards
-          ? ((oldProps.sibling = workInProgress.child),
-            (workInProgress.child = oldProps))
-          : ((current = requiresClone.last),
-            null !== current
-              ? (current.sibling = oldProps)
-              : (workInProgress.child = oldProps),
-            (requiresClone.last = oldProps));
+            for (
+              oldProps = workInProgress.child,
+                null !== oldProps && (oldProps.return = workInProgress);
+              null !== oldProps;
+
+            ) {
+              var list = oldProps.dependencies;
+              if (null !== list) {
+                newValue = oldProps.child;
+                for (
+                  var dependency = list.firstContext;
+                  null !== dependency;
+
+                ) {
+                  if (dependency.context === Component) {
+                    if (1 === oldProps.tag) {
+                      dependency = createUpdate(renderLanes & -renderLanes);
+                      dependency.tag = 2;
+                      var updateQueue = oldProps.updateQueue;
+                      if (null !== updateQueue) {
+                        updateQueue = updateQueue.shared;
+                        var pending = updateQueue.pending;
+                        null === pending
+                          ? (dependency.next = dependency)
+                          : ((dependency.next = pending.next),
+                            (pending.next = dependency));
+                        updateQueue.pending = dependency;
+                      }
+                    }
+                    oldProps.lanes |= renderLanes;
+                    dependency = oldProps.alternate;
+                    null !== dependency && (dependency.lanes |= renderLanes);
+                    scheduleContextWorkOnParentPath(
+                      oldProps.return,
+                      renderLanes,
+                      workInProgress
+                    );
+                    list.lanes |= renderLanes;
+                    break;
+                  }
+                  dependency = dependency.next;
+                }
+              } else if (10 === oldProps.tag)
+                newValue =
+                  oldProps.type === workInProgress.type ? null : oldProps.child;
+              else if (18 === oldProps.tag) {
+                newValue = oldProps.return;
+                if (null === newValue)
+                  throw Error(
+                    "We just came from a parent so we must have had a parent. This is a bug in React."
+                  );
+                newValue.lanes |= renderLanes;
+                list = newValue.alternate;
+                null !== list && (list.lanes |= renderLanes);
+                scheduleContextWorkOnParentPath(
+                  newValue,
+                  renderLanes,
+                  workInProgress
+                );
+                newValue = oldProps.sibling;
+              } else newValue = oldProps.child;
+              if (null !== newValue) newValue.return = oldProps;
+              else
+                for (newValue = oldProps; null !== newValue; ) {
+                  if (newValue === workInProgress) {
+                    newValue = null;
+                    break;
+                  }
+                  oldProps = newValue.sibling;
+                  if (null !== oldProps) {
+                    oldProps.return = newValue.return;
+                    newValue = oldProps;
+                    break;
+                  }
+                  newValue = newValue.return;
+                }
+              oldProps = newValue;
+            }
+        reconcileChildren(current, workInProgress, value.children, renderLanes);
+        workInProgress = workInProgress.child;
       }
-      if (null !== requiresClone.tail)
-        return (
-          (workInProgress = requiresClone.tail),
-          (requiresClone.rendering = workInProgress),
-          (requiresClone.tail = workInProgress.sibling),
-          (requiresClone.renderingStartTime = now()),
-          (workInProgress.sibling = null),
-          (current = suspenseStackCursor.current),
-          push(suspenseStackCursor, newProps ? (current & 1) | 2 : current & 1),
-          workInProgress
-        );
-      bubbleProperties(workInProgress);
-      return null;
-    case 22:
-    case 23:
+      return workInProgress;
+    case 9:
       return (
-        popSuspenseHandler(workInProgress),
-        popHiddenContext(),
-        (newProps = null !== workInProgress.memoizedState),
-        null !== current
-          ? (null !== current.memoizedState) !== newProps &&
-            (workInProgress.flags |= 8192)
-          : newProps && (workInProgress.flags |= 8192),
-        newProps && 0 !== (workInProgress.mode & 1)
-          ? 0 !== (renderLanes & 536870912) &&
-            0 === (workInProgress.flags & 128) &&
-            (bubbleProperties(workInProgress),
-            workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192))
-          : bubbleProperties(workInProgress),
-        (current = workInProgress.updateQueue),
-        null !== current &&
-          scheduleRetryEffect(workInProgress, current.retryQueue),
-        null
+        (value = workInProgress.type),
+        (Component = workInProgress.pendingProps.children),
+        prepareToReadContext(workInProgress, renderLanes),
+        (value = readContext(value)),
+        (Component = Component(value)),
+        (workInProgress.flags |= 1),
+        reconcileChildren(current, workInProgress, Component, renderLanes),
+        workInProgress.child
       );
-    case 24:
-      return null;
-    case 25:
-      return null;
-  }
-  throw Error(
-    "Unknown unit of work tag (" +
-      workInProgress.tag +
-      "). This error is likely caused by a bug in React. Please file an issue."
-  );
-}
-function unwindWork(current, workInProgress) {
-  switch (workInProgress.tag) {
-    case 1:
+    case 14:
       return (
-        isContextProvider(workInProgress.type) && popContext(),
-        (current = workInProgress.flags),
-        current & 65536
-          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
-          : null
+        (Component = workInProgress.type),
+        (value = resolveDefaultProps(Component, workInProgress.pendingProps)),
+        (value = resolveDefaultProps(Component.type, value)),
+        updateMemoComponent(
+          current,
+          workInProgress,
+          Component,
+          value,
+          renderLanes
+        )
       );
-    case 3:
-      return (
-        popHostContainer(),
-        pop(didPerformWorkStackCursor),
-        pop(contextStackCursor$1),
-        (current = workInProgress.flags),
-        0 !== (current & 65536) && 0 === (current & 128)
-          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
-          : null
+    case 15:
+      return updateSimpleMemoComponent(
+        current,
+        workInProgress,
+        workInProgress.type,
+        workInProgress.pendingProps,
+        renderLanes
       );
-    case 26:
-    case 27:
-    case 5:
-      return popHostContext(workInProgress), null;
-    case 13:
-      popSuspenseHandler(workInProgress);
-      current = workInProgress.memoizedState;
-      if (
-        null !== current &&
-        null !== current.dehydrated &&
-        null === workInProgress.alternate
-      )
-        throw Error(
-          "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
-        );
-      current = workInProgress.flags;
-      return current & 65536
-        ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
-        : null;
-    case 19:
-      return pop(suspenseStackCursor), null;
-    case 4:
-      return popHostContainer(), null;
-    case 10:
-      return popProvider(workInProgress.type._context), null;
-    case 22:
-    case 23:
+    case 17:
       return (
-        popSuspenseHandler(workInProgress),
-        popHiddenContext(),
-        (current = workInProgress.flags),
-        current & 65536
-          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
-          : null
+        (Component = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === Component
+            ? value
+            : resolveDefaultProps(Component, value)),
+        resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress),
+        (workInProgress.tag = 1),
+        prepareToReadContext(workInProgress, renderLanes),
+        constructClassInstance(workInProgress, Component, value),
+        mountClassInstance(workInProgress, Component, value, renderLanes),
+        finishClassComponent(
+          null,
+          workInProgress,
+          Component,
+          !0,
+          !1,
+          renderLanes
+        )
       );
-    case 24:
-      return null;
-    case 25:
-      return null;
-    default:
-      return null;
-  }
-}
-function unwindInterruptedWork(current, interruptedWork) {
-  switch (interruptedWork.tag) {
-    case 1:
-      current = interruptedWork.type.childContextTypes;
-      null !== current && void 0 !== current && popContext();
-      break;
-    case 3:
-      popHostContainer();
-      pop(didPerformWorkStackCursor);
-      pop(contextStackCursor$1);
-      break;
-    case 26:
-    case 27:
-    case 5:
-      popHostContext(interruptedWork);
-      break;
-    case 4:
-      popHostContainer();
-      break;
-    case 13:
-      popSuspenseHandler(interruptedWork);
-      break;
     case 19:
-      pop(suspenseStackCursor);
-      break;
-    case 10:
-      popProvider(interruptedWork.type._context);
-      break;
+      return updateSuspenseListComponent(current, workInProgress, renderLanes);
     case 22:
-    case 23:
-      popSuspenseHandler(interruptedWork), popHiddenContext();
+      return updateOffscreenComponent(current, workInProgress, renderLanes);
   }
+  throw Error(
+    "Unknown unit of work tag (" +
+      workInProgress.tag +
+      "). This error is likely caused by a bug in React. Please file an issue."
+  );
 }
-var offscreenSubtreeIsHidden = !1,
-  offscreenSubtreeWasHidden = !1,
-  PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
-  nextEffect = null;
-function safelyAttachRef(current, nearestMountedAncestor) {
-  try {
-    var ref = current.ref;
-    if (null !== ref) {
-      var instance = current.stateNode;
-      switch (current.tag) {
-        case 26:
-        case 27:
-        case 5:
-          var instanceToUse = getPublicInstance(instance);
-          break;
-        default:
-          instanceToUse = instance;
-      }
-      "function" === typeof ref
-        ? (current.refCleanup = ref(instanceToUse))
-        : (ref.current = instanceToUse);
-    }
-  } catch (error) {
-    captureCommitPhaseError(current, nearestMountedAncestor, error);
-  }
+var valueCursor = createCursor(null),
+  currentlyRenderingFiber = null,
+  lastContextDependency = null,
+  lastFullyObservedContext = null;
+function resetContextDependencies() {
+  lastFullyObservedContext =
+    lastContextDependency =
+    currentlyRenderingFiber =
+      null;
 }
-function safelyDetachRef(current, nearestMountedAncestor) {
-  var ref = current.ref,
-    refCleanup = current.refCleanup;
-  if (null !== ref)
-    if ("function" === typeof refCleanup)
-      try {
-        refCleanup();
-      } catch (error) {
-        captureCommitPhaseError(current, nearestMountedAncestor, error);
-      } finally {
-        (current.refCleanup = null),
-          (current = current.alternate),
-          null != current && (current.refCleanup = null);
-      }
-    else if ("function" === typeof ref)
-      try {
-        ref(null);
-      } catch (error$77) {
-        captureCommitPhaseError(current, nearestMountedAncestor, error$77);
-      }
-    else ref.current = null;
+function popProvider(context) {
+  context._currentValue2 = valueCursor.current;
+  pop(valueCursor);
 }
-function safelyCallDestroy(current, nearestMountedAncestor, destroy) {
-  try {
-    destroy();
-  } catch (error) {
-    captureCommitPhaseError(current, nearestMountedAncestor, error);
+function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {
+  for (; null !== parent; ) {
+    var alternate = parent.alternate;
+    (parent.childLanes & renderLanes) !== renderLanes
+      ? ((parent.childLanes |= renderLanes),
+        null !== alternate && (alternate.childLanes |= renderLanes))
+      : null !== alternate &&
+        (alternate.childLanes & renderLanes) !== renderLanes &&
+        (alternate.childLanes |= renderLanes);
+    if (parent === propagationRoot) break;
+    parent = parent.return;
   }
 }
-var shouldFireAfterActiveInstanceBlur = !1;
-function commitBeforeMutationEffects(root, firstChild) {
-  for (nextEffect = firstChild; null !== nextEffect; )
-    if (
-      ((root = nextEffect),
-      (firstChild = root.child),
-      0 !== (root.subtreeFlags & 1028) && null !== firstChild)
-    )
-      (firstChild.return = root), (nextEffect = firstChild);
-    else
-      for (; null !== nextEffect; ) {
-        root = nextEffect;
-        try {
-          var current = root.alternate,
-            flags = root.flags;
-          switch (root.tag) {
-            case 0:
-              break;
-            case 11:
-            case 15:
-              break;
-            case 1:
-              if (0 !== (flags & 1024) && null !== current) {
-                var prevProps = current.memoizedProps,
-                  prevState = current.memoizedState,
-                  instance = root.stateNode,
-                  snapshot = instance.getSnapshotBeforeUpdate(
-                    root.elementType === root.type
-                      ? prevProps
-                      : resolveDefaultProps(root.type, prevProps),
-                    prevState
-                  );
-                instance.__reactInternalSnapshotBeforeUpdate = snapshot;
-              }
-              break;
-            case 3:
-              break;
-            case 5:
-            case 26:
-            case 27:
-            case 6:
-            case 4:
-            case 17:
-              break;
-            default:
-              if (0 !== (flags & 1024))
-                throw Error(
-                  "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
-                );
-          }
-        } catch (error) {
-          captureCommitPhaseError(root, root.return, error);
-        }
-        firstChild = root.sibling;
-        if (null !== firstChild) {
-          firstChild.return = root.return;
-          nextEffect = firstChild;
-          break;
-        }
-        nextEffect = root.return;
-      }
-  current = shouldFireAfterActiveInstanceBlur;
-  shouldFireAfterActiveInstanceBlur = !1;
-  return current;
+function prepareToReadContext(workInProgress, renderLanes) {
+  currentlyRenderingFiber = workInProgress;
+  lastFullyObservedContext = lastContextDependency = null;
+  workInProgress = workInProgress.dependencies;
+  null !== workInProgress &&
+    null !== workInProgress.firstContext &&
+    (0 !== (workInProgress.lanes & renderLanes) && (didReceiveUpdate = !0),
+    (workInProgress.firstContext = null));
 }
-function commitHookEffectListUnmount(
-  flags,
-  finishedWork,
-  nearestMountedAncestor
-) {
-  var updateQueue = finishedWork.updateQueue;
-  updateQueue = null !== updateQueue ? updateQueue.lastEffect : null;
-  if (null !== updateQueue) {
-    var effect = (updateQueue = updateQueue.next);
-    do {
-      if ((effect.tag & flags) === flags) {
-        var inst = effect.inst,
-          destroy = inst.destroy;
-        void 0 !== destroy &&
-          ((inst.destroy = void 0),
-          safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy));
-      }
-      effect = effect.next;
-    } while (effect !== updateQueue);
-  }
+function readContext(context) {
+  return readContextForConsumer(currentlyRenderingFiber, context);
 }
-function commitHookEffectListMount(flags, finishedWork) {
-  finishedWork = finishedWork.updateQueue;
-  finishedWork = null !== finishedWork ? finishedWork.lastEffect : null;
-  if (null !== finishedWork) {
-    var effect = (finishedWork = finishedWork.next);
-    do {
-      if ((effect.tag & flags) === flags) {
-        var create$78 = effect.create,
-          inst = effect.inst;
-        create$78 = create$78();
-        inst.destroy = create$78;
-      }
-      effect = effect.next;
-    } while (effect !== finishedWork);
-  }
+function readContextDuringReconciliation(consumer, context, renderLanes) {
+  null === currentlyRenderingFiber &&
+    prepareToReadContext(consumer, renderLanes);
+  return readContextForConsumer(consumer, context);
 }
-function commitHookLayoutEffects(finishedWork, hookFlags) {
-  try {
-    commitHookEffectListMount(hookFlags, finishedWork);
-  } catch (error) {
-    captureCommitPhaseError(finishedWork, finishedWork.return, error);
-  }
+function readContextForConsumer(consumer, context) {
+  var value = context._currentValue2;
+  if (lastFullyObservedContext !== context)
+    if (
+      ((context = { context: context, memoizedValue: value, next: null }),
+      null === lastContextDependency)
+    ) {
+      if (null === consumer)
+        throw Error(
+          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
+        );
+      lastContextDependency = context;
+      consumer.dependencies = { lanes: 0, firstContext: context };
+    } else lastContextDependency = lastContextDependency.next = context;
+  return value;
 }
-function commitClassCallbacks(finishedWork) {
-  var updateQueue = finishedWork.updateQueue;
-  if (null !== updateQueue) {
-    var instance = finishedWork.stateNode;
-    try {
-      commitCallbacks(updateQueue, instance);
-    } catch (error) {
-      captureCommitPhaseError(finishedWork, finishedWork.return, error);
-    }
+var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
+function handleAsyncAction() {}
+function doesRequireClone(current, completedWork) {
+  if (null !== current && current.child === completedWork.child) return !1;
+  if (0 !== (completedWork.flags & 16)) return !0;
+  for (current = completedWork.child; null !== current; ) {
+    if (0 !== (current.flags & 12854) || 0 !== (current.subtreeFlags & 12854))
+      return !0;
+    current = current.sibling;
   }
+  return !1;
 }
-function commitHostComponentMount(finishedWork) {
-  try {
-    throw Error(
-      "The current renderer does not support mutation. This error is likely caused by a bug in React. Please file an issue."
-    );
-  } catch (error) {
-    captureCommitPhaseError(finishedWork, finishedWork.return, error);
+function appendAllChildren(
+  parent,
+  workInProgress,
+  needsVisibilityToggle,
+  isHidden
+) {
+  for (var node = workInProgress.child; null !== node; ) {
+    if (5 === node.tag) {
+      var instance = node.stateNode;
+      needsVisibilityToggle &&
+        isHidden &&
+        (instance = cloneHiddenInstance(instance));
+      appendChildNode(parent.node, instance.node);
+    } else if (6 === node.tag) {
+      instance = node.stateNode;
+      if (needsVisibilityToggle && isHidden)
+        throw Error("Not yet implemented.");
+      appendChildNode(parent.node, instance.node);
+    } else if (4 !== node.tag)
+      if (22 === node.tag && null !== node.memoizedState)
+        (instance = node.child),
+          null !== instance && (instance.return = node),
+          appendAllChildren(parent, node, !0, !0);
+      else if (null !== node.child) {
+        node.child.return = node;
+        node = node.child;
+        continue;
+      }
+    if (node === workInProgress) break;
+    for (; null === node.sibling; ) {
+      if (null === node.return || node.return === workInProgress) return;
+      node = node.return;
+    }
+    node.sibling.return = node.return;
+    node = node.sibling;
   }
 }
-function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
-  var flags = finishedWork.flags;
-  switch (finishedWork.tag) {
-    case 0:
-    case 11:
-    case 15:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      flags & 4 && commitHookLayoutEffects(finishedWork, 5);
-      break;
-    case 1:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      if (flags & 4)
-        if (((finishedRoot = finishedWork.stateNode), null === current))
-          try {
-            finishedRoot.componentDidMount();
-          } catch (error) {
-            captureCommitPhaseError(finishedWork, finishedWork.return, error);
-          }
-        else {
-          var prevProps =
-            finishedWork.elementType === finishedWork.type
-              ? current.memoizedProps
-              : resolveDefaultProps(finishedWork.type, current.memoizedProps);
-          current = current.memoizedState;
-          try {
-            finishedRoot.componentDidUpdate(
-              prevProps,
-              current,
-              finishedRoot.__reactInternalSnapshotBeforeUpdate
-            );
-          } catch (error$79) {
-            captureCommitPhaseError(
-              finishedWork,
-              finishedWork.return,
-              error$79
-            );
-          }
-        }
-      flags & 64 && commitClassCallbacks(finishedWork);
-      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
-      break;
-    case 3:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      if (flags & 64 && ((flags = finishedWork.updateQueue), null !== flags)) {
-        finishedRoot = null;
-        if (null !== finishedWork.child)
-          switch (finishedWork.child.tag) {
-            case 27:
-            case 5:
-              finishedRoot = getPublicInstance(finishedWork.child.stateNode);
-              break;
-            case 1:
-              finishedRoot = finishedWork.child.stateNode;
-          }
-        try {
-          commitCallbacks(flags, finishedRoot);
-        } catch (error) {
-          captureCommitPhaseError(finishedWork, finishedWork.return, error);
-        }
+function appendAllChildrenToContainer(
+  containerChildSet,
+  workInProgress,
+  needsVisibilityToggle,
+  isHidden
+) {
+  for (var node = workInProgress.child; null !== node; ) {
+    if (5 === node.tag) {
+      var instance = node.stateNode;
+      needsVisibilityToggle &&
+        isHidden &&
+        (instance = cloneHiddenInstance(instance));
+      appendChildNodeToSet(containerChildSet, instance.node);
+    } else if (6 === node.tag) {
+      instance = node.stateNode;
+      if (needsVisibilityToggle && isHidden)
+        throw Error("Not yet implemented.");
+      appendChildNodeToSet(containerChildSet, instance.node);
+    } else if (4 !== node.tag)
+      if (22 === node.tag && null !== node.memoizedState)
+        (instance = node.child),
+          null !== instance && (instance.return = node),
+          appendAllChildrenToContainer(
+            containerChildSet,
+            node,
+            !(
+              null !== node.memoizedProps &&
+              "manual" === node.memoizedProps.mode
+            ),
+            !0
+          );
+      else if (null !== node.child) {
+        node.child.return = node;
+        node = node.child;
+        continue;
       }
-      break;
-    case 26:
-    case 27:
-    case 5:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      null === current && flags & 4 && commitHostComponentMount(finishedWork);
-      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
-      break;
-    case 12:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      break;
-    case 13:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      break;
-    case 22:
-      if (0 !== (finishedWork.mode & 1)) {
-        if (
-          ((prevProps =
-            null !== finishedWork.memoizedState || offscreenSubtreeIsHidden),
-          !prevProps)
-        ) {
-          current =
-            (null !== current && null !== current.memoizedState) ||
-            offscreenSubtreeWasHidden;
-          var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
-            prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
-          offscreenSubtreeIsHidden = prevProps;
-          (offscreenSubtreeWasHidden = current) &&
-          !prevOffscreenSubtreeWasHidden
-            ? recursivelyTraverseReappearLayoutEffects(
-                finishedRoot,
-                finishedWork,
-                0 !== (finishedWork.subtreeFlags & 8772)
-              )
-            : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
-          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
-        }
-      } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      flags & 512 &&
-        ("manual" === finishedWork.memoizedProps.mode
-          ? safelyAttachRef(finishedWork, finishedWork.return)
-          : safelyDetachRef(finishedWork, finishedWork.return));
-      break;
-    default:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+    if (node === workInProgress) break;
+    for (; null === node.sibling; ) {
+      if (null === node.return || node.return === workInProgress) return;
+      node = node.return;
+    }
+    node.sibling.return = node.return;
+    node = node.sibling;
   }
 }
-function detachFiberAfterEffects(fiber) {
-  var alternate = fiber.alternate;
-  null !== alternate &&
-    ((fiber.alternate = null), detachFiberAfterEffects(alternate));
-  fiber.child = null;
-  fiber.deletions = null;
-  fiber.sibling = null;
-  fiber.stateNode = null;
-  fiber.return = null;
-  fiber.dependencies = null;
-  fiber.memoizedProps = null;
-  fiber.memoizedState = null;
-  fiber.pendingProps = null;
-  fiber.stateNode = null;
-  fiber.updateQueue = null;
+function updateHostContainer(current, workInProgress) {
+  if (doesRequireClone(current, workInProgress)) {
+    current = workInProgress.stateNode;
+    var container = current.containerInfo,
+      newChildSet = createChildNodeSet();
+    appendAllChildrenToContainer(newChildSet, workInProgress, !1, !1);
+    current.pendingChildren = newChildSet;
+    workInProgress.flags |= 4;
+    completeRoot(container, newChildSet);
+  }
 }
-function recursivelyTraverseDeletionEffects(
-  finishedRoot,
-  nearestMountedAncestor,
-  parent
-) {
-  for (parent = parent.child; null !== parent; )
-    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent),
-      (parent = parent.sibling);
+function scheduleRetryEffect(workInProgress, retryQueue) {
+  null !== retryQueue
+    ? (workInProgress.flags |= 4)
+    : workInProgress.flags & 16384 &&
+      ((retryQueue =
+        22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),
+      (workInProgress.lanes |= retryQueue));
 }
-function commitDeletionEffectsOnFiber(
-  finishedRoot,
-  nearestMountedAncestor,
-  deletedFiber
-) {
-  if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
-    try {
-      injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
-    } catch (err) {}
-  switch (deletedFiber.tag) {
-    case 26:
-    case 27:
-    case 5:
-      offscreenSubtreeWasHidden ||
-        safelyDetachRef(deletedFiber, nearestMountedAncestor);
-    case 6:
-      recursivelyTraverseDeletionEffects(
-        finishedRoot,
-        nearestMountedAncestor,
-        deletedFiber
-      );
-      break;
-    case 18:
-      break;
-    case 4:
-      createChildNodeSet();
-      recursivelyTraverseDeletionEffects(
-        finishedRoot,
-        nearestMountedAncestor,
-        deletedFiber
-      );
+function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
+  switch (renderState.tailMode) {
+    case "hidden":
+      hasRenderedATailFallback = renderState.tail;
+      for (var lastTailNode = null; null !== hasRenderedATailFallback; )
+        null !== hasRenderedATailFallback.alternate &&
+          (lastTailNode = hasRenderedATailFallback),
+          (hasRenderedATailFallback = hasRenderedATailFallback.sibling);
+      null === lastTailNode
+        ? (renderState.tail = null)
+        : (lastTailNode.sibling = null);
       break;
+    case "collapsed":
+      lastTailNode = renderState.tail;
+      for (var lastTailNode$61 = null; null !== lastTailNode; )
+        null !== lastTailNode.alternate && (lastTailNode$61 = lastTailNode),
+          (lastTailNode = lastTailNode.sibling);
+      null === lastTailNode$61
+        ? hasRenderedATailFallback || null === renderState.tail
+          ? (renderState.tail = null)
+          : (renderState.tail.sibling = null)
+        : (lastTailNode$61.sibling = null);
+  }
+}
+function bubbleProperties(completedWork) {
+  var didBailout =
+      null !== completedWork.alternate &&
+      completedWork.alternate.child === completedWork.child,
+    newChildLanes = 0,
+    subtreeFlags = 0;
+  if (didBailout)
+    for (var child$62 = completedWork.child; null !== child$62; )
+      (newChildLanes |= child$62.lanes | child$62.childLanes),
+        (subtreeFlags |= child$62.subtreeFlags & 31457280),
+        (subtreeFlags |= child$62.flags & 31457280),
+        (child$62.return = completedWork),
+        (child$62 = child$62.sibling);
+  else
+    for (child$62 = completedWork.child; null !== child$62; )
+      (newChildLanes |= child$62.lanes | child$62.childLanes),
+        (subtreeFlags |= child$62.subtreeFlags),
+        (subtreeFlags |= child$62.flags),
+        (child$62.return = completedWork),
+        (child$62 = child$62.sibling);
+  completedWork.subtreeFlags |= subtreeFlags;
+  completedWork.childLanes = newChildLanes;
+  return didBailout;
+}
+function completeWork(current, workInProgress, renderLanes) {
+  var newProps = workInProgress.pendingProps;
+  switch (workInProgress.tag) {
+    case 2:
+    case 16:
+    case 15:
     case 0:
     case 11:
-    case 14:
-    case 15:
-      if (!offscreenSubtreeWasHidden) {
-        var updateQueue = deletedFiber.updateQueue;
+    case 7:
+    case 8:
+    case 12:
+    case 9:
+    case 14:
+      return bubbleProperties(workInProgress), null;
+    case 1:
+      return bubbleProperties(workInProgress), null;
+    case 3:
+      return (
+        (newProps = workInProgress.stateNode),
+        popHostContainer(),
+        newProps.pendingContext &&
+          ((newProps.context = newProps.pendingContext),
+          (newProps.pendingContext = null)),
+        (null !== current && null !== current.child) ||
+          null === current ||
+          (current.memoizedState.isDehydrated &&
+            0 === (workInProgress.flags & 256)) ||
+          ((workInProgress.flags |= 1024),
+          null !== hydrationErrors &&
+            (queueRecoverableErrors(hydrationErrors),
+            (hydrationErrors = null))),
+        updateHostContainer(current, workInProgress),
+        bubbleProperties(workInProgress),
+        null
+      );
+    case 26:
+    case 27:
+    case 5:
+      popHostContext(workInProgress);
+      renderLanes = workInProgress.type;
+      if (null !== current && null != workInProgress.stateNode) {
+        renderLanes = current.stateNode;
+        var oldProps = current.memoizedProps;
         if (
-          null !== updateQueue &&
-          ((updateQueue = updateQueue.lastEffect), null !== updateQueue)
+          (current = doesRequireClone(current, workInProgress)) ||
+          oldProps !== newProps
         ) {
-          var effect = (updateQueue = updateQueue.next);
-          do {
-            var tag = effect.tag,
-              inst = effect.inst,
-              destroy = inst.destroy;
-            void 0 !== destroy &&
-              (0 !== (tag & 2)
-                ? ((inst.destroy = void 0),
-                  safelyCallDestroy(
-                    deletedFiber,
-                    nearestMountedAncestor,
-                    destroy
-                  ))
-                : 0 !== (tag & 4) &&
-                  ((inst.destroy = void 0),
-                  safelyCallDestroy(
-                    deletedFiber,
-                    nearestMountedAncestor,
-                    destroy
-                  )));
-            effect = effect.next;
-          } while (effect !== updateQueue);
+          b: {
+            oldProps = diffProperties(
+              null,
+              oldProps,
+              newProps,
+              renderLanes.canonical.viewConfig.validAttributes
+            );
+            renderLanes.canonical.currentProps = newProps;
+            newProps = renderLanes.node;
+            if (current)
+              newProps =
+                null !== oldProps
+                  ? cloneNodeWithNewChildrenAndProps(newProps, oldProps)
+                  : cloneNodeWithNewChildren(newProps);
+            else if (null !== oldProps)
+              newProps = cloneNodeWithNewProps(newProps, oldProps);
+            else {
+              newProps = renderLanes;
+              break b;
+            }
+            newProps = { node: newProps, canonical: renderLanes.canonical };
+          }
+          newProps === renderLanes
+            ? (workInProgress.stateNode = renderLanes)
+            : ((workInProgress.stateNode = newProps),
+              current
+                ? appendAllChildren(newProps, workInProgress, !1, !1)
+                : (workInProgress.flags |= 4));
+        } else workInProgress.stateNode = renderLanes;
+      } else {
+        if (!newProps) {
+          if (null === workInProgress.stateNode)
+            throw Error(
+              "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
+            );
+          bubbleProperties(workInProgress);
+          return null;
         }
+        oldProps = rootInstanceStackCursor.current;
+        current = nextReactTag;
+        nextReactTag += 2;
+        renderLanes = getViewConfigForType(renderLanes);
+        var updatePayload = diffProperties(
+          null,
+          emptyObject,
+          newProps,
+          renderLanes.validAttributes
+        );
+        oldProps = createNode(
+          current,
+          renderLanes.uiViewClassName,
+          oldProps,
+          updatePayload,
+          workInProgress
+        );
+        updatePayload = ReactNativePrivateInterface.createPublicInstance(
+          current,
+          renderLanes,
+          workInProgress
+        );
+        current = {
+          node: oldProps,
+          canonical: {
+            nativeTag: current,
+            viewConfig: renderLanes,
+            currentProps: newProps,
+            internalInstanceHandle: workInProgress,
+            publicInstance: updatePayload
+          }
+        };
+        appendAllChildren(current, workInProgress, !1, !1);
+        workInProgress.stateNode = current;
       }
-      recursivelyTraverseDeletionEffects(
-        finishedRoot,
-        nearestMountedAncestor,
-        deletedFiber
-      );
-      break;
-    case 1:
+      bubbleProperties(workInProgress);
+      workInProgress.flags &= -16777217;
+      return null;
+    case 6:
+      if (current && null != workInProgress.stateNode)
+        current.memoizedProps !== newProps
+          ? ((workInProgress.stateNode = createTextInstance(
+              newProps,
+              rootInstanceStackCursor.current,
+              contextStackCursor.current,
+              workInProgress
+            )),
+            (workInProgress.flags |= 4))
+          : (workInProgress.stateNode = current.stateNode);
+      else {
+        if ("string" !== typeof newProps && null === workInProgress.stateNode)
+          throw Error(
+            "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
+          );
+        workInProgress.stateNode = createTextInstance(
+          newProps,
+          rootInstanceStackCursor.current,
+          contextStackCursor.current,
+          workInProgress
+        );
+      }
+      bubbleProperties(workInProgress);
+      return null;
+    case 13:
+      newProps = workInProgress.memoizedState;
       if (
-        !offscreenSubtreeWasHidden &&
-        (safelyDetachRef(deletedFiber, nearestMountedAncestor),
-        (updateQueue = deletedFiber.stateNode),
-        "function" === typeof updateQueue.componentWillUnmount)
-      )
-        try {
-          (updateQueue.props = deletedFiber.memoizedProps),
-            (updateQueue.state = deletedFiber.memoizedState),
-            updateQueue.componentWillUnmount();
-        } catch (error) {
-          captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
+        null === current ||
+        (null !== current.memoizedState &&
+          null !== current.memoizedState.dehydrated)
+      ) {
+        if (null !== newProps && null !== newProps.dehydrated) {
+          if (null === current) {
+            throw Error(
+              "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
+            );
+            throw Error(
+              "Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
+            );
+          }
+          0 === (workInProgress.flags & 128) &&
+            (workInProgress.memoizedState = null);
+          workInProgress.flags |= 4;
+          bubbleProperties(workInProgress);
+          oldProps = !1;
+        } else
+          null !== hydrationErrors &&
+            (queueRecoverableErrors(hydrationErrors), (hydrationErrors = null)),
+            (oldProps = !0);
+        if (!oldProps) {
+          if (workInProgress.flags & 256)
+            return popSuspenseHandler(workInProgress), workInProgress;
+          popSuspenseHandler(workInProgress);
+          return null;
         }
-      recursivelyTraverseDeletionEffects(
-        finishedRoot,
-        nearestMountedAncestor,
-        deletedFiber
-      );
-      break;
-    case 21:
-      recursivelyTraverseDeletionEffects(
-        finishedRoot,
-        nearestMountedAncestor,
-        deletedFiber
+      }
+      popSuspenseHandler(workInProgress);
+      if (0 !== (workInProgress.flags & 128))
+        return (workInProgress.lanes = renderLanes), workInProgress;
+      newProps = null !== newProps;
+      newProps !== (null !== current && null !== current.memoizedState) &&
+        newProps &&
+        (workInProgress.child.flags |= 8192);
+      scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
+      bubbleProperties(workInProgress);
+      return null;
+    case 4:
+      return (
+        popHostContainer(),
+        updateHostContainer(current, workInProgress),
+        bubbleProperties(workInProgress),
+        null
       );
-      break;
-    case 22:
-      safelyDetachRef(deletedFiber, nearestMountedAncestor);
-      deletedFiber.mode & 1
-        ? ((offscreenSubtreeWasHidden =
-            (updateQueue = offscreenSubtreeWasHidden) ||
-            null !== deletedFiber.memoizedState),
-          recursivelyTraverseDeletionEffects(
-            finishedRoot,
-            nearestMountedAncestor,
-            deletedFiber
-          ),
-          (offscreenSubtreeWasHidden = updateQueue))
-        : recursivelyTraverseDeletionEffects(
-            finishedRoot,
-            nearestMountedAncestor,
-            deletedFiber
-          );
-      break;
-    default:
-      recursivelyTraverseDeletionEffects(
-        finishedRoot,
-        nearestMountedAncestor,
-        deletedFiber
+    case 10:
+      return (
+        popProvider(workInProgress.type._context),
+        bubbleProperties(workInProgress),
+        null
       );
-  }
-}
-function getRetryCache(finishedWork) {
-  switch (finishedWork.tag) {
-    case 13:
+    case 17:
+      return bubbleProperties(workInProgress), null;
     case 19:
-      var retryCache = finishedWork.stateNode;
-      null === retryCache &&
-        (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
-      return retryCache;
+      pop(suspenseStackCursor);
+      oldProps = workInProgress.memoizedState;
+      if (null === oldProps) return bubbleProperties(workInProgress), null;
+      newProps = 0 !== (workInProgress.flags & 128);
+      updatePayload = oldProps.rendering;
+      if (null === updatePayload)
+        if (newProps) cutOffTailIfNeeded(oldProps, !1);
+        else {
+          if (
+            0 !== workInProgressRootExitStatus ||
+            (null !== current && 0 !== (current.flags & 128))
+          )
+            for (current = workInProgress.child; null !== current; ) {
+              updatePayload = findFirstSuspended(current);
+              if (null !== updatePayload) {
+                workInProgress.flags |= 128;
+                cutOffTailIfNeeded(oldProps, !1);
+                current = updatePayload.updateQueue;
+                workInProgress.updateQueue = current;
+                scheduleRetryEffect(workInProgress, current);
+                workInProgress.subtreeFlags = 0;
+                current = renderLanes;
+                for (newProps = workInProgress.child; null !== newProps; )
+                  resetWorkInProgress(newProps, current),
+                    (newProps = newProps.sibling);
+                push(
+                  suspenseStackCursor,
+                  (suspenseStackCursor.current & 1) | 2
+                );
+                return workInProgress.child;
+              }
+              current = current.sibling;
+            }
+          null !== oldProps.tail &&
+            now() > workInProgressRootRenderTargetTime &&
+            ((workInProgress.flags |= 128),
+            (newProps = !0),
+            cutOffTailIfNeeded(oldProps, !1),
+            (workInProgress.lanes = 4194304));
+        }
+      else {
+        if (!newProps)
+          if (
+            ((current = findFirstSuspended(updatePayload)), null !== current)
+          ) {
+            if (
+              ((workInProgress.flags |= 128),
+              (newProps = !0),
+              (current = current.updateQueue),
+              (workInProgress.updateQueue = current),
+              scheduleRetryEffect(workInProgress, current),
+              cutOffTailIfNeeded(oldProps, !0),
+              null === oldProps.tail &&
+                "hidden" === oldProps.tailMode &&
+                !updatePayload.alternate)
+            )
+              return bubbleProperties(workInProgress), null;
+          } else
+            2 * now() - oldProps.renderingStartTime >
+              workInProgressRootRenderTargetTime &&
+              536870912 !== renderLanes &&
+              ((workInProgress.flags |= 128),
+              (newProps = !0),
+              cutOffTailIfNeeded(oldProps, !1),
+              (workInProgress.lanes = 4194304));
+        oldProps.isBackwards
+          ? ((updatePayload.sibling = workInProgress.child),
+            (workInProgress.child = updatePayload))
+          : ((current = oldProps.last),
+            null !== current
+              ? (current.sibling = updatePayload)
+              : (workInProgress.child = updatePayload),
+            (oldProps.last = updatePayload));
+      }
+      if (null !== oldProps.tail)
+        return (
+          (workInProgress = oldProps.tail),
+          (oldProps.rendering = workInProgress),
+          (oldProps.tail = workInProgress.sibling),
+          (oldProps.renderingStartTime = now()),
+          (workInProgress.sibling = null),
+          (current = suspenseStackCursor.current),
+          push(suspenseStackCursor, newProps ? (current & 1) | 2 : current & 1),
+          workInProgress
+        );
+      bubbleProperties(workInProgress);
+      return null;
     case 22:
+    case 23:
       return (
-        (finishedWork = finishedWork.stateNode),
-        (retryCache = finishedWork._retryCache),
-        null === retryCache &&
-          (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),
-        retryCache
-      );
-    default:
-      throw Error(
-        "Unexpected Suspense handler tag (" +
-          finishedWork.tag +
-          "). This is a bug in React."
+        popSuspenseHandler(workInProgress),
+        popHiddenContext(),
+        (newProps = null !== workInProgress.memoizedState),
+        null !== current
+          ? (null !== current.memoizedState) !== newProps &&
+            (workInProgress.flags |= 8192)
+          : newProps && (workInProgress.flags |= 8192),
+        newProps && 0 !== (workInProgress.mode & 1)
+          ? 0 !== (renderLanes & 536870912) &&
+            0 === (workInProgress.flags & 128) &&
+            (bubbleProperties(workInProgress),
+            workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192))
+          : bubbleProperties(workInProgress),
+        (current = workInProgress.updateQueue),
+        null !== current &&
+          scheduleRetryEffect(workInProgress, current.retryQueue),
+        null
       );
+    case 24:
+      return null;
+    case 25:
+      return null;
   }
+  throw Error(
+    "Unknown unit of work tag (" +
+      workInProgress.tag +
+      "). This error is likely caused by a bug in React. Please file an issue."
+  );
 }
-function attachSuspenseRetryListeners(finishedWork, wakeables) {
-  var retryCache = getRetryCache(finishedWork);
-  wakeables.forEach(function (wakeable) {
-    var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
-    retryCache.has(wakeable) ||
-      (retryCache.add(wakeable), wakeable.then(retry, retry));
-  });
-}
-function recursivelyTraverseMutationEffects(root, parentFiber) {
-  var deletions = parentFiber.deletions;
-  if (null !== deletions)
-    for (var i = 0; i < deletions.length; i++) {
-      var childToDelete = deletions[i];
-      try {
-        commitDeletionEffectsOnFiber(root, parentFiber, childToDelete);
-        var alternate = childToDelete.alternate;
-        null !== alternate && (alternate.return = null);
-        childToDelete.return = null;
-      } catch (error) {
-        captureCommitPhaseError(childToDelete, parentFiber, error);
-      }
-    }
-  if (parentFiber.subtreeFlags & 12854)
-    for (parentFiber = parentFiber.child; null !== parentFiber; )
-      commitMutationEffectsOnFiber(parentFiber, root),
-        (parentFiber = parentFiber.sibling);
-}
-function commitMutationEffectsOnFiber(finishedWork, root) {
-  var current = finishedWork.alternate,
-    flags = finishedWork.flags;
-  switch (finishedWork.tag) {
-    case 0:
-    case 11:
-    case 14:
-    case 15:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      if (flags & 4) {
-        try {
-          commitHookEffectListUnmount(3, finishedWork, finishedWork.return),
-            commitHookEffectListMount(3, finishedWork);
-        } catch (error) {
-          captureCommitPhaseError(finishedWork, finishedWork.return, error);
-        }
-        try {
-          commitHookEffectListUnmount(5, finishedWork, finishedWork.return);
-        } catch (error$81) {
-          captureCommitPhaseError(finishedWork, finishedWork.return, error$81);
-        }
-      }
-      break;
+function unwindWork(current, workInProgress) {
+  switch (workInProgress.tag) {
     case 1:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      flags & 512 &&
-        null !== current &&
-        safelyDetachRef(current, current.return);
-      flags & 64 &&
-        offscreenSubtreeIsHidden &&
-        ((finishedWork = finishedWork.updateQueue),
-        null !== finishedWork &&
-          ((flags = finishedWork.callbacks),
-          null !== flags &&
-            ((current = finishedWork.shared.hiddenCallbacks),
-            (finishedWork.shared.hiddenCallbacks =
-              null === current ? flags : current.concat(flags)))));
-      break;
+      return (
+        (current = workInProgress.flags),
+        current & 65536
+          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
+          : null
+      );
+    case 3:
+      return (
+        popHostContainer(),
+        (current = workInProgress.flags),
+        0 !== (current & 65536) && 0 === (current & 128)
+          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
+          : null
+      );
     case 26:
     case 27:
     case 5:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      flags & 512 &&
+      return popHostContext(workInProgress), null;
+    case 13:
+      popSuspenseHandler(workInProgress);
+      current = workInProgress.memoizedState;
+      if (
         null !== current &&
-        safelyDetachRef(current, current.return);
-      break;
-    case 6:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      break;
+        null !== current.dehydrated &&
+        null === workInProgress.alternate
+      )
+        throw Error(
+          "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
+        );
+      current = workInProgress.flags;
+      return current & 65536
+        ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
+        : null;
+    case 19:
+      return pop(suspenseStackCursor), null;
+    case 4:
+      return popHostContainer(), null;
+    case 10:
+      return popProvider(workInProgress.type._context), null;
+    case 22:
+    case 23:
+      return (
+        popSuspenseHandler(workInProgress),
+        popHiddenContext(),
+        (current = workInProgress.flags),
+        current & 65536
+          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
+          : null
+      );
+    case 24:
+      return null;
+    case 25:
+      return null;
+    default:
+      return null;
+  }
+}
+function unwindInterruptedWork(current, interruptedWork) {
+  switch (interruptedWork.tag) {
     case 3:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
+      popHostContainer();
+      break;
+    case 26:
+    case 27:
+    case 5:
+      popHostContext(interruptedWork);
       break;
     case 4:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
+      popHostContainer();
       break;
     case 13:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      finishedWork.child.flags & 8192 &&
-        ((current = null !== current && null !== current.memoizedState),
-        null === finishedWork.memoizedState ||
-          current ||
-          (globalMostRecentFallbackTime = now()));
-      flags & 4 &&
-        ((flags = finishedWork.updateQueue),
-        null !== flags &&
-          ((finishedWork.updateQueue = null),
-          attachSuspenseRetryListeners(finishedWork, flags)));
-      break;
-    case 22:
-      flags & 512 &&
-        null !== current &&
-        safelyDetachRef(current, current.return);
-      var isHidden = null !== finishedWork.memoizedState,
-        wasHidden = null !== current && null !== current.memoizedState;
-      if (finishedWork.mode & 1) {
-        var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
-          prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
-        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || isHidden;
-        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
-        recursivelyTraverseMutationEffects(root, finishedWork);
-        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
-        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
-      } else recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      root = finishedWork.stateNode;
-      root._current = finishedWork;
-      root._visibility &= -3;
-      root._visibility |= root._pendingVisibility & 2;
-      flags & 8192 &&
-        ((root._visibility = isHidden
-          ? root._visibility & -2
-          : root._visibility | 1),
-        isHidden &&
-          ((isHidden = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden),
-          null === current ||
-            wasHidden ||
-            isHidden ||
-            (0 !== (finishedWork.mode & 1) &&
-              recursivelyTraverseDisappearLayoutEffects(finishedWork))));
-      flags & 4 &&
-        ((flags = finishedWork.updateQueue),
-        null !== flags &&
-          ((current = flags.retryQueue),
-          null !== current &&
-            ((flags.retryQueue = null),
-            attachSuspenseRetryListeners(finishedWork, current))));
+      popSuspenseHandler(interruptedWork);
       break;
     case 19:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      flags & 4 &&
-        ((flags = finishedWork.updateQueue),
-        null !== flags &&
-          ((finishedWork.updateQueue = null),
-          attachSuspenseRetryListeners(finishedWork, flags)));
+      pop(suspenseStackCursor);
       break;
-    case 21:
+    case 10:
+      popProvider(interruptedWork.type._context);
       break;
-    default:
-      recursivelyTraverseMutationEffects(root, finishedWork),
-        commitReconciliationEffects(finishedWork);
+    case 22:
+    case 23:
+      popSuspenseHandler(interruptedWork), popHiddenContext();
   }
 }
-function commitReconciliationEffects(finishedWork) {
-  var flags = finishedWork.flags;
-  flags & 2 && (finishedWork.flags &= -3);
-  flags & 4096 && (finishedWork.flags &= -4097);
-}
-function recursivelyTraverseLayoutEffects(root, parentFiber) {
-  if (parentFiber.subtreeFlags & 8772)
-    for (parentFiber = parentFiber.child; null !== parentFiber; )
-      commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),
-        (parentFiber = parentFiber.sibling);
-}
-function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
-  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
-    var finishedWork = parentFiber;
-    switch (finishedWork.tag) {
-      case 0:
-      case 11:
-      case 14:
-      case 15:
-        commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
-        recursivelyTraverseDisappearLayoutEffects(finishedWork);
-        break;
-      case 1:
-        safelyDetachRef(finishedWork, finishedWork.return);
-        var instance = finishedWork.stateNode;
-        if ("function" === typeof instance.componentWillUnmount) {
-          var current = finishedWork,
-            nearestMountedAncestor = finishedWork.return;
-          try {
-            var current$jscomp$0 = current;
-            instance.props = current$jscomp$0.memoizedProps;
-            instance.state = current$jscomp$0.memoizedState;
-            instance.componentWillUnmount();
-          } catch (error) {
-            captureCommitPhaseError(current, nearestMountedAncestor, error);
-          }
-        }
-        recursivelyTraverseDisappearLayoutEffects(finishedWork);
-        break;
-      case 26:
-      case 27:
-      case 5:
-        safelyDetachRef(finishedWork, finishedWork.return);
-        recursivelyTraverseDisappearLayoutEffects(finishedWork);
-        break;
-      case 22:
-        safelyDetachRef(finishedWork, finishedWork.return);
-        null === finishedWork.memoizedState &&
-          recursivelyTraverseDisappearLayoutEffects(finishedWork);
-        break;
-      default:
-        recursivelyTraverseDisappearLayoutEffects(finishedWork);
+var offscreenSubtreeIsHidden = !1,
+  offscreenSubtreeWasHidden = !1,
+  PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
+  nextEffect = null;
+function safelyAttachRef(current, nearestMountedAncestor) {
+  try {
+    var ref = current.ref;
+    if (null !== ref) {
+      var instance = current.stateNode;
+      switch (current.tag) {
+        case 26:
+        case 27:
+        case 5:
+          var instanceToUse = getPublicInstance(instance);
+          break;
+        default:
+          instanceToUse = instance;
+      }
+      "function" === typeof ref
+        ? (current.refCleanup = ref(instanceToUse))
+        : (ref.current = instanceToUse);
     }
-    parentFiber = parentFiber.sibling;
+  } catch (error) {
+    captureCommitPhaseError(current, nearestMountedAncestor, error);
   }
 }
-function recursivelyTraverseReappearLayoutEffects(
-  finishedRoot$jscomp$0,
-  parentFiber,
-  includeWorkInProgressEffects
-) {
-  includeWorkInProgressEffects =
-    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
-  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
-    var current = parentFiber.alternate,
-      finishedRoot = finishedRoot$jscomp$0,
-      finishedWork = parentFiber,
-      flags = finishedWork.flags;
-    switch (finishedWork.tag) {
-      case 0:
-      case 11:
-      case 15:
-        recursivelyTraverseReappearLayoutEffects(
-          finishedRoot,
-          finishedWork,
-          includeWorkInProgressEffects
-        );
-        commitHookLayoutEffects(finishedWork, 4);
-        break;
-      case 1:
-        recursivelyTraverseReappearLayoutEffects(
-          finishedRoot,
-          finishedWork,
-          includeWorkInProgressEffects
-        );
-        finishedRoot = finishedWork.stateNode;
-        if ("function" === typeof finishedRoot.componentDidMount)
-          try {
-            finishedRoot.componentDidMount();
-          } catch (error) {
-            captureCommitPhaseError(finishedWork, finishedWork.return, error);
-          }
-        current = finishedWork.updateQueue;
-        if (null !== current) {
-          var hiddenCallbacks = current.shared.hiddenCallbacks;
-          if (null !== hiddenCallbacks)
-            for (
-              current.shared.hiddenCallbacks = null, current = 0;
-              current < hiddenCallbacks.length;
-              current++
-            )
-              callCallback(hiddenCallbacks[current], finishedRoot);
-        }
-        includeWorkInProgressEffects &&
-          flags & 64 &&
-          commitClassCallbacks(finishedWork);
-        safelyAttachRef(finishedWork, finishedWork.return);
-        break;
-      case 26:
-      case 27:
-      case 5:
-        recursivelyTraverseReappearLayoutEffects(
-          finishedRoot,
-          finishedWork,
-          includeWorkInProgressEffects
-        );
-        includeWorkInProgressEffects &&
-          null === current &&
-          flags & 4 &&
-          commitHostComponentMount(finishedWork);
-        safelyAttachRef(finishedWork, finishedWork.return);
-        break;
-      case 12:
-        recursivelyTraverseReappearLayoutEffects(
-          finishedRoot,
-          finishedWork,
-          includeWorkInProgressEffects
-        );
-        break;
-      case 13:
-        recursivelyTraverseReappearLayoutEffects(
-          finishedRoot,
-          finishedWork,
-          includeWorkInProgressEffects
-        );
-        break;
-      case 22:
-        null === finishedWork.memoizedState &&
-          recursivelyTraverseReappearLayoutEffects(
-            finishedRoot,
-            finishedWork,
-            includeWorkInProgressEffects
-          );
-        safelyAttachRef(finishedWork, finishedWork.return);
-        break;
-      default:
-        recursivelyTraverseReappearLayoutEffects(
-          finishedRoot,
-          finishedWork,
-          includeWorkInProgressEffects
-        );
-    }
-    parentFiber = parentFiber.sibling;
-  }
+function safelyDetachRef(current, nearestMountedAncestor) {
+  var ref = current.ref,
+    refCleanup = current.refCleanup;
+  if (null !== ref)
+    if ("function" === typeof refCleanup)
+      try {
+        refCleanup();
+      } catch (error) {
+        captureCommitPhaseError(current, nearestMountedAncestor, error);
+      } finally {
+        (current.refCleanup = null),
+          (current = current.alternate),
+          null != current && (current.refCleanup = null);
+      }
+    else if ("function" === typeof ref)
+      try {
+        ref(null);
+      } catch (error$76) {
+        captureCommitPhaseError(current, nearestMountedAncestor, error$76);
+      }
+    else ref.current = null;
 }
-function commitHookPassiveMountEffects(finishedWork, hookFlags) {
+function safelyCallDestroy(current, nearestMountedAncestor, destroy) {
   try {
-    commitHookEffectListMount(hookFlags, finishedWork);
+    destroy();
   } catch (error) {
-    captureCommitPhaseError(finishedWork, finishedWork.return, error);
+    captureCommitPhaseError(current, nearestMountedAncestor, error);
   }
 }
-function recursivelyTraversePassiveMountEffects(root, parentFiber) {
-  if (parentFiber.subtreeFlags & 10256)
-    for (parentFiber = parentFiber.child; null !== parentFiber; )
-      commitPassiveMountOnFiber(root, parentFiber),
-        (parentFiber = parentFiber.sibling);
+var shouldFireAfterActiveInstanceBlur = !1;
+function commitBeforeMutationEffects(root, firstChild) {
+  for (nextEffect = firstChild; null !== nextEffect; )
+    if (
+      ((root = nextEffect),
+      (firstChild = root.child),
+      0 !== (root.subtreeFlags & 1028) && null !== firstChild)
+    )
+      (firstChild.return = root), (nextEffect = firstChild);
+    else
+      for (; null !== nextEffect; ) {
+        root = nextEffect;
+        try {
+          var current = root.alternate,
+            flags = root.flags;
+          switch (root.tag) {
+            case 0:
+              break;
+            case 11:
+            case 15:
+              break;
+            case 1:
+              if (0 !== (flags & 1024) && null !== current) {
+                var prevProps = current.memoizedProps,
+                  prevState = current.memoizedState,
+                  instance = root.stateNode,
+                  snapshot = instance.getSnapshotBeforeUpdate(
+                    root.elementType === root.type
+                      ? prevProps
+                      : resolveDefaultProps(root.type, prevProps),
+                    prevState
+                  );
+                instance.__reactInternalSnapshotBeforeUpdate = snapshot;
+              }
+              break;
+            case 3:
+              break;
+            case 5:
+            case 26:
+            case 27:
+            case 6:
+            case 4:
+            case 17:
+              break;
+            default:
+              if (0 !== (flags & 1024))
+                throw Error(
+                  "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
+                );
+          }
+        } catch (error) {
+          captureCommitPhaseError(root, root.return, error);
+        }
+        firstChild = root.sibling;
+        if (null !== firstChild) {
+          firstChild.return = root.return;
+          nextEffect = firstChild;
+          break;
+        }
+        nextEffect = root.return;
+      }
+  current = shouldFireAfterActiveInstanceBlur;
+  shouldFireAfterActiveInstanceBlur = !1;
+  return current;
 }
-function commitPassiveMountOnFiber(finishedRoot, finishedWork) {
+function commitHookEffectListUnmount(
+  flags,
+  finishedWork,
+  nearestMountedAncestor
+) {
+  var updateQueue = finishedWork.updateQueue;
+  updateQueue = null !== updateQueue ? updateQueue.lastEffect : null;
+  if (null !== updateQueue) {
+    var effect = (updateQueue = updateQueue.next);
+    do {
+      if ((effect.tag & flags) === flags) {
+        var inst = effect.inst,
+          destroy = inst.destroy;
+        void 0 !== destroy &&
+          ((inst.destroy = void 0),
+          safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy));
+      }
+      effect = effect.next;
+    } while (effect !== updateQueue);
+  }
+}
+function commitHookEffectListMount(flags, finishedWork) {
+  finishedWork = finishedWork.updateQueue;
+  finishedWork = null !== finishedWork ? finishedWork.lastEffect : null;
+  if (null !== finishedWork) {
+    var effect = (finishedWork = finishedWork.next);
+    do {
+      if ((effect.tag & flags) === flags) {
+        var create$77 = effect.create,
+          inst = effect.inst;
+        create$77 = create$77();
+        inst.destroy = create$77;
+      }
+      effect = effect.next;
+    } while (effect !== finishedWork);
+  }
+}
+function commitHookLayoutEffects(finishedWork, hookFlags) {
+  try {
+    commitHookEffectListMount(hookFlags, finishedWork);
+  } catch (error) {
+    captureCommitPhaseError(finishedWork, finishedWork.return, error);
+  }
+}
+function commitClassCallbacks(finishedWork) {
+  var updateQueue = finishedWork.updateQueue;
+  if (null !== updateQueue) {
+    var instance = finishedWork.stateNode;
+    try {
+      commitCallbacks(updateQueue, instance);
+    } catch (error) {
+      captureCommitPhaseError(finishedWork, finishedWork.return, error);
+    }
+  }
+}
+function commitHostComponentMount(finishedWork) {
+  try {
+    throw Error(
+      "The current renderer does not support mutation. This error is likely caused by a bug in React. Please file an issue."
+    );
+  } catch (error) {
+    captureCommitPhaseError(finishedWork, finishedWork.return, error);
+  }
+}
+function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
   var flags = finishedWork.flags;
   switch (finishedWork.tag) {
     case 0:
     case 11:
     case 15:
-      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
-      flags & 2048 && commitHookPassiveMountEffects(finishedWork, 9);
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      flags & 4 && commitHookLayoutEffects(finishedWork, 5);
+      break;
+    case 1:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      if (flags & 4)
+        if (((finishedRoot = finishedWork.stateNode), null === current))
+          try {
+            finishedRoot.componentDidMount();
+          } catch (error) {
+            captureCommitPhaseError(finishedWork, finishedWork.return, error);
+          }
+        else {
+          var prevProps =
+            finishedWork.elementType === finishedWork.type
+              ? current.memoizedProps
+              : resolveDefaultProps(finishedWork.type, current.memoizedProps);
+          current = current.memoizedState;
+          try {
+            finishedRoot.componentDidUpdate(
+              prevProps,
+              current,
+              finishedRoot.__reactInternalSnapshotBeforeUpdate
+            );
+          } catch (error$78) {
+            captureCommitPhaseError(
+              finishedWork,
+              finishedWork.return,
+              error$78
+            );
+          }
+        }
+      flags & 64 && commitClassCallbacks(finishedWork);
+      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
       break;
     case 3:
-      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      if (flags & 64 && ((flags = finishedWork.updateQueue), null !== flags)) {
+        finishedRoot = null;
+        if (null !== finishedWork.child)
+          switch (finishedWork.child.tag) {
+            case 27:
+            case 5:
+              finishedRoot = getPublicInstance(finishedWork.child.stateNode);
+              break;
+            case 1:
+              finishedRoot = finishedWork.child.stateNode;
+          }
+        try {
+          commitCallbacks(flags, finishedRoot);
+        } catch (error) {
+          captureCommitPhaseError(finishedWork, finishedWork.return, error);
+        }
+      }
       break;
-    case 23:
+    case 26:
+    case 27:
+    case 5:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      null === current && flags & 4 && commitHostComponentMount(finishedWork);
+      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
       break;
-    case 22:
-      flags = finishedWork.stateNode;
-      null !== finishedWork.memoizedState
-        ? flags._visibility & 4
-          ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork)
-          : finishedWork.mode & 1 ||
-            ((flags._visibility |= 4),
-            recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork))
-        : flags._visibility & 4
-        ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork)
-        : ((flags._visibility |= 4),
-          recursivelyTraverseReconnectPassiveEffects(
-            finishedRoot,
-            finishedWork
-          ));
+    case 12:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
       break;
-    case 24:
-      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
+    case 13:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      break;
+    case 22:
+      if (0 !== (finishedWork.mode & 1)) {
+        if (
+          ((prevProps =
+            null !== finishedWork.memoizedState || offscreenSubtreeIsHidden),
+          !prevProps)
+        ) {
+          current =
+            (null !== current && null !== current.memoizedState) ||
+            offscreenSubtreeWasHidden;
+          var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
+            prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
+          offscreenSubtreeIsHidden = prevProps;
+          (offscreenSubtreeWasHidden = current) &&
+          !prevOffscreenSubtreeWasHidden
+            ? recursivelyTraverseReappearLayoutEffects(
+                finishedRoot,
+                finishedWork,
+                0 !== (finishedWork.subtreeFlags & 8772)
+              )
+            : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
+          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
+        }
+      } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      flags & 512 &&
+        ("manual" === finishedWork.memoizedProps.mode
+          ? safelyAttachRef(finishedWork, finishedWork.return)
+          : safelyDetachRef(finishedWork, finishedWork.return));
       break;
     default:
-      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
   }
 }
-function recursivelyTraverseReconnectPassiveEffects(
-  finishedRoot$jscomp$0,
-  parentFiber
-) {
-  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
-    var finishedRoot = finishedRoot$jscomp$0,
-      finishedWork = parentFiber;
-    switch (finishedWork.tag) {
-      case 0:
-      case 11:
-      case 15:
-        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork);
-        commitHookPassiveMountEffects(finishedWork, 8);
-        break;
-      case 23:
-        break;
-      case 22:
-        var instance = finishedWork.stateNode;
-        null !== finishedWork.memoizedState
-          ? instance._visibility & 4
-            ? recursivelyTraverseReconnectPassiveEffects(
-                finishedRoot,
-                finishedWork
-              )
-            : finishedWork.mode & 1 ||
-              ((instance._visibility |= 4),
-              recursivelyTraverseReconnectPassiveEffects(
-                finishedRoot,
-                finishedWork
-              ))
-          : ((instance._visibility |= 4),
-            recursivelyTraverseReconnectPassiveEffects(
-              finishedRoot,
-              finishedWork
-            ));
-        break;
-      case 24:
-        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork);
-        break;
-      default:
-        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork);
-    }
-    parentFiber = parentFiber.sibling;
-  }
+function detachFiberAfterEffects(fiber) {
+  var alternate = fiber.alternate;
+  null !== alternate &&
+    ((fiber.alternate = null), detachFiberAfterEffects(alternate));
+  fiber.child = null;
+  fiber.deletions = null;
+  fiber.sibling = null;
+  fiber.stateNode = null;
+  fiber.return = null;
+  fiber.dependencies = null;
+  fiber.memoizedProps = null;
+  fiber.memoizedState = null;
+  fiber.pendingProps = null;
+  fiber.stateNode = null;
+  fiber.updateQueue = null;
 }
-var suspenseyCommitFlag = 8192;
-function recursivelyAccumulateSuspenseyCommit(parentFiber) {
-  if (parentFiber.subtreeFlags & suspenseyCommitFlag)
-    for (parentFiber = parentFiber.child; null !== parentFiber; )
-      accumulateSuspenseyCommitOnFiber(parentFiber),
-        (parentFiber = parentFiber.sibling);
+function recursivelyTraverseDeletionEffects(
+  finishedRoot,
+  nearestMountedAncestor,
+  parent
+) {
+  for (parent = parent.child; null !== parent; )
+    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent),
+      (parent = parent.sibling);
 }
-function accumulateSuspenseyCommitOnFiber(fiber) {
-  switch (fiber.tag) {
+function commitDeletionEffectsOnFiber(
+  finishedRoot,
+  nearestMountedAncestor,
+  deletedFiber
+) {
+  if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
+    try {
+      injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
+    } catch (err) {}
+  switch (deletedFiber.tag) {
     case 26:
-      recursivelyAccumulateSuspenseyCommit(fiber);
-      if (fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState)
-        throw Error(
-          "The current renderer does not support Resources. This error is likely caused by a bug in React. Please file an issue."
-        );
-      break;
+    case 27:
     case 5:
-      recursivelyAccumulateSuspenseyCommit(fiber);
+      offscreenSubtreeWasHidden ||
+        safelyDetachRef(deletedFiber, nearestMountedAncestor);
+    case 6:
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
       break;
-    case 3:
-    case 4:
-      recursivelyAccumulateSuspenseyCommit(fiber);
+    case 18:
       break;
-    case 22:
-      if (null === fiber.memoizedState) {
-        var current = fiber.alternate;
-        null !== current && null !== current.memoizedState
-          ? ((current = suspenseyCommitFlag),
-            (suspenseyCommitFlag = 16777216),
-            recursivelyAccumulateSuspenseyCommit(fiber),
-            (suspenseyCommitFlag = current))
-          : recursivelyAccumulateSuspenseyCommit(fiber);
-      }
+    case 4:
+      createChildNodeSet();
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
       break;
-    default:
-      recursivelyAccumulateSuspenseyCommit(fiber);
-  }
-}
-function detachAlternateSiblings(parentFiber) {
-  var previousFiber = parentFiber.alternate;
-  if (
-    null !== previousFiber &&
-    ((parentFiber = previousFiber.child), null !== parentFiber)
-  ) {
-    previousFiber.child = null;
-    do
-      (previousFiber = parentFiber.sibling),
-        (parentFiber.sibling = null),
-        (parentFiber = previousFiber);
-    while (null !== parentFiber);
-  }
-}
-function recursivelyTraversePassiveUnmountEffects(parentFiber) {
-  var deletions = parentFiber.deletions;
-  if (0 !== (parentFiber.flags & 16)) {
-    if (null !== deletions)
-      for (var i = 0; i < deletions.length; i++) {
-        var childToDelete = deletions[i];
-        nextEffect = childToDelete;
-        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
-          childToDelete,
-          parentFiber
-        );
-      }
-    detachAlternateSiblings(parentFiber);
-  }
-  if (parentFiber.subtreeFlags & 10256)
-    for (parentFiber = parentFiber.child; null !== parentFiber; )
-      commitPassiveUnmountOnFiber(parentFiber),
-        (parentFiber = parentFiber.sibling);
-}
-function commitPassiveUnmountOnFiber(finishedWork) {
-  switch (finishedWork.tag) {
     case 0:
     case 11:
+    case 14:
     case 15:
-      recursivelyTraversePassiveUnmountEffects(finishedWork);
-      finishedWork.flags & 2048 &&
-        commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
+      if (!offscreenSubtreeWasHidden) {
+        var updateQueue = deletedFiber.updateQueue;
+        if (
+          null !== updateQueue &&
+          ((updateQueue = updateQueue.lastEffect), null !== updateQueue)
+        ) {
+          var effect = (updateQueue = updateQueue.next);
+          do {
+            var tag = effect.tag,
+              inst = effect.inst,
+              destroy = inst.destroy;
+            void 0 !== destroy &&
+              (0 !== (tag & 2)
+                ? ((inst.destroy = void 0),
+                  safelyCallDestroy(
+                    deletedFiber,
+                    nearestMountedAncestor,
+                    destroy
+                  ))
+                : 0 !== (tag & 4) &&
+                  ((inst.destroy = void 0),
+                  safelyCallDestroy(
+                    deletedFiber,
+                    nearestMountedAncestor,
+                    destroy
+                  )));
+            effect = effect.next;
+          } while (effect !== updateQueue);
+        }
+      }
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
+      break;
+    case 1:
+      if (
+        !offscreenSubtreeWasHidden &&
+        (safelyDetachRef(deletedFiber, nearestMountedAncestor),
+        (updateQueue = deletedFiber.stateNode),
+        "function" === typeof updateQueue.componentWillUnmount)
+      )
+        try {
+          (updateQueue.props = deletedFiber.memoizedProps),
+            (updateQueue.state = deletedFiber.memoizedState),
+            updateQueue.componentWillUnmount();
+        } catch (error) {
+          captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
+        }
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
+      break;
+    case 21:
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
       break;
     case 22:
-      var instance = finishedWork.stateNode;
-      null !== finishedWork.memoizedState &&
-      instance._visibility & 4 &&
-      (null === finishedWork.return || 13 !== finishedWork.return.tag)
-        ? ((instance._visibility &= -5),
-          recursivelyTraverseDisconnectPassiveEffects(finishedWork))
-        : recursivelyTraversePassiveUnmountEffects(finishedWork);
+      safelyDetachRef(deletedFiber, nearestMountedAncestor);
+      deletedFiber.mode & 1
+        ? ((offscreenSubtreeWasHidden =
+            (updateQueue = offscreenSubtreeWasHidden) ||
+            null !== deletedFiber.memoizedState),
+          recursivelyTraverseDeletionEffects(
+            finishedRoot,
+            nearestMountedAncestor,
+            deletedFiber
+          ),
+          (offscreenSubtreeWasHidden = updateQueue))
+        : recursivelyTraverseDeletionEffects(
+            finishedRoot,
+            nearestMountedAncestor,
+            deletedFiber
+          );
       break;
     default:
-      recursivelyTraversePassiveUnmountEffects(finishedWork);
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
   }
 }
-function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
-  var deletions = parentFiber.deletions;
-  if (0 !== (parentFiber.flags & 16)) {
-    if (null !== deletions)
-      for (var i = 0; i < deletions.length; i++) {
-        var childToDelete = deletions[i];
-        nextEffect = childToDelete;
-        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
-          childToDelete,
-          parentFiber
-        );
-      }
-    detachAlternateSiblings(parentFiber);
-  }
-  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
-    deletions = parentFiber;
-    switch (deletions.tag) {
+function getRetryCache(finishedWork) {
+  switch (finishedWork.tag) {
+    case 13:
+    case 19:
+      var retryCache = finishedWork.stateNode;
+      null === retryCache &&
+        (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
+      return retryCache;
+    case 22:
+      return (
+        (finishedWork = finishedWork.stateNode),
+        (retryCache = finishedWork._retryCache),
+        null === retryCache &&
+          (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),
+        retryCache
+      );
+    default:
+      throw Error(
+        "Unexpected Suspense handler tag (" +
+          finishedWork.tag +
+          "). This is a bug in React."
+      );
+  }
+}
+function attachSuspenseRetryListeners(finishedWork, wakeables) {
+  var retryCache = getRetryCache(finishedWork);
+  wakeables.forEach(function (wakeable) {
+    var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
+    retryCache.has(wakeable) ||
+      (retryCache.add(wakeable), wakeable.then(retry, retry));
+  });
+}
+function recursivelyTraverseMutationEffects(root, parentFiber) {
+  var deletions = parentFiber.deletions;
+  if (null !== deletions)
+    for (var i = 0; i < deletions.length; i++) {
+      var childToDelete = deletions[i];
+      try {
+        commitDeletionEffectsOnFiber(root, parentFiber, childToDelete);
+        var alternate = childToDelete.alternate;
+        null !== alternate && (alternate.return = null);
+        childToDelete.return = null;
+      } catch (error) {
+        captureCommitPhaseError(childToDelete, parentFiber, error);
+      }
+    }
+  if (parentFiber.subtreeFlags & 12854)
+    for (parentFiber = parentFiber.child; null !== parentFiber; )
+      commitMutationEffectsOnFiber(parentFiber, root),
+        (parentFiber = parentFiber.sibling);
+}
+function commitMutationEffectsOnFiber(finishedWork, root) {
+  var current = finishedWork.alternate,
+    flags = finishedWork.flags;
+  switch (finishedWork.tag) {
+    case 0:
+    case 11:
+    case 14:
+    case 15:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      if (flags & 4) {
+        try {
+          commitHookEffectListUnmount(3, finishedWork, finishedWork.return),
+            commitHookEffectListMount(3, finishedWork);
+        } catch (error) {
+          captureCommitPhaseError(finishedWork, finishedWork.return, error);
+        }
+        try {
+          commitHookEffectListUnmount(5, finishedWork, finishedWork.return);
+        } catch (error$80) {
+          captureCommitPhaseError(finishedWork, finishedWork.return, error$80);
+        }
+      }
+      break;
+    case 1:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      flags & 512 &&
+        null !== current &&
+        safelyDetachRef(current, current.return);
+      flags & 64 &&
+        offscreenSubtreeIsHidden &&
+        ((finishedWork = finishedWork.updateQueue),
+        null !== finishedWork &&
+          ((flags = finishedWork.callbacks),
+          null !== flags &&
+            ((current = finishedWork.shared.hiddenCallbacks),
+            (finishedWork.shared.hiddenCallbacks =
+              null === current ? flags : current.concat(flags)))));
+      break;
+    case 26:
+    case 27:
+    case 5:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      flags & 512 &&
+        null !== current &&
+        safelyDetachRef(current, current.return);
+      break;
+    case 6:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      break;
+    case 3:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      break;
+    case 4:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      break;
+    case 13:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      finishedWork.child.flags & 8192 &&
+        ((current = null !== current && null !== current.memoizedState),
+        null === finishedWork.memoizedState ||
+          current ||
+          (globalMostRecentFallbackTime = now()));
+      flags & 4 &&
+        ((flags = finishedWork.updateQueue),
+        null !== flags &&
+          ((finishedWork.updateQueue = null),
+          attachSuspenseRetryListeners(finishedWork, flags)));
+      break;
+    case 22:
+      flags & 512 &&
+        null !== current &&
+        safelyDetachRef(current, current.return);
+      var isHidden = null !== finishedWork.memoizedState,
+        wasHidden = null !== current && null !== current.memoizedState;
+      if (finishedWork.mode & 1) {
+        var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
+          prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
+        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || isHidden;
+        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
+        recursivelyTraverseMutationEffects(root, finishedWork);
+        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
+        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
+      } else recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      root = finishedWork.stateNode;
+      root._current = finishedWork;
+      root._visibility &= -3;
+      root._visibility |= root._pendingVisibility & 2;
+      flags & 8192 &&
+        ((root._visibility = isHidden
+          ? root._visibility & -2
+          : root._visibility | 1),
+        isHidden &&
+          ((isHidden = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden),
+          null === current ||
+            wasHidden ||
+            isHidden ||
+            (0 !== (finishedWork.mode & 1) &&
+              recursivelyTraverseDisappearLayoutEffects(finishedWork))));
+      flags & 4 &&
+        ((flags = finishedWork.updateQueue),
+        null !== flags &&
+          ((current = flags.retryQueue),
+          null !== current &&
+            ((flags.retryQueue = null),
+            attachSuspenseRetryListeners(finishedWork, current))));
+      break;
+    case 19:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      flags & 4 &&
+        ((flags = finishedWork.updateQueue),
+        null !== flags &&
+          ((finishedWork.updateQueue = null),
+          attachSuspenseRetryListeners(finishedWork, flags)));
+      break;
+    case 21:
+      break;
+    default:
+      recursivelyTraverseMutationEffects(root, finishedWork),
+        commitReconciliationEffects(finishedWork);
+  }
+}
+function commitReconciliationEffects(finishedWork) {
+  var flags = finishedWork.flags;
+  flags & 2 && (finishedWork.flags &= -3);
+  flags & 4096 && (finishedWork.flags &= -4097);
+}
+function recursivelyTraverseLayoutEffects(root, parentFiber) {
+  if (parentFiber.subtreeFlags & 8772)
+    for (parentFiber = parentFiber.child; null !== parentFiber; )
+      commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),
+        (parentFiber = parentFiber.sibling);
+}
+function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
+  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+    var finishedWork = parentFiber;
+    switch (finishedWork.tag) {
       case 0:
       case 11:
+      case 14:
       case 15:
-        commitHookEffectListUnmount(8, deletions, deletions.return);
-        recursivelyTraverseDisconnectPassiveEffects(deletions);
+        commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
+        recursivelyTraverseDisappearLayoutEffects(finishedWork);
+        break;
+      case 1:
+        safelyDetachRef(finishedWork, finishedWork.return);
+        var instance = finishedWork.stateNode;
+        if ("function" === typeof instance.componentWillUnmount) {
+          var current = finishedWork,
+            nearestMountedAncestor = finishedWork.return;
+          try {
+            var current$jscomp$0 = current;
+            instance.props = current$jscomp$0.memoizedProps;
+            instance.state = current$jscomp$0.memoizedState;
+            instance.componentWillUnmount();
+          } catch (error) {
+            captureCommitPhaseError(current, nearestMountedAncestor, error);
+          }
+        }
+        recursivelyTraverseDisappearLayoutEffects(finishedWork);
+        break;
+      case 26:
+      case 27:
+      case 5:
+        safelyDetachRef(finishedWork, finishedWork.return);
+        recursivelyTraverseDisappearLayoutEffects(finishedWork);
         break;
       case 22:
-        i = deletions.stateNode;
-        i._visibility & 4 &&
-          ((i._visibility &= -5),
-          recursivelyTraverseDisconnectPassiveEffects(deletions));
+        safelyDetachRef(finishedWork, finishedWork.return);
+        null === finishedWork.memoizedState &&
+          recursivelyTraverseDisappearLayoutEffects(finishedWork);
         break;
       default:
-        recursivelyTraverseDisconnectPassiveEffects(deletions);
+        recursivelyTraverseDisappearLayoutEffects(finishedWork);
     }
     parentFiber = parentFiber.sibling;
   }
 }
-function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
-  deletedSubtreeRoot,
-  nearestMountedAncestor
+function recursivelyTraverseReappearLayoutEffects(
+  finishedRoot$jscomp$0,
+  parentFiber,
+  includeWorkInProgressEffects
 ) {
-  for (; null !== nextEffect; ) {
-    var fiber = nextEffect;
-    switch (fiber.tag) {
+  includeWorkInProgressEffects =
+    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
+  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+    var current = parentFiber.alternate,
+      finishedRoot = finishedRoot$jscomp$0,
+      finishedWork = parentFiber,
+      flags = finishedWork.flags;
+    switch (finishedWork.tag) {
       case 0:
       case 11:
       case 15:
-        commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
-    }
-    var child = fiber.child;
-    if (null !== child) (child.return = fiber), (nextEffect = child);
-    else
-      a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
-        child = nextEffect;
-        var sibling = child.sibling,
-          returnFiber = child.return;
-        detachFiberAfterEffects(child);
-        if (child === fiber) {
-          nextEffect = null;
-          break a;
-        }
-        if (null !== sibling) {
-          sibling.return = returnFiber;
-          nextEffect = sibling;
-          break a;
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+        commitHookLayoutEffects(finishedWork, 4);
+        break;
+      case 1:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+        finishedRoot = finishedWork.stateNode;
+        if ("function" === typeof finishedRoot.componentDidMount)
+          try {
+            finishedRoot.componentDidMount();
+          } catch (error) {
+            captureCommitPhaseError(finishedWork, finishedWork.return, error);
+          }
+        current = finishedWork.updateQueue;
+        if (null !== current) {
+          var hiddenCallbacks = current.shared.hiddenCallbacks;
+          if (null !== hiddenCallbacks)
+            for (
+              current.shared.hiddenCallbacks = null, current = 0;
+              current < hiddenCallbacks.length;
+              current++
+            )
+              callCallback(hiddenCallbacks[current], finishedRoot);
         }
-        nextEffect = returnFiber;
-      }
+        includeWorkInProgressEffects &&
+          flags & 64 &&
+          commitClassCallbacks(finishedWork);
+        safelyAttachRef(finishedWork, finishedWork.return);
+        break;
+      case 26:
+      case 27:
+      case 5:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+        includeWorkInProgressEffects &&
+          null === current &&
+          flags & 4 &&
+          commitHostComponentMount(finishedWork);
+        safelyAttachRef(finishedWork, finishedWork.return);
+        break;
+      case 12:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+        break;
+      case 13:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+        break;
+      case 22:
+        null === finishedWork.memoizedState &&
+          recursivelyTraverseReappearLayoutEffects(
+            finishedRoot,
+            finishedWork,
+            includeWorkInProgressEffects
+          );
+        safelyAttachRef(finishedWork, finishedWork.return);
+        break;
+      default:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+    }
+    parentFiber = parentFiber.sibling;
   }
 }
-var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
-  ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher,
-  ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner,
-  ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig,
-  executionContext = 0,
-  workInProgressRoot = null,
-  workInProgress = null,
-  workInProgressRootRenderLanes = 0,
-  workInProgressSuspendedReason = 0,
-  workInProgressThrownValue = null,
-  workInProgressRootDidAttachPingListener = !1,
-  entangledRenderLanes = 0,
-  workInProgressRootExitStatus = 0,
-  workInProgressRootFatalError = null,
-  workInProgressRootSkippedLanes = 0,
-  workInProgressRootInterleavedUpdatedLanes = 0,
-  workInProgressRootPingedLanes = 0,
-  workInProgressDeferredLane = 0,
-  workInProgressRootConcurrentErrors = null,
-  workInProgressRootRecoverableErrors = null,
-  globalMostRecentFallbackTime = 0,
-  workInProgressRootRenderTargetTime = Infinity,
-  workInProgressTransitions = null,
-  hasUncaughtError = !1,
-  firstUncaughtError = null,
-  legacyErrorBoundariesThatAlreadyFailed = null,
-  rootDoesHavePassiveEffects = !1,
-  rootWithPendingPassiveEffects = null,
-  pendingPassiveEffectsLanes = 0,
-  nestedUpdateCount = 0,
-  rootWithNestedUpdates = null;
-function requestUpdateLane(fiber) {
-  if (0 === (fiber.mode & 1)) return 2;
-  if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)
-    return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
-  fiber = ReactCurrentBatchConfig$1.transition;
-  null !== fiber && fiber._callbacks.add(handleAsyncAction);
-  if (null !== fiber)
-    return (
-      0 === currentEventTransitionLane &&
-        (currentEventTransitionLane = claimNextTransitionLane()),
-      currentEventTransitionLane
-    );
-  fiber = currentUpdatePriority;
-  if (0 === fiber)
-    a: {
-      fiber = fabricGetCurrentEventPriority
-        ? fabricGetCurrentEventPriority()
-        : null;
-      if (null != fiber)
-        switch (fiber) {
-          case FabricDiscretePriority:
-            fiber = 2;
-            break a;
-        }
-      fiber = 32;
-    }
-  return fiber;
+function commitHookPassiveMountEffects(finishedWork, hookFlags) {
+  try {
+    commitHookEffectListMount(hookFlags, finishedWork);
+  } catch (error) {
+    captureCommitPhaseError(finishedWork, finishedWork.return, error);
+  }
 }
-function requestDeferredLane() {
-  0 === workInProgressDeferredLane &&
-    (workInProgressDeferredLane =
-      0 !== (workInProgressRootRenderLanes & 536870912)
-        ? 536870912
-        : claimNextTransitionLane());
-  var suspenseHandler = suspenseHandlerStackCursor.current;
-  null !== suspenseHandler && (suspenseHandler.flags |= 32);
-  return workInProgressDeferredLane;
+function recursivelyTraversePassiveMountEffects(root, parentFiber) {
+  if (parentFiber.subtreeFlags & 10256)
+    for (parentFiber = parentFiber.child; null !== parentFiber; )
+      commitPassiveMountOnFiber(root, parentFiber),
+        (parentFiber = parentFiber.sibling);
 }
-function scheduleUpdateOnFiber(root, fiber, lane) {
-  if (
-    (root === workInProgressRoot && 2 === workInProgressSuspendedReason) ||
-    null !== root.cancelPendingCommit
-  )
-    prepareFreshStack(root, 0),
-      markRootSuspended(
-        root,
-        workInProgressRootRenderLanes,
-        workInProgressDeferredLane
-      );
-  markRootUpdated(root, lane);
-  if (0 === (executionContext & 2) || root !== workInProgressRoot)
-    root === workInProgressRoot &&
-      (0 === (executionContext & 2) &&
-        (workInProgressRootInterleavedUpdatedLanes |= lane),
-      4 === workInProgressRootExitStatus &&
-        markRootSuspended(
-          root,
-          workInProgressRootRenderLanes,
-          workInProgressDeferredLane
-        )),
-      ensureRootIsScheduled(root),
-      2 === lane &&
-        0 === executionContext &&
-        0 === (fiber.mode & 1) &&
-        ((workInProgressRootRenderTargetTime = now() + 500),
-        flushSyncWorkAcrossRoots_impl(!0));
+function commitPassiveMountOnFiber(finishedRoot, finishedWork) {
+  var flags = finishedWork.flags;
+  switch (finishedWork.tag) {
+    case 0:
+    case 11:
+    case 15:
+      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
+      flags & 2048 && commitHookPassiveMountEffects(finishedWork, 9);
+      break;
+    case 3:
+      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
+      break;
+    case 23:
+      break;
+    case 22:
+      flags = finishedWork.stateNode;
+      null !== finishedWork.memoizedState
+        ? flags._visibility & 4
+          ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork)
+          : finishedWork.mode & 1 ||
+            ((flags._visibility |= 4),
+            recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork))
+        : flags._visibility & 4
+        ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork)
+        : ((flags._visibility |= 4),
+          recursivelyTraverseReconnectPassiveEffects(
+            finishedRoot,
+            finishedWork
+          ));
+      break;
+    case 24:
+      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
+      break;
+    default:
+      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
+  }
 }
-function performConcurrentWorkOnRoot(root, didTimeout) {
-  if (0 !== (executionContext & 6))
-    throw Error("Should not already be working.");
-  var originalCallbackNode = root.callbackNode;
-  if (flushPassiveEffects() && root.callbackNode !== originalCallbackNode)
-    return null;
-  var lanes = getNextLanes(
-    root,
-    root === workInProgressRoot ? workInProgressRootRenderLanes : 0
-  );
-  if (0 === lanes) return null;
-  var exitStatus = (didTimeout =
-    0 === (lanes & 60) && 0 === (lanes & root.expiredLanes) && !didTimeout)
-    ? renderRootConcurrent(root, lanes)
-    : renderRootSync(root, lanes);
-  if (0 !== exitStatus) {
-    var renderWasConcurrent = didTimeout;
-    do {
-      if (6 === exitStatus) markRootSuspended(root, lanes, 0);
-      else {
-        didTimeout = root.current.alternate;
-        if (
-          renderWasConcurrent &&
-          !isRenderConsistentWithExternalStores(didTimeout)
-        ) {
-          exitStatus = renderRootSync(root, lanes);
-          renderWasConcurrent = !1;
-          continue;
-        }
-        if (2 === exitStatus) {
-          renderWasConcurrent = lanes;
-          var errorRetryLanes = getLanesToRetrySynchronouslyOnError(
-            root,
-            renderWasConcurrent
-          );
-          0 !== errorRetryLanes &&
-            ((lanes = errorRetryLanes),
-            (exitStatus = recoverFromConcurrentError(
-              root,
-              renderWasConcurrent,
-              errorRetryLanes
-            )));
-        }
-        if (1 === exitStatus)
-          throw (
-            ((originalCallbackNode = workInProgressRootFatalError),
-            prepareFreshStack(root, 0),
-            markRootSuspended(root, lanes, 0),
-            ensureRootIsScheduled(root),
-            originalCallbackNode)
-          );
-        root.finishedWork = didTimeout;
-        root.finishedLanes = lanes;
-        a: {
-          renderWasConcurrent = root;
-          switch (exitStatus) {
-            case 0:
-            case 1:
-              throw Error("Root did not complete. This is a bug in React.");
-            case 4:
-              if ((lanes & 4194176) === lanes) {
-                markRootSuspended(
-                  renderWasConcurrent,
-                  lanes,
-                  workInProgressDeferredLane
-                );
-                break a;
-              }
-              break;
-            case 2:
-            case 3:
-            case 5:
-              break;
-            default:
-              throw Error("Unknown root exit status.");
-          }
-          if (
-            (lanes & 62914560) === lanes &&
-            3 === exitStatus &&
-            ((exitStatus = globalMostRecentFallbackTime + 300 - now()),
-            10 < exitStatus)
-          ) {
-            markRootSuspended(
-              renderWasConcurrent,
-              lanes,
-              workInProgressDeferredLane
-            );
-            if (0 !== getNextLanes(renderWasConcurrent, 0)) break a;
-            renderWasConcurrent.timeoutHandle = scheduleTimeout(
-              commitRootWhenReady.bind(
-                null,
-                renderWasConcurrent,
-                didTimeout,
-                workInProgressRootRecoverableErrors,
-                workInProgressTransitions,
-                lanes,
-                workInProgressDeferredLane
-              ),
-              exitStatus
-            );
-            break a;
-          }
-          commitRootWhenReady(
-            renderWasConcurrent,
-            didTimeout,
-            workInProgressRootRecoverableErrors,
-            workInProgressTransitions,
-            lanes,
-            workInProgressDeferredLane
-          );
-        }
-      }
-      break;
-    } while (1);
-  }
-  ensureRootIsScheduled(root);
-  scheduleTaskForRootDuringMicrotask(root, now());
-  root =
-    root.callbackNode === originalCallbackNode
-      ? performConcurrentWorkOnRoot.bind(null, root)
-      : null;
-  return root;
-}
-function recoverFromConcurrentError(
-  root,
-  originallyAttemptedLanes,
-  errorRetryLanes
+function recursivelyTraverseReconnectPassiveEffects(
+  finishedRoot$jscomp$0,
+  parentFiber
 ) {
-  var errorsFromFirstAttempt = workInProgressRootConcurrentErrors,
-    JSCompiler_inline_result;
-  (JSCompiler_inline_result = root.current.memoizedState.isDehydrated) &&
-    (prepareFreshStack(root, errorRetryLanes).flags |= 256);
-  errorRetryLanes = renderRootSync(root, errorRetryLanes);
-  if (2 !== errorRetryLanes) {
-    if (workInProgressRootDidAttachPingListener && !JSCompiler_inline_result)
-      return (
-        (root.errorRecoveryDisabledLanes |= originallyAttemptedLanes),
-        (workInProgressRootInterleavedUpdatedLanes |= originallyAttemptedLanes),
-        4
-      );
-    root = workInProgressRootRecoverableErrors;
-    workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
-    null !== root && queueRecoverableErrors(root);
+  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+    var finishedRoot = finishedRoot$jscomp$0,
+      finishedWork = parentFiber;
+    switch (finishedWork.tag) {
+      case 0:
+      case 11:
+      case 15:
+        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork);
+        commitHookPassiveMountEffects(finishedWork, 8);
+        break;
+      case 23:
+        break;
+      case 22:
+        var instance = finishedWork.stateNode;
+        null !== finishedWork.memoizedState
+          ? instance._visibility & 4
+            ? recursivelyTraverseReconnectPassiveEffects(
+                finishedRoot,
+                finishedWork
+              )
+            : finishedWork.mode & 1 ||
+              ((instance._visibility |= 4),
+              recursivelyTraverseReconnectPassiveEffects(
+                finishedRoot,
+                finishedWork
+              ))
+          : ((instance._visibility |= 4),
+            recursivelyTraverseReconnectPassiveEffects(
+              finishedRoot,
+              finishedWork
+            ));
+        break;
+      case 24:
+        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork);
+        break;
+      default:
+        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork);
+    }
+    parentFiber = parentFiber.sibling;
   }
-  return errorRetryLanes;
-}
-function queueRecoverableErrors(errors) {
-  null === workInProgressRootRecoverableErrors
-    ? (workInProgressRootRecoverableErrors = errors)
-    : workInProgressRootRecoverableErrors.push.apply(
-        workInProgressRootRecoverableErrors,
-        errors
-      );
 }
-function commitRootWhenReady(
-  root,
-  finishedWork,
-  recoverableErrors,
-  transitions,
-  lanes,
-  spawnedLane
-) {
-  0 === (lanes & 42) && accumulateSuspenseyCommitOnFiber(finishedWork);
-  commitRoot(root, recoverableErrors, transitions, spawnedLane);
+var suspenseyCommitFlag = 8192;
+function recursivelyAccumulateSuspenseyCommit(parentFiber) {
+  if (parentFiber.subtreeFlags & suspenseyCommitFlag)
+    for (parentFiber = parentFiber.child; null !== parentFiber; )
+      accumulateSuspenseyCommitOnFiber(parentFiber),
+        (parentFiber = parentFiber.sibling);
 }
-function isRenderConsistentWithExternalStores(finishedWork) {
-  for (var node = finishedWork; ; ) {
-    if (node.flags & 16384) {
-      var updateQueue = node.updateQueue;
-      if (
-        null !== updateQueue &&
-        ((updateQueue = updateQueue.stores), null !== updateQueue)
-      )
-        for (var i = 0; i < updateQueue.length; i++) {
-          var check = updateQueue[i],
-            getSnapshot = check.getSnapshot;
-          check = check.value;
-          try {
-            if (!objectIs(getSnapshot(), check)) return !1;
-          } catch (error) {
-            return !1;
-          }
-        }
-    }
-    updateQueue = node.child;
-    if (node.subtreeFlags & 16384 && null !== updateQueue)
-      (updateQueue.return = node), (node = updateQueue);
-    else {
-      if (node === finishedWork) break;
-      for (; null === node.sibling; ) {
-        if (null === node.return || node.return === finishedWork) return !0;
-        node = node.return;
+function accumulateSuspenseyCommitOnFiber(fiber) {
+  switch (fiber.tag) {
+    case 26:
+      recursivelyAccumulateSuspenseyCommit(fiber);
+      if (fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState)
+        throw Error(
+          "The current renderer does not support Resources. This error is likely caused by a bug in React. Please file an issue."
+        );
+      break;
+    case 5:
+      recursivelyAccumulateSuspenseyCommit(fiber);
+      break;
+    case 3:
+    case 4:
+      recursivelyAccumulateSuspenseyCommit(fiber);
+      break;
+    case 22:
+      if (null === fiber.memoizedState) {
+        var current = fiber.alternate;
+        null !== current && null !== current.memoizedState
+          ? ((current = suspenseyCommitFlag),
+            (suspenseyCommitFlag = 16777216),
+            recursivelyAccumulateSuspenseyCommit(fiber),
+            (suspenseyCommitFlag = current))
+          : recursivelyAccumulateSuspenseyCommit(fiber);
       }
-      node.sibling.return = node.return;
-      node = node.sibling;
-    }
+      break;
+    default:
+      recursivelyAccumulateSuspenseyCommit(fiber);
   }
-  return !0;
 }
-function markRootSuspended(root, suspendedLanes, spawnedLane) {
-  suspendedLanes &= ~workInProgressRootPingedLanes;
-  suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
-  root.suspendedLanes |= suspendedLanes;
-  root.pingedLanes &= ~suspendedLanes;
-  for (
-    var expirationTimes = root.expirationTimes, lanes = suspendedLanes;
-    0 < lanes;
-
-  ) {
-    var index$4 = 31 - clz32(lanes),
-      lane = 1 << index$4;
-    expirationTimes[index$4] = -1;
-    lanes &= ~lane;
+function detachAlternateSiblings(parentFiber) {
+  var previousFiber = parentFiber.alternate;
+  if (
+    null !== previousFiber &&
+    ((parentFiber = previousFiber.child), null !== parentFiber)
+  ) {
+    previousFiber.child = null;
+    do
+      (previousFiber = parentFiber.sibling),
+        (parentFiber.sibling = null),
+        (parentFiber = previousFiber);
+    while (null !== parentFiber);
   }
-  0 !== spawnedLane &&
-    markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
 }
-function resetWorkInProgressStack() {
-  if (null !== workInProgress) {
-    if (0 === workInProgressSuspendedReason)
-      var interruptedWork = workInProgress.return;
-    else
-      (interruptedWork = workInProgress),
-        resetContextDependencies(),
-        resetHooksOnUnwind(interruptedWork),
-        (thenableState$1 = null),
-        (thenableIndexCounter$1 = 0),
-        (interruptedWork = workInProgress);
-    for (; null !== interruptedWork; )
-      unwindInterruptedWork(interruptedWork.alternate, interruptedWork),
-        (interruptedWork = interruptedWork.return);
-    workInProgress = null;
+function recursivelyTraversePassiveUnmountEffects(parentFiber) {
+  var deletions = parentFiber.deletions;
+  if (0 !== (parentFiber.flags & 16)) {
+    if (null !== deletions)
+      for (var i = 0; i < deletions.length; i++) {
+        var childToDelete = deletions[i];
+        nextEffect = childToDelete;
+        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
+          childToDelete,
+          parentFiber
+        );
+      }
+    detachAlternateSiblings(parentFiber);
   }
+  if (parentFiber.subtreeFlags & 10256)
+    for (parentFiber = parentFiber.child; null !== parentFiber; )
+      commitPassiveUnmountOnFiber(parentFiber),
+        (parentFiber = parentFiber.sibling);
 }
-function prepareFreshStack(root, lanes) {
-  root.finishedWork = null;
-  root.finishedLanes = 0;
-  var timeoutHandle = root.timeoutHandle;
-  -1 !== timeoutHandle &&
-    ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle));
-  timeoutHandle = root.cancelPendingCommit;
-  null !== timeoutHandle &&
-    ((root.cancelPendingCommit = null), timeoutHandle());
-  resetWorkInProgressStack();
-  workInProgressRoot = root;
-  workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
-  workInProgressRootRenderLanes = lanes;
-  workInProgressSuspendedReason = 0;
-  workInProgressThrownValue = null;
-  workInProgressRootDidAttachPingListener = !1;
-  workInProgressRootExitStatus = 0;
-  workInProgressRootFatalError = null;
-  workInProgressDeferredLane =
-    workInProgressRootPingedLanes =
-    workInProgressRootInterleavedUpdatedLanes =
-    workInProgressRootSkippedLanes =
-      0;
-  workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors =
-    null;
-  0 !== (lanes & 8) && (lanes |= lanes & 32);
-  var allEntangledLanes = root.entangledLanes;
-  if (0 !== allEntangledLanes)
-    for (
-      root = root.entanglements, allEntangledLanes &= lanes;
-      0 < allEntangledLanes;
-
-    ) {
-      var index$2 = 31 - clz32(allEntangledLanes),
-        lane = 1 << index$2;
-      lanes |= root[index$2];
-      allEntangledLanes &= ~lane;
-    }
-  entangledRenderLanes = lanes;
-  finishQueueingConcurrentUpdates();
-  return timeoutHandle;
-}
-function handleThrow(root, thrownValue) {
-  currentlyRenderingFiber$1 = null;
-  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
-  ReactCurrentOwner.current = null;
-  thrownValue === SuspenseException
-    ? ((thrownValue = getSuspendedThenable()),
-      (root = suspenseHandlerStackCursor.current),
-      (workInProgressSuspendedReason =
-        (null !== root &&
-          ((workInProgressRootRenderLanes & 4194176) ===
-          workInProgressRootRenderLanes
-            ? null !== shellBoundary
-            : ((workInProgressRootRenderLanes & 62914560) !==
-                workInProgressRootRenderLanes &&
-                0 === (workInProgressRootRenderLanes & 536870912)) ||
-              root !== shellBoundary)) ||
-        0 !== (workInProgressRootSkippedLanes & 134217727) ||
-        0 !== (workInProgressRootInterleavedUpdatedLanes & 134217727)
-          ? 3
-          : 2))
-    : thrownValue === SuspenseyCommitException
-    ? ((thrownValue = getSuspendedThenable()),
-      (workInProgressSuspendedReason = 4))
-    : (workInProgressSuspendedReason =
-        thrownValue === SelectiveHydrationException
-          ? 8
-          : null !== thrownValue &&
-            "object" === typeof thrownValue &&
-            "function" === typeof thrownValue.then
-          ? 6
-          : 1);
-  workInProgressThrownValue = thrownValue;
-  null === workInProgress &&
-    ((workInProgressRootExitStatus = 1),
-    (workInProgressRootFatalError = thrownValue));
-}
-function pushDispatcher() {
-  var prevDispatcher = ReactCurrentDispatcher.current;
-  ReactCurrentDispatcher.current = ContextOnlyDispatcher;
-  return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
-}
-function renderDidSuspendDelayIfPossible() {
-  workInProgressRootExitStatus = 4;
-  (0 === (workInProgressRootSkippedLanes & 134217727) &&
-    0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||
-    null === workInProgressRoot ||
-    markRootSuspended(
-      workInProgressRoot,
-      workInProgressRootRenderLanes,
-      workInProgressDeferredLane
-    );
+function commitPassiveUnmountOnFiber(finishedWork) {
+  switch (finishedWork.tag) {
+    case 0:
+    case 11:
+    case 15:
+      recursivelyTraversePassiveUnmountEffects(finishedWork);
+      finishedWork.flags & 2048 &&
+        commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
+      break;
+    case 22:
+      var instance = finishedWork.stateNode;
+      null !== finishedWork.memoizedState &&
+      instance._visibility & 4 &&
+      (null === finishedWork.return || 13 !== finishedWork.return.tag)
+        ? ((instance._visibility &= -5),
+          recursivelyTraverseDisconnectPassiveEffects(finishedWork))
+        : recursivelyTraversePassiveUnmountEffects(finishedWork);
+      break;
+    default:
+      recursivelyTraversePassiveUnmountEffects(finishedWork);
+  }
 }
-function renderRootSync(root, lanes) {
-  var prevExecutionContext = executionContext;
-  executionContext |= 2;
-  var prevDispatcher = pushDispatcher();
-  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes)
-    (workInProgressTransitions = null), prepareFreshStack(root, lanes);
-  lanes = !1;
-  a: do
-    try {
-      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
-        var unitOfWork = workInProgress,
-          thrownValue = workInProgressThrownValue;
-        switch (workInProgressSuspendedReason) {
-          case 8:
-            resetWorkInProgressStack();
-            workInProgressRootExitStatus = 6;
-            break a;
-          case 3:
-          case 2:
-            lanes ||
-              null !== suspenseHandlerStackCursor.current ||
-              (lanes = !0);
-          default:
-            (workInProgressSuspendedReason = 0),
-              (workInProgressThrownValue = null),
-              throwAndUnwindWorkLoop(root, unitOfWork, thrownValue);
-        }
+function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
+  var deletions = parentFiber.deletions;
+  if (0 !== (parentFiber.flags & 16)) {
+    if (null !== deletions)
+      for (var i = 0; i < deletions.length; i++) {
+        var childToDelete = deletions[i];
+        nextEffect = childToDelete;
+        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
+          childToDelete,
+          parentFiber
+        );
       }
-      workLoopSync();
-      break;
-    } catch (thrownValue$89) {
-      handleThrow(root, thrownValue$89);
+    detachAlternateSiblings(parentFiber);
+  }
+  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+    deletions = parentFiber;
+    switch (deletions.tag) {
+      case 0:
+      case 11:
+      case 15:
+        commitHookEffectListUnmount(8, deletions, deletions.return);
+        recursivelyTraverseDisconnectPassiveEffects(deletions);
+        break;
+      case 22:
+        i = deletions.stateNode;
+        i._visibility & 4 &&
+          ((i._visibility &= -5),
+          recursivelyTraverseDisconnectPassiveEffects(deletions));
+        break;
+      default:
+        recursivelyTraverseDisconnectPassiveEffects(deletions);
     }
-  while (1);
-  lanes && root.shellSuspendCounter++;
-  resetContextDependencies();
-  executionContext = prevExecutionContext;
-  ReactCurrentDispatcher.current = prevDispatcher;
-  if (null !== workInProgress)
-    throw Error(
-      "Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue."
-    );
-  workInProgressRoot = null;
-  workInProgressRootRenderLanes = 0;
-  finishQueueingConcurrentUpdates();
-  return workInProgressRootExitStatus;
-}
-function workLoopSync() {
-  for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
+    parentFiber = parentFiber.sibling;
+  }
 }
-function renderRootConcurrent(root, lanes) {
-  var prevExecutionContext = executionContext;
-  executionContext |= 2;
-  var prevDispatcher = pushDispatcher();
-  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes)
-    (workInProgressTransitions = null),
-      (workInProgressRootRenderTargetTime = now() + 500),
-      prepareFreshStack(root, lanes);
-  a: do
-    try {
-      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
-        lanes = workInProgress;
-        var thrownValue = workInProgressThrownValue;
-        b: switch (workInProgressSuspendedReason) {
-          case 1:
-            workInProgressSuspendedReason = 0;
-            workInProgressThrownValue = null;
-            throwAndUnwindWorkLoop(root, lanes, thrownValue);
-            break;
-          case 2:
-            if (isThenableResolved(thrownValue)) {
-              workInProgressSuspendedReason = 0;
-              workInProgressThrownValue = null;
-              replaySuspendedUnitOfWork(lanes);
-              break;
-            }
-            lanes = function () {
-              2 === workInProgressSuspendedReason &&
-                workInProgressRoot === root &&
-                (workInProgressSuspendedReason = 7);
-              ensureRootIsScheduled(root);
-            };
-            thrownValue.then(lanes, lanes);
-            break a;
-          case 3:
-            workInProgressSuspendedReason = 7;
-            break a;
-          case 4:
-            workInProgressSuspendedReason = 5;
-            break a;
-          case 7:
-            isThenableResolved(thrownValue)
-              ? ((workInProgressSuspendedReason = 0),
-                (workInProgressThrownValue = null),
-                replaySuspendedUnitOfWork(lanes))
-              : ((workInProgressSuspendedReason = 0),
-                (workInProgressThrownValue = null),
-                throwAndUnwindWorkLoop(root, lanes, thrownValue));
-            break;
-          case 5:
-            switch (workInProgress.tag) {
-              case 5:
-              case 26:
-              case 27:
-                lanes = workInProgress;
-                workInProgressSuspendedReason = 0;
-                workInProgressThrownValue = null;
-                var sibling = lanes.sibling;
-                if (null !== sibling) workInProgress = sibling;
-                else {
-                  var returnFiber = lanes.return;
-                  null !== returnFiber
-                    ? ((workInProgress = returnFiber),
-                      completeUnitOfWork(returnFiber))
-                    : (workInProgress = null);
-                }
-                break b;
-            }
-            workInProgressSuspendedReason = 0;
-            workInProgressThrownValue = null;
-            throwAndUnwindWorkLoop(root, lanes, thrownValue);
-            break;
-          case 6:
-            workInProgressSuspendedReason = 0;
-            workInProgressThrownValue = null;
-            throwAndUnwindWorkLoop(root, lanes, thrownValue);
-            break;
-          case 8:
-            resetWorkInProgressStack();
-            workInProgressRootExitStatus = 6;
-            break a;
-          default:
-            throw Error("Unexpected SuspendedReason. This is a bug in React.");
+function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
+  deletedSubtreeRoot,
+  nearestMountedAncestor
+) {
+  for (; null !== nextEffect; ) {
+    var fiber = nextEffect;
+    switch (fiber.tag) {
+      case 0:
+      case 11:
+      case 15:
+        commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
+    }
+    var child = fiber.child;
+    if (null !== child) (child.return = fiber), (nextEffect = child);
+    else
+      a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
+        child = nextEffect;
+        var sibling = child.sibling,
+          returnFiber = child.return;
+        detachFiberAfterEffects(child);
+        if (child === fiber) {
+          nextEffect = null;
+          break a;
+        }
+        if (null !== sibling) {
+          sibling.return = returnFiber;
+          nextEffect = sibling;
+          break a;
         }
+        nextEffect = returnFiber;
       }
-      workLoopConcurrent();
-      break;
-    } catch (thrownValue$91) {
-      handleThrow(root, thrownValue$91);
-    }
-  while (1);
-  resetContextDependencies();
-  ReactCurrentDispatcher.current = prevDispatcher;
-  executionContext = prevExecutionContext;
-  if (null !== workInProgress) return 0;
-  workInProgressRoot = null;
-  workInProgressRootRenderLanes = 0;
-  finishQueueingConcurrentUpdates();
-  return workInProgressRootExitStatus;
-}
-function workLoopConcurrent() {
-  for (; null !== workInProgress && !shouldYield(); )
-    performUnitOfWork(workInProgress);
-}
-function performUnitOfWork(unitOfWork) {
-  var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
-  unitOfWork.memoizedProps = unitOfWork.pendingProps;
-  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
-  ReactCurrentOwner.current = null;
-}
-function replaySuspendedUnitOfWork(unitOfWork) {
-  var current = unitOfWork.alternate;
-  switch (unitOfWork.tag) {
-    case 2:
-      unitOfWork.tag = 0;
-    case 15:
-    case 0:
-      var Component = unitOfWork.type,
-        unresolvedProps = unitOfWork.pendingProps;
-      unresolvedProps =
-        unitOfWork.elementType === Component
-          ? unresolvedProps
-          : resolveDefaultProps(Component, unresolvedProps);
-      var context = isContextProvider(Component)
-        ? previousContext
-        : contextStackCursor$1.current;
-      context = getMaskedContext(unitOfWork, context);
-      current = replayFunctionComponent(
-        current,
-        unitOfWork,
-        unresolvedProps,
-        Component,
-        context,
-        workInProgressRootRenderLanes
-      );
-      break;
-    case 11:
-      Component = unitOfWork.type.render;
-      unresolvedProps = unitOfWork.pendingProps;
-      unresolvedProps =
-        unitOfWork.elementType === Component
-          ? unresolvedProps
-          : resolveDefaultProps(Component, unresolvedProps);
-      current = replayFunctionComponent(
-        current,
-        unitOfWork,
-        unresolvedProps,
-        Component,
-        unitOfWork.ref,
-        workInProgressRootRenderLanes
-      );
-      break;
-    case 5:
-      resetHooksOnUnwind(unitOfWork);
-    default:
-      unwindInterruptedWork(current, unitOfWork),
-        (unitOfWork = workInProgress =
-          resetWorkInProgress(unitOfWork, entangledRenderLanes)),
-        (current = beginWork(current, unitOfWork, entangledRenderLanes));
   }
-  unitOfWork.memoizedProps = unitOfWork.pendingProps;
-  null === current
-    ? completeUnitOfWork(unitOfWork)
-    : (workInProgress = current);
-  ReactCurrentOwner.current = null;
 }
-function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue) {
-  resetContextDependencies();
-  resetHooksOnUnwind(unitOfWork);
-  thenableState$1 = null;
-  thenableIndexCounter$1 = 0;
-  var returnFiber = unitOfWork.return;
-  try {
-    if (
-      throwException(
-        root,
-        returnFiber,
-        unitOfWork,
-        thrownValue,
-        workInProgressRootRenderLanes
-      )
-    ) {
-      workInProgressRootExitStatus = 1;
-      workInProgressRootFatalError = thrownValue;
-      workInProgress = null;
-      return;
+var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
+  ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher,
+  ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner,
+  ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig,
+  executionContext = 0,
+  workInProgressRoot = null,
+  workInProgress = null,
+  workInProgressRootRenderLanes = 0,
+  workInProgressSuspendedReason = 0,
+  workInProgressThrownValue = null,
+  workInProgressRootDidAttachPingListener = !1,
+  entangledRenderLanes = 0,
+  workInProgressRootExitStatus = 0,
+  workInProgressRootFatalError = null,
+  workInProgressRootSkippedLanes = 0,
+  workInProgressRootInterleavedUpdatedLanes = 0,
+  workInProgressRootPingedLanes = 0,
+  workInProgressDeferredLane = 0,
+  workInProgressRootConcurrentErrors = null,
+  workInProgressRootRecoverableErrors = null,
+  workInProgressRootDidIncludeRecursiveRenderUpdate = !1,
+  globalMostRecentFallbackTime = 0,
+  workInProgressRootRenderTargetTime = Infinity,
+  workInProgressTransitions = null,
+  hasUncaughtError = !1,
+  firstUncaughtError = null,
+  legacyErrorBoundariesThatAlreadyFailed = null,
+  rootDoesHavePassiveEffects = !1,
+  rootWithPendingPassiveEffects = null,
+  pendingPassiveEffectsLanes = 0,
+  nestedUpdateCount = 0,
+  rootWithNestedUpdates = null;
+function requestUpdateLane(fiber) {
+  if (0 === (fiber.mode & 1)) return 2;
+  if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)
+    return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
+  fiber = ReactCurrentBatchConfig$1.transition;
+  if (null !== fiber) {
+    if (!fiber._callbacks) {
+      fiber._callbacks = new Set();
     }
-  } catch (error) {
-    if (null !== returnFiber) throw ((workInProgress = returnFiber), error);
-    workInProgressRootExitStatus = 1;
-    workInProgressRootFatalError = thrownValue;
-    workInProgress = null;
-    return;
+    fiber._callbacks.add(handleAsyncAction);
   }
-  if (unitOfWork.flags & 32768)
+  if (null !== fiber)
+    return (
+      0 === currentEventTransitionLane &&
+        (currentEventTransitionLane = claimNextTransitionLane()),
+      currentEventTransitionLane
+    );
+  fiber = currentUpdatePriority;
+  if (0 === fiber)
     a: {
-      root = unitOfWork;
-      do {
-        unitOfWork = unwindWork(root.alternate, root);
-        if (null !== unitOfWork) {
-          unitOfWork.flags &= 32767;
-          workInProgress = unitOfWork;
-          break a;
+      fiber = fabricGetCurrentEventPriority
+        ? fabricGetCurrentEventPriority()
+        : null;
+      if (null != fiber)
+        switch (fiber) {
+          case FabricDiscretePriority:
+            fiber = 2;
+            break a;
         }
-        root = root.return;
-        null !== root &&
-          ((root.flags |= 32768),
-          (root.subtreeFlags = 0),
-          (root.deletions = null));
-        workInProgress = root;
-      } while (null !== root);
-      workInProgressRootExitStatus = 6;
-      workInProgress = null;
+      fiber = 32;
     }
-  else completeUnitOfWork(unitOfWork);
+  return fiber;
 }
-function completeUnitOfWork(unitOfWork) {
-  var completedWork = unitOfWork;
-  do {
-    unitOfWork = completedWork.return;
-    var next = completeWork(
-      completedWork.alternate,
-      completedWork,
-      entangledRenderLanes
-    );
-    if (null !== next) {
-      workInProgress = next;
-      return;
-    }
-    completedWork = completedWork.sibling;
-    if (null !== completedWork) {
-      workInProgress = completedWork;
-      return;
-    }
-    workInProgress = completedWork = unitOfWork;
-  } while (null !== completedWork);
-  0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
+function requestDeferredLane() {
+  0 === workInProgressDeferredLane &&
+    (workInProgressDeferredLane =
+      0 !== (workInProgressRootRenderLanes & 536870912)
+        ? 536870912
+        : claimNextTransitionLane());
+  var suspenseHandler = suspenseHandlerStackCursor.current;
+  null !== suspenseHandler && (suspenseHandler.flags |= 32);
+  return workInProgressDeferredLane;
 }
-function commitRoot(root, recoverableErrors, transitions, spawnedLane) {
-  var previousUpdateLanePriority = currentUpdatePriority,
-    prevTransition = ReactCurrentBatchConfig.transition;
-  try {
-    (ReactCurrentBatchConfig.transition = null),
-      (currentUpdatePriority = 2),
-      commitRootImpl(
+function scheduleUpdateOnFiber(root, fiber, lane) {
+  if (
+    (root === workInProgressRoot && 2 === workInProgressSuspendedReason) ||
+    null !== root.cancelPendingCommit
+  )
+    prepareFreshStack(root, 0),
+      markRootSuspended(
         root,
-        recoverableErrors,
-        transitions,
-        previousUpdateLanePriority,
-        spawnedLane
+        workInProgressRootRenderLanes,
+        workInProgressDeferredLane
       );
-  } finally {
-    (ReactCurrentBatchConfig.transition = prevTransition),
-      (currentUpdatePriority = previousUpdateLanePriority);
-  }
-  return null;
+  markRootUpdated$1(root, lane);
+  if (0 === (executionContext & 2) || root !== workInProgressRoot)
+    root === workInProgressRoot &&
+      (0 === (executionContext & 2) &&
+        (workInProgressRootInterleavedUpdatedLanes |= lane),
+      4 === workInProgressRootExitStatus &&
+        markRootSuspended(
+          root,
+          workInProgressRootRenderLanes,
+          workInProgressDeferredLane
+        )),
+      ensureRootIsScheduled(root),
+      2 === lane &&
+        0 === executionContext &&
+        0 === (fiber.mode & 1) &&
+        ((workInProgressRootRenderTargetTime = now() + 500),
+        flushSyncWorkAcrossRoots_impl(!0));
 }
-function commitRootImpl(
-  root,
-  recoverableErrors,
-  transitions,
-  renderPriorityLevel,
-  spawnedLane
-) {
-  do flushPassiveEffects();
-  while (null !== rootWithPendingPassiveEffects);
+function performConcurrentWorkOnRoot(root, didTimeout) {
   if (0 !== (executionContext & 6))
     throw Error("Should not already be working.");
-  var finishedWork = root.finishedWork;
-  transitions = root.finishedLanes;
-  if (null === finishedWork) return null;
-  root.finishedWork = null;
-  root.finishedLanes = 0;
-  if (finishedWork === root.current)
-    throw Error(
-      "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
-    );
-  root.callbackNode = null;
-  root.callbackPriority = 0;
-  root.cancelPendingCommit = null;
-  var remainingLanes = finishedWork.lanes | finishedWork.childLanes;
-  remainingLanes |= concurrentlyUpdatedLanes;
-  markRootFinished(root, remainingLanes, spawnedLane);
-  root === workInProgressRoot &&
-    ((workInProgress = workInProgressRoot = null),
-    (workInProgressRootRenderLanes = 0));
-  (0 === (finishedWork.subtreeFlags & 10256) &&
-    0 === (finishedWork.flags & 10256)) ||
-    rootDoesHavePassiveEffects ||
-    ((rootDoesHavePassiveEffects = !0),
-    scheduleCallback(NormalPriority, function () {
-      flushPassiveEffects();
-      return null;
-    }));
-  spawnedLane = 0 !== (finishedWork.flags & 15990);
-  if (0 !== (finishedWork.subtreeFlags & 15990) || spawnedLane) {
-    spawnedLane = ReactCurrentBatchConfig.transition;
-    ReactCurrentBatchConfig.transition = null;
-    remainingLanes = currentUpdatePriority;
-    currentUpdatePriority = 2;
-    var prevExecutionContext = executionContext;
-    executionContext |= 4;
-    ReactCurrentOwner.current = null;
-    commitBeforeMutationEffects(root, finishedWork);
-    commitMutationEffectsOnFiber(finishedWork, root);
-    root.current = finishedWork;
-    commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);
-    requestPaint();
-    executionContext = prevExecutionContext;
-    currentUpdatePriority = remainingLanes;
-    ReactCurrentBatchConfig.transition = spawnedLane;
-  } else root.current = finishedWork;
-  rootDoesHavePassiveEffects &&
-    ((rootDoesHavePassiveEffects = !1),
-    (rootWithPendingPassiveEffects = root),
-    (pendingPassiveEffectsLanes = transitions));
-  remainingLanes = root.pendingLanes;
-  0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
-  onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
-  ensureRootIsScheduled(root);
-  if (null !== recoverableErrors)
-    for (
-      renderPriorityLevel = root.onRecoverableError, finishedWork = 0;
-      finishedWork < recoverableErrors.length;
-      finishedWork++
-    )
-      (spawnedLane = recoverableErrors[finishedWork]),
-        (remainingLanes = {
-          digest: spawnedLane.digest,
-          componentStack: spawnedLane.stack
-        }),
-        renderPriorityLevel(spawnedLane.value, remainingLanes);
-  if (hasUncaughtError)
-    throw (
-      ((hasUncaughtError = !1),
-      (root = firstUncaughtError),
-      (firstUncaughtError = null),
-      root)
-    );
-  0 !== (pendingPassiveEffectsLanes & 3) &&
-    0 !== root.tag &&
-    flushPassiveEffects();
-  remainingLanes = root.pendingLanes;
-  0 !== (transitions & 4194218) && 0 !== (remainingLanes & 42)
-    ? root === rootWithNestedUpdates
-      ? nestedUpdateCount++
-      : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root))
-    : (nestedUpdateCount = 0);
-  flushSyncWorkAcrossRoots_impl(!1);
-  return null;
-}
-function flushPassiveEffects() {
-  if (null !== rootWithPendingPassiveEffects) {
-    var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes),
-      prevTransition = ReactCurrentBatchConfig.transition,
-      previousPriority = currentUpdatePriority;
-    try {
-      ReactCurrentBatchConfig.transition = null;
-      currentUpdatePriority = 32 > renderPriority ? 32 : renderPriority;
-      if (null === rootWithPendingPassiveEffects)
-        var JSCompiler_inline_result = !1;
+  var originalCallbackNode = root.callbackNode;
+  if (flushPassiveEffects() && root.callbackNode !== originalCallbackNode)
+    return null;
+  var lanes = getNextLanes(
+    root,
+    root === workInProgressRoot ? workInProgressRootRenderLanes : 0
+  );
+  if (0 === lanes) return null;
+  var exitStatus = (didTimeout =
+    0 === (lanes & 60) && 0 === (lanes & root.expiredLanes) && !didTimeout)
+    ? renderRootConcurrent(root, lanes)
+    : renderRootSync(root, lanes);
+  if (0 !== exitStatus) {
+    var renderWasConcurrent = didTimeout;
+    do {
+      if (6 === exitStatus) markRootSuspended(root, lanes, 0);
       else {
-        renderPriority = rootWithPendingPassiveEffects;
-        rootWithPendingPassiveEffects = null;
-        pendingPassiveEffectsLanes = 0;
-        if (0 !== (executionContext & 6))
-          throw Error("Cannot flush passive effects while already rendering.");
-        var prevExecutionContext = executionContext;
-        executionContext |= 4;
-        commitPassiveUnmountOnFiber(renderPriority.current);
-        commitPassiveMountOnFiber(renderPriority, renderPriority.current);
-        executionContext = prevExecutionContext;
-        flushSyncWorkAcrossRoots_impl(!1);
-        if (
-          injectedHook &&
-          "function" === typeof injectedHook.onPostCommitFiberRoot
-        )
-          try {
-            injectedHook.onPostCommitFiberRoot(rendererID, renderPriority);
-          } catch (err) {}
-        JSCompiler_inline_result = !0;
-      }
-      return JSCompiler_inline_result;
-    } finally {
-      (currentUpdatePriority = previousPriority),
-        (ReactCurrentBatchConfig.transition = prevTransition);
-    }
-  }
-  return !1;
-}
-function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
-  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
-  sourceFiber = createRootErrorUpdate(rootFiber, sourceFiber, 2);
-  rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
-  null !== rootFiber &&
-    (markRootUpdated(rootFiber, 2), ensureRootIsScheduled(rootFiber));
-}
-function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
-  if (3 === sourceFiber.tag)
-    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
-  else
-    for (; null !== nearestMountedAncestor; ) {
-      if (3 === nearestMountedAncestor.tag) {
-        captureCommitPhaseErrorOnRoot(
-          nearestMountedAncestor,
-          sourceFiber,
-          error
-        );
-        break;
-      } else if (1 === nearestMountedAncestor.tag) {
-        var instance = nearestMountedAncestor.stateNode;
+        didTimeout = root.current.alternate;
         if (
-          "function" ===
-            typeof nearestMountedAncestor.type.getDerivedStateFromError ||
-          ("function" === typeof instance.componentDidCatch &&
-            (null === legacyErrorBoundariesThatAlreadyFailed ||
-              !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
+          renderWasConcurrent &&
+          !isRenderConsistentWithExternalStores(didTimeout)
         ) {
-          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
-          sourceFiber = createClassErrorUpdate(
-            nearestMountedAncestor,
-            sourceFiber,
-            2
-          );
-          nearestMountedAncestor = enqueueUpdate(
-            nearestMountedAncestor,
-            sourceFiber,
-            2
-          );
-          null !== nearestMountedAncestor &&
-            (markRootUpdated(nearestMountedAncestor, 2),
-            ensureRootIsScheduled(nearestMountedAncestor));
-          break;
+          exitStatus = renderRootSync(root, lanes);
+          renderWasConcurrent = !1;
+          continue;
         }
-      }
-      nearestMountedAncestor = nearestMountedAncestor.return;
-    }
-}
-function attachPingListener(root, wakeable, lanes) {
-  var pingCache = root.pingCache;
-  if (null === pingCache) {
-    pingCache = root.pingCache = new PossiblyWeakMap();
-    var threadIDs = new Set();
-    pingCache.set(wakeable, threadIDs);
-  } else
-    (threadIDs = pingCache.get(wakeable)),
-      void 0 === threadIDs &&
-        ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs));
-  threadIDs.has(lanes) ||
-    ((workInProgressRootDidAttachPingListener = !0),
-    threadIDs.add(lanes),
-    (root = pingSuspendedRoot.bind(null, root, wakeable, lanes)),
-    wakeable.then(root, root));
-}
-function pingSuspendedRoot(root, wakeable, pingedLanes) {
-  var pingCache = root.pingCache;
-  null !== pingCache && pingCache.delete(wakeable);
-  root.pingedLanes |= root.suspendedLanes & pingedLanes;
-  workInProgressRoot === root &&
-    (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&
-    (4 === workInProgressRootExitStatus ||
-    (3 === workInProgressRootExitStatus &&
-      (workInProgressRootRenderLanes & 62914560) ===
-        workInProgressRootRenderLanes &&
-      300 > now() - globalMostRecentFallbackTime)
-      ? 0 === (executionContext & 2) && prepareFreshStack(root, 0)
-      : (workInProgressRootPingedLanes |= pingedLanes));
+        if (2 === exitStatus) {
+          renderWasConcurrent = lanes;
+          var errorRetryLanes = getLanesToRetrySynchronouslyOnError(
+            root,
+            renderWasConcurrent
+          );
+          0 !== errorRetryLanes &&
+            ((lanes = errorRetryLanes),
+            (exitStatus = recoverFromConcurrentError(
+              root,
+              renderWasConcurrent,
+              errorRetryLanes
+            )));
+        }
+        if (1 === exitStatus)
+          throw (
+            ((originalCallbackNode = workInProgressRootFatalError),
+            prepareFreshStack(root, 0),
+            markRootSuspended(root, lanes, 0),
+            ensureRootIsScheduled(root),
+            originalCallbackNode)
+          );
+        root.finishedWork = didTimeout;
+        root.finishedLanes = lanes;
+        a: {
+          renderWasConcurrent = root;
+          switch (exitStatus) {
+            case 0:
+            case 1:
+              throw Error("Root did not complete. This is a bug in React.");
+            case 4:
+              if ((lanes & 4194176) === lanes) {
+                markRootSuspended(
+                  renderWasConcurrent,
+                  lanes,
+                  workInProgressDeferredLane
+                );
+                break a;
+              }
+              break;
+            case 2:
+            case 3:
+            case 5:
+              break;
+            default:
+              throw Error("Unknown root exit status.");
+          }
+          if (
+            (lanes & 62914560) === lanes &&
+            3 === exitStatus &&
+            ((exitStatus = globalMostRecentFallbackTime + 300 - now()),
+            10 < exitStatus)
+          ) {
+            markRootSuspended(
+              renderWasConcurrent,
+              lanes,
+              workInProgressDeferredLane
+            );
+            if (0 !== getNextLanes(renderWasConcurrent, 0)) break a;
+            renderWasConcurrent.timeoutHandle = scheduleTimeout(
+              commitRootWhenReady.bind(
+                null,
+                renderWasConcurrent,
+                didTimeout,
+                workInProgressRootRecoverableErrors,
+                workInProgressTransitions,
+                workInProgressRootDidIncludeRecursiveRenderUpdate,
+                lanes,
+                workInProgressDeferredLane
+              ),
+              exitStatus
+            );
+            break a;
+          }
+          commitRootWhenReady(
+            renderWasConcurrent,
+            didTimeout,
+            workInProgressRootRecoverableErrors,
+            workInProgressTransitions,
+            workInProgressRootDidIncludeRecursiveRenderUpdate,
+            lanes,
+            workInProgressDeferredLane
+          );
+        }
+      }
+      break;
+    } while (1);
+  }
   ensureRootIsScheduled(root);
+  scheduleTaskForRootDuringMicrotask(root, now());
+  root =
+    root.callbackNode === originalCallbackNode
+      ? performConcurrentWorkOnRoot.bind(null, root)
+      : null;
+  return root;
 }
-function retryTimedOutBoundary(boundaryFiber, retryLane) {
-  0 === retryLane &&
-    (retryLane = 0 === (boundaryFiber.mode & 1) ? 2 : claimNextRetryLane());
-  boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
-  null !== boundaryFiber &&
-    (markRootUpdated(boundaryFiber, retryLane),
-    ensureRootIsScheduled(boundaryFiber));
-}
-function retryDehydratedSuspenseBoundary(boundaryFiber) {
-  var suspenseState = boundaryFiber.memoizedState,
-    retryLane = 0;
-  null !== suspenseState && (retryLane = suspenseState.retryLane);
-  retryTimedOutBoundary(boundaryFiber, retryLane);
-}
-function resolveRetryWakeable(boundaryFiber, wakeable) {
-  var retryLane = 0;
-  switch (boundaryFiber.tag) {
-    case 13:
-      var retryCache = boundaryFiber.stateNode;
-      var suspenseState = boundaryFiber.memoizedState;
-      null !== suspenseState && (retryLane = suspenseState.retryLane);
-      break;
-    case 19:
-      retryCache = boundaryFiber.stateNode;
-      break;
-    case 22:
-      retryCache = boundaryFiber.stateNode._retryCache;
-      break;
-    default:
-      throw Error(
-        "Pinged unknown suspense boundary type. This is probably a bug in React."
+function recoverFromConcurrentError(
+  root,
+  originallyAttemptedLanes,
+  errorRetryLanes
+) {
+  var errorsFromFirstAttempt = workInProgressRootConcurrentErrors,
+    JSCompiler_inline_result;
+  (JSCompiler_inline_result = root.current.memoizedState.isDehydrated) &&
+    (prepareFreshStack(root, errorRetryLanes).flags |= 256);
+  errorRetryLanes = renderRootSync(root, errorRetryLanes);
+  if (2 !== errorRetryLanes) {
+    if (workInProgressRootDidAttachPingListener && !JSCompiler_inline_result)
+      return (
+        (root.errorRecoveryDisabledLanes |= originallyAttemptedLanes),
+        (workInProgressRootInterleavedUpdatedLanes |= originallyAttemptedLanes),
+        4
       );
+    root = workInProgressRootRecoverableErrors;
+    workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
+    null !== root && queueRecoverableErrors(root);
   }
-  null !== retryCache && retryCache.delete(wakeable);
-  retryTimedOutBoundary(boundaryFiber, retryLane);
+  return errorRetryLanes;
 }
-var beginWork;
-beginWork = function (current, workInProgress, renderLanes) {
-  if (null !== current)
-    if (
-      current.memoizedProps !== workInProgress.pendingProps ||
-      didPerformWorkStackCursor.current
-    )
-      didReceiveUpdate = !0;
-    else {
+function queueRecoverableErrors(errors) {
+  null === workInProgressRootRecoverableErrors
+    ? (workInProgressRootRecoverableErrors = errors)
+    : workInProgressRootRecoverableErrors.push.apply(
+        workInProgressRootRecoverableErrors,
+        errors
+      );
+}
+function commitRootWhenReady(
+  root,
+  finishedWork,
+  recoverableErrors,
+  transitions,
+  didIncludeRenderPhaseUpdate,
+  lanes,
+  spawnedLane
+) {
+  0 === (lanes & 42) && accumulateSuspenseyCommitOnFiber(finishedWork);
+  commitRoot(
+    root,
+    recoverableErrors,
+    transitions,
+    didIncludeRenderPhaseUpdate,
+    spawnedLane
+  );
+}
+function isRenderConsistentWithExternalStores(finishedWork) {
+  for (var node = finishedWork; ; ) {
+    if (node.flags & 16384) {
+      var updateQueue = node.updateQueue;
       if (
-        0 === (current.lanes & renderLanes) &&
-        0 === (workInProgress.flags & 128)
+        null !== updateQueue &&
+        ((updateQueue = updateQueue.stores), null !== updateQueue)
       )
-        return (
-          (didReceiveUpdate = !1),
-          attemptEarlyBailoutIfNoScheduledUpdate(
-            current,
-            workInProgress,
-            renderLanes
-          )
-        );
-      didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;
+        for (var i = 0; i < updateQueue.length; i++) {
+          var check = updateQueue[i],
+            getSnapshot = check.getSnapshot;
+          check = check.value;
+          try {
+            if (!objectIs(getSnapshot(), check)) return !1;
+          } catch (error) {
+            return !1;
+          }
+        }
     }
-  else didReceiveUpdate = !1;
-  workInProgress.lanes = 0;
-  switch (workInProgress.tag) {
-    case 2:
-      var Component = workInProgress.type;
-      resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress);
-      current = workInProgress.pendingProps;
-      var context = getMaskedContext(
-        workInProgress,
-        contextStackCursor$1.current
-      );
-      prepareToReadContext(workInProgress, renderLanes);
-      context = renderWithHooks(
-        null,
-        workInProgress,
-        Component,
-        current,
-        context,
-        renderLanes
-      );
-      workInProgress.flags |= 1;
-      if (
-        "object" === typeof context &&
-        null !== context &&
-        "function" === typeof context.render &&
-        void 0 === context.$$typeof
-      ) {
-        workInProgress.tag = 1;
-        workInProgress.memoizedState = null;
-        workInProgress.updateQueue = null;
-        if (isContextProvider(Component)) {
-          var hasContext = !0;
-          pushContextProvider(workInProgress);
-        } else hasContext = !1;
-        workInProgress.memoizedState =
-          null !== context.state && void 0 !== context.state
-            ? context.state
-            : null;
-        initializeUpdateQueue(workInProgress);
-        context.updater = classComponentUpdater;
-        workInProgress.stateNode = context;
-        context._reactInternals = workInProgress;
-        mountClassInstance(workInProgress, Component, current, renderLanes);
-        workInProgress = finishClassComponent(
-          null,
-          workInProgress,
-          Component,
-          !0,
-          hasContext,
-          renderLanes
-        );
-      } else
-        (workInProgress.tag = 0),
-          reconcileChildren(null, workInProgress, context, renderLanes),
-          (workInProgress = workInProgress.child);
-      return workInProgress;
-    case 16:
-      Component = workInProgress.elementType;
-      a: {
-        resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress);
-        current = workInProgress.pendingProps;
-        context = Component._init;
-        Component = context(Component._payload);
-        workInProgress.type = Component;
-        context = workInProgress.tag = resolveLazyComponentTag(Component);
-        current = resolveDefaultProps(Component, current);
-        switch (context) {
-          case 0:
-            workInProgress = updateFunctionComponent(
-              null,
-              workInProgress,
-              Component,
-              current,
-              renderLanes
-            );
+    updateQueue = node.child;
+    if (node.subtreeFlags & 16384 && null !== updateQueue)
+      (updateQueue.return = node), (node = updateQueue);
+    else {
+      if (node === finishedWork) break;
+      for (; null === node.sibling; ) {
+        if (null === node.return || node.return === finishedWork) return !0;
+        node = node.return;
+      }
+      node.sibling.return = node.return;
+      node = node.sibling;
+    }
+  }
+  return !0;
+}
+function markRootSuspended(root, suspendedLanes, spawnedLane) {
+  suspendedLanes &= ~workInProgressRootPingedLanes;
+  suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
+  root.suspendedLanes |= suspendedLanes;
+  root.pingedLanes &= ~suspendedLanes;
+  for (
+    var expirationTimes = root.expirationTimes, lanes = suspendedLanes;
+    0 < lanes;
+
+  ) {
+    var index$4 = 31 - clz32(lanes),
+      lane = 1 << index$4;
+    expirationTimes[index$4] = -1;
+    lanes &= ~lane;
+  }
+  0 !== spawnedLane &&
+    markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
+}
+function resetWorkInProgressStack() {
+  if (null !== workInProgress) {
+    if (0 === workInProgressSuspendedReason)
+      var interruptedWork = workInProgress.return;
+    else
+      (interruptedWork = workInProgress),
+        resetContextDependencies(),
+        resetHooksOnUnwind(interruptedWork),
+        (thenableState$1 = null),
+        (thenableIndexCounter$1 = 0),
+        (interruptedWork = workInProgress);
+    for (; null !== interruptedWork; )
+      unwindInterruptedWork(interruptedWork.alternate, interruptedWork),
+        (interruptedWork = interruptedWork.return);
+    workInProgress = null;
+  }
+}
+function prepareFreshStack(root, lanes) {
+  root.finishedWork = null;
+  root.finishedLanes = 0;
+  var timeoutHandle = root.timeoutHandle;
+  -1 !== timeoutHandle &&
+    ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle));
+  timeoutHandle = root.cancelPendingCommit;
+  null !== timeoutHandle &&
+    ((root.cancelPendingCommit = null), timeoutHandle());
+  resetWorkInProgressStack();
+  workInProgressRoot = root;
+  workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
+  workInProgressRootRenderLanes = lanes;
+  workInProgressSuspendedReason = 0;
+  workInProgressThrownValue = null;
+  workInProgressRootDidAttachPingListener = !1;
+  workInProgressRootExitStatus = 0;
+  workInProgressRootFatalError = null;
+  workInProgressDeferredLane =
+    workInProgressRootPingedLanes =
+    workInProgressRootInterleavedUpdatedLanes =
+    workInProgressRootSkippedLanes =
+      0;
+  workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors =
+    null;
+  workInProgressRootDidIncludeRecursiveRenderUpdate = !1;
+  0 !== (lanes & 8) && (lanes |= lanes & 32);
+  var allEntangledLanes = root.entangledLanes;
+  if (0 !== allEntangledLanes)
+    for (
+      root = root.entanglements, allEntangledLanes &= lanes;
+      0 < allEntangledLanes;
+
+    ) {
+      var index$2 = 31 - clz32(allEntangledLanes),
+        lane = 1 << index$2;
+      lanes |= root[index$2];
+      allEntangledLanes &= ~lane;
+    }
+  entangledRenderLanes = lanes;
+  finishQueueingConcurrentUpdates();
+  return timeoutHandle;
+}
+function handleThrow(root, thrownValue) {
+  currentlyRenderingFiber$1 = null;
+  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
+  ReactCurrentOwner.current = null;
+  thrownValue === SuspenseException
+    ? ((thrownValue = getSuspendedThenable()),
+      (root = suspenseHandlerStackCursor.current),
+      (workInProgressSuspendedReason =
+        (null !== root &&
+          ((workInProgressRootRenderLanes & 4194176) ===
+          workInProgressRootRenderLanes
+            ? null !== shellBoundary
+            : ((workInProgressRootRenderLanes & 62914560) !==
+                workInProgressRootRenderLanes &&
+                0 === (workInProgressRootRenderLanes & 536870912)) ||
+              root !== shellBoundary)) ||
+        0 !== (workInProgressRootSkippedLanes & 134217727) ||
+        0 !== (workInProgressRootInterleavedUpdatedLanes & 134217727)
+          ? 3
+          : 2))
+    : thrownValue === SuspenseyCommitException
+    ? ((thrownValue = getSuspendedThenable()),
+      (workInProgressSuspendedReason = 4))
+    : (workInProgressSuspendedReason =
+        thrownValue === SelectiveHydrationException
+          ? 8
+          : null !== thrownValue &&
+            "object" === typeof thrownValue &&
+            "function" === typeof thrownValue.then
+          ? 6
+          : 1);
+  workInProgressThrownValue = thrownValue;
+  null === workInProgress &&
+    ((workInProgressRootExitStatus = 1),
+    (workInProgressRootFatalError = thrownValue));
+}
+function pushDispatcher() {
+  var prevDispatcher = ReactCurrentDispatcher.current;
+  ReactCurrentDispatcher.current = ContextOnlyDispatcher;
+  return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
+}
+function renderDidSuspendDelayIfPossible() {
+  workInProgressRootExitStatus = 4;
+  (0 === (workInProgressRootSkippedLanes & 134217727) &&
+    0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||
+    null === workInProgressRoot ||
+    markRootSuspended(
+      workInProgressRoot,
+      workInProgressRootRenderLanes,
+      workInProgressDeferredLane
+    );
+}
+function renderRootSync(root, lanes) {
+  var prevExecutionContext = executionContext;
+  executionContext |= 2;
+  var prevDispatcher = pushDispatcher();
+  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes)
+    (workInProgressTransitions = null), prepareFreshStack(root, lanes);
+  lanes = !1;
+  a: do
+    try {
+      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
+        var unitOfWork = workInProgress,
+          thrownValue = workInProgressThrownValue;
+        switch (workInProgressSuspendedReason) {
+          case 8:
+            resetWorkInProgressStack();
+            workInProgressRootExitStatus = 6;
             break a;
+          case 3:
+          case 2:
+            lanes ||
+              null !== suspenseHandlerStackCursor.current ||
+              (lanes = !0);
+          default:
+            (workInProgressSuspendedReason = 0),
+              (workInProgressThrownValue = null),
+              throwAndUnwindWorkLoop(root, unitOfWork, thrownValue);
+        }
+      }
+      workLoopSync();
+      break;
+    } catch (thrownValue$88) {
+      handleThrow(root, thrownValue$88);
+    }
+  while (1);
+  lanes && root.shellSuspendCounter++;
+  resetContextDependencies();
+  executionContext = prevExecutionContext;
+  ReactCurrentDispatcher.current = prevDispatcher;
+  if (null !== workInProgress)
+    throw Error(
+      "Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue."
+    );
+  workInProgressRoot = null;
+  workInProgressRootRenderLanes = 0;
+  finishQueueingConcurrentUpdates();
+  return workInProgressRootExitStatus;
+}
+function workLoopSync() {
+  for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
+}
+function renderRootConcurrent(root, lanes) {
+  var prevExecutionContext = executionContext;
+  executionContext |= 2;
+  var prevDispatcher = pushDispatcher();
+  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes)
+    (workInProgressTransitions = null),
+      (workInProgressRootRenderTargetTime = now() + 500),
+      prepareFreshStack(root, lanes);
+  a: do
+    try {
+      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
+        lanes = workInProgress;
+        var thrownValue = workInProgressThrownValue;
+        b: switch (workInProgressSuspendedReason) {
           case 1:
-            workInProgress = updateClassComponent(
-              null,
-              workInProgress,
-              Component,
-              current,
-              renderLanes
-            );
+            workInProgressSuspendedReason = 0;
+            workInProgressThrownValue = null;
+            throwAndUnwindWorkLoop(root, lanes, thrownValue);
+            break;
+          case 2:
+            if (isThenableResolved(thrownValue)) {
+              workInProgressSuspendedReason = 0;
+              workInProgressThrownValue = null;
+              replaySuspendedUnitOfWork(lanes);
+              break;
+            }
+            lanes = function () {
+              2 === workInProgressSuspendedReason &&
+                workInProgressRoot === root &&
+                (workInProgressSuspendedReason = 7);
+              ensureRootIsScheduled(root);
+            };
+            thrownValue.then(lanes, lanes);
             break a;
-          case 11:
-            workInProgress = updateForwardRef(
-              null,
-              workInProgress,
-              Component,
-              current,
-              renderLanes
-            );
+          case 3:
+            workInProgressSuspendedReason = 7;
             break a;
-          case 14:
-            workInProgress = updateMemoComponent(
-              null,
-              workInProgress,
-              Component,
-              resolveDefaultProps(Component.type, current),
-              renderLanes
-            );
+          case 4:
+            workInProgressSuspendedReason = 5;
             break a;
+          case 7:
+            isThenableResolved(thrownValue)
+              ? ((workInProgressSuspendedReason = 0),
+                (workInProgressThrownValue = null),
+                replaySuspendedUnitOfWork(lanes))
+              : ((workInProgressSuspendedReason = 0),
+                (workInProgressThrownValue = null),
+                throwAndUnwindWorkLoop(root, lanes, thrownValue));
+            break;
+          case 5:
+            switch (workInProgress.tag) {
+              case 5:
+              case 26:
+              case 27:
+                lanes = workInProgress;
+                workInProgressSuspendedReason = 0;
+                workInProgressThrownValue = null;
+                var sibling = lanes.sibling;
+                if (null !== sibling) workInProgress = sibling;
+                else {
+                  var returnFiber = lanes.return;
+                  null !== returnFiber
+                    ? ((workInProgress = returnFiber),
+                      completeUnitOfWork(returnFiber))
+                    : (workInProgress = null);
+                }
+                break b;
+            }
+            workInProgressSuspendedReason = 0;
+            workInProgressThrownValue = null;
+            throwAndUnwindWorkLoop(root, lanes, thrownValue);
+            break;
+          case 6:
+            workInProgressSuspendedReason = 0;
+            workInProgressThrownValue = null;
+            throwAndUnwindWorkLoop(root, lanes, thrownValue);
+            break;
+          case 8:
+            resetWorkInProgressStack();
+            workInProgressRootExitStatus = 6;
+            break a;
+          default:
+            throw Error("Unexpected SuspendedReason. This is a bug in React.");
         }
-        throw Error(
-          "Element type is invalid. Received a promise that resolves to: " +
-            Component +
-            ". Lazy element type must resolve to a class or function."
-        );
       }
-      return workInProgress;
+      workLoopConcurrent();
+      break;
+    } catch (thrownValue$90) {
+      handleThrow(root, thrownValue$90);
+    }
+  while (1);
+  resetContextDependencies();
+  ReactCurrentDispatcher.current = prevDispatcher;
+  executionContext = prevExecutionContext;
+  if (null !== workInProgress) return 0;
+  workInProgressRoot = null;
+  workInProgressRootRenderLanes = 0;
+  finishQueueingConcurrentUpdates();
+  return workInProgressRootExitStatus;
+}
+function workLoopConcurrent() {
+  for (; null !== workInProgress && !shouldYield(); )
+    performUnitOfWork(workInProgress);
+}
+function performUnitOfWork(unitOfWork) {
+  var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
+  unitOfWork.memoizedProps = unitOfWork.pendingProps;
+  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
+  ReactCurrentOwner.current = null;
+}
+function replaySuspendedUnitOfWork(unitOfWork) {
+  var current = unitOfWork.alternate;
+  switch (unitOfWork.tag) {
+    case 2:
+      unitOfWork.tag = 0;
+    case 15:
     case 0:
-      return (
-        (Component = workInProgress.type),
-        (context = workInProgress.pendingProps),
-        (context =
-          workInProgress.elementType === Component
-            ? context
-            : resolveDefaultProps(Component, context)),
-        updateFunctionComponent(
-          current,
-          workInProgress,
-          Component,
-          context,
-          renderLanes
-        )
+      var Component = unitOfWork.type,
+        unresolvedProps = unitOfWork.pendingProps;
+      unresolvedProps =
+        unitOfWork.elementType === Component
+          ? unresolvedProps
+          : resolveDefaultProps(Component, unresolvedProps);
+      current = replayFunctionComponent(
+        current,
+        unitOfWork,
+        unresolvedProps,
+        Component,
+        void 0,
+        workInProgressRootRenderLanes
       );
-    case 1:
-      return (
-        (Component = workInProgress.type),
-        (context = workInProgress.pendingProps),
-        (context =
-          workInProgress.elementType === Component
-            ? context
-            : resolveDefaultProps(Component, context)),
-        updateClassComponent(
-          current,
-          workInProgress,
-          Component,
-          context,
-          renderLanes
-        )
+      break;
+    case 11:
+      Component = unitOfWork.type.render;
+      unresolvedProps = unitOfWork.pendingProps;
+      unresolvedProps =
+        unitOfWork.elementType === Component
+          ? unresolvedProps
+          : resolveDefaultProps(Component, unresolvedProps);
+      current = replayFunctionComponent(
+        current,
+        unitOfWork,
+        unresolvedProps,
+        Component,
+        unitOfWork.ref,
+        workInProgressRootRenderLanes
       );
-    case 3:
-      pushHostRootContext(workInProgress);
-      if (null === current)
-        throw Error("Should have a current fiber. This is a bug in React.");
-      context = workInProgress.pendingProps;
-      Component = workInProgress.memoizedState.element;
-      cloneUpdateQueue(current, workInProgress);
-      processUpdateQueue(workInProgress, context, null, renderLanes);
-      context = workInProgress.memoizedState.element;
-      context === Component
-        ? (workInProgress = bailoutOnAlreadyFinishedWork(
-            current,
-            workInProgress,
-            renderLanes
-          ))
-        : (reconcileChildren(current, workInProgress, context, renderLanes),
-          (workInProgress = workInProgress.child));
-      return workInProgress;
-    case 26:
-    case 27:
+      break;
     case 5:
-      return (
-        pushHostContext(workInProgress),
-        (Component = workInProgress.pendingProps.children),
-        markRef$1(current, workInProgress),
-        reconcileChildren(current, workInProgress, Component, renderLanes),
-        workInProgress.child
+      resetHooksOnUnwind(unitOfWork);
+    default:
+      unwindInterruptedWork(current, unitOfWork),
+        (unitOfWork = workInProgress =
+          resetWorkInProgress(unitOfWork, entangledRenderLanes)),
+        (current = beginWork(current, unitOfWork, entangledRenderLanes));
+  }
+  unitOfWork.memoizedProps = unitOfWork.pendingProps;
+  null === current
+    ? completeUnitOfWork(unitOfWork)
+    : (workInProgress = current);
+  ReactCurrentOwner.current = null;
+}
+function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue) {
+  resetContextDependencies();
+  resetHooksOnUnwind(unitOfWork);
+  thenableState$1 = null;
+  thenableIndexCounter$1 = 0;
+  var returnFiber = unitOfWork.return;
+  try {
+    if (
+      throwException(
+        root,
+        returnFiber,
+        unitOfWork,
+        thrownValue,
+        workInProgressRootRenderLanes
+      )
+    ) {
+      workInProgressRootExitStatus = 1;
+      workInProgressRootFatalError = thrownValue;
+      workInProgress = null;
+      return;
+    }
+  } catch (error) {
+    if (null !== returnFiber) throw ((workInProgress = returnFiber), error);
+    workInProgressRootExitStatus = 1;
+    workInProgressRootFatalError = thrownValue;
+    workInProgress = null;
+    return;
+  }
+  if (unitOfWork.flags & 32768)
+    a: {
+      root = unitOfWork;
+      do {
+        unitOfWork = unwindWork(root.alternate, root);
+        if (null !== unitOfWork) {
+          unitOfWork.flags &= 32767;
+          workInProgress = unitOfWork;
+          break a;
+        }
+        root = root.return;
+        null !== root &&
+          ((root.flags |= 32768),
+          (root.subtreeFlags = 0),
+          (root.deletions = null));
+        workInProgress = root;
+      } while (null !== root);
+      workInProgressRootExitStatus = 6;
+      workInProgress = null;
+    }
+  else completeUnitOfWork(unitOfWork);
+}
+function completeUnitOfWork(unitOfWork) {
+  var completedWork = unitOfWork;
+  do {
+    unitOfWork = completedWork.return;
+    var next = completeWork(
+      completedWork.alternate,
+      completedWork,
+      entangledRenderLanes
+    );
+    if (null !== next) {
+      workInProgress = next;
+      return;
+    }
+    completedWork = completedWork.sibling;
+    if (null !== completedWork) {
+      workInProgress = completedWork;
+      return;
+    }
+    workInProgress = completedWork = unitOfWork;
+  } while (null !== completedWork);
+  0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
+}
+function commitRoot(
+  root,
+  recoverableErrors,
+  transitions,
+  didIncludeRenderPhaseUpdate,
+  spawnedLane
+) {
+  var previousUpdateLanePriority = currentUpdatePriority,
+    prevTransition = ReactCurrentBatchConfig.transition;
+  try {
+    (ReactCurrentBatchConfig.transition = null),
+      (currentUpdatePriority = 2),
+      commitRootImpl(
+        root,
+        recoverableErrors,
+        transitions,
+        didIncludeRenderPhaseUpdate,
+        previousUpdateLanePriority,
+        spawnedLane
       );
-    case 6:
+  } finally {
+    (ReactCurrentBatchConfig.transition = prevTransition),
+      (currentUpdatePriority = previousUpdateLanePriority);
+  }
+  return null;
+}
+function commitRootImpl(
+  root,
+  recoverableErrors,
+  transitions,
+  didIncludeRenderPhaseUpdate,
+  renderPriorityLevel,
+  spawnedLane
+) {
+  do flushPassiveEffects();
+  while (null !== rootWithPendingPassiveEffects);
+  if (0 !== (executionContext & 6))
+    throw Error("Should not already be working.");
+  didIncludeRenderPhaseUpdate = root.finishedWork;
+  transitions = root.finishedLanes;
+  if (null === didIncludeRenderPhaseUpdate) return null;
+  root.finishedWork = null;
+  root.finishedLanes = 0;
+  if (didIncludeRenderPhaseUpdate === root.current)
+    throw Error(
+      "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
+    );
+  root.callbackNode = null;
+  root.callbackPriority = 0;
+  root.cancelPendingCommit = null;
+  var remainingLanes =
+    didIncludeRenderPhaseUpdate.lanes | didIncludeRenderPhaseUpdate.childLanes;
+  remainingLanes |= concurrentlyUpdatedLanes;
+  markRootFinished(root, remainingLanes, spawnedLane);
+  root === workInProgressRoot &&
+    ((workInProgress = workInProgressRoot = null),
+    (workInProgressRootRenderLanes = 0));
+  (0 === (didIncludeRenderPhaseUpdate.subtreeFlags & 10256) &&
+    0 === (didIncludeRenderPhaseUpdate.flags & 10256)) ||
+    rootDoesHavePassiveEffects ||
+    ((rootDoesHavePassiveEffects = !0),
+    scheduleCallback(NormalPriority, function () {
+      flushPassiveEffects();
       return null;
-    case 13:
-      return updateSuspenseComponent(current, workInProgress, renderLanes);
-    case 4:
-      return (
-        pushHostContainer(
-          workInProgress,
-          workInProgress.stateNode.containerInfo
-        ),
-        (Component = workInProgress.pendingProps),
-        null === current
-          ? (workInProgress.child = reconcileChildFibers(
-              workInProgress,
-              null,
-              Component,
-              renderLanes
-            ))
-          : reconcileChildren(current, workInProgress, Component, renderLanes),
-        workInProgress.child
-      );
-    case 11:
-      return (
-        (Component = workInProgress.type),
-        (context = workInProgress.pendingProps),
-        (context =
-          workInProgress.elementType === Component
-            ? context
-            : resolveDefaultProps(Component, context)),
-        updateForwardRef(
-          current,
-          workInProgress,
-          Component,
-          context,
-          renderLanes
-        )
-      );
-    case 7:
-      return (
-        reconcileChildren(
-          current,
-          workInProgress,
-          workInProgress.pendingProps,
-          renderLanes
-        ),
-        workInProgress.child
-      );
-    case 8:
-      return (
-        reconcileChildren(
-          current,
-          workInProgress,
-          workInProgress.pendingProps.children,
-          renderLanes
-        ),
-        workInProgress.child
-      );
-    case 12:
-      return (
-        reconcileChildren(
-          current,
-          workInProgress,
-          workInProgress.pendingProps.children,
-          renderLanes
-        ),
-        workInProgress.child
-      );
-    case 10:
-      a: {
-        Component = workInProgress.type._context;
-        context = workInProgress.pendingProps;
-        hasContext = workInProgress.memoizedProps;
-        var newValue = context.value;
-        push(valueCursor, Component._currentValue2);
-        Component._currentValue2 = newValue;
-        if (null !== hasContext)
-          if (objectIs(hasContext.value, newValue)) {
-            if (
-              hasContext.children === context.children &&
-              !didPerformWorkStackCursor.current
-            ) {
-              workInProgress = bailoutOnAlreadyFinishedWork(
-                current,
-                workInProgress,
-                renderLanes
-              );
-              break a;
-            }
-          } else
-            for (
-              hasContext = workInProgress.child,
-                null !== hasContext && (hasContext.return = workInProgress);
-              null !== hasContext;
-
-            ) {
-              var list = hasContext.dependencies;
-              if (null !== list) {
-                newValue = hasContext.child;
-                for (
-                  var dependency = list.firstContext;
-                  null !== dependency;
-
-                ) {
-                  if (dependency.context === Component) {
-                    if (1 === hasContext.tag) {
-                      dependency = createUpdate(renderLanes & -renderLanes);
-                      dependency.tag = 2;
-                      var updateQueue = hasContext.updateQueue;
-                      if (null !== updateQueue) {
-                        updateQueue = updateQueue.shared;
-                        var pending = updateQueue.pending;
-                        null === pending
-                          ? (dependency.next = dependency)
-                          : ((dependency.next = pending.next),
-                            (pending.next = dependency));
-                        updateQueue.pending = dependency;
-                      }
-                    }
-                    hasContext.lanes |= renderLanes;
-                    dependency = hasContext.alternate;
-                    null !== dependency && (dependency.lanes |= renderLanes);
-                    scheduleContextWorkOnParentPath(
-                      hasContext.return,
-                      renderLanes,
-                      workInProgress
-                    );
-                    list.lanes |= renderLanes;
-                    break;
-                  }
-                  dependency = dependency.next;
-                }
-              } else if (10 === hasContext.tag)
-                newValue =
-                  hasContext.type === workInProgress.type
-                    ? null
-                    : hasContext.child;
-              else if (18 === hasContext.tag) {
-                newValue = hasContext.return;
-                if (null === newValue)
-                  throw Error(
-                    "We just came from a parent so we must have had a parent. This is a bug in React."
-                  );
-                newValue.lanes |= renderLanes;
-                list = newValue.alternate;
-                null !== list && (list.lanes |= renderLanes);
-                scheduleContextWorkOnParentPath(
-                  newValue,
-                  renderLanes,
-                  workInProgress
-                );
-                newValue = hasContext.sibling;
-              } else newValue = hasContext.child;
-              if (null !== newValue) newValue.return = hasContext;
-              else
-                for (newValue = hasContext; null !== newValue; ) {
-                  if (newValue === workInProgress) {
-                    newValue = null;
-                    break;
-                  }
-                  hasContext = newValue.sibling;
-                  if (null !== hasContext) {
-                    hasContext.return = newValue.return;
-                    newValue = hasContext;
-                    break;
-                  }
-                  newValue = newValue.return;
-                }
-              hasContext = newValue;
-            }
-        reconcileChildren(
-          current,
-          workInProgress,
-          context.children,
-          renderLanes
+    }));
+  spawnedLane = 0 !== (didIncludeRenderPhaseUpdate.flags & 15990);
+  if (0 !== (didIncludeRenderPhaseUpdate.subtreeFlags & 15990) || spawnedLane) {
+    spawnedLane = ReactCurrentBatchConfig.transition;
+    ReactCurrentBatchConfig.transition = null;
+    remainingLanes = currentUpdatePriority;
+    currentUpdatePriority = 2;
+    var prevExecutionContext = executionContext;
+    executionContext |= 4;
+    ReactCurrentOwner.current = null;
+    commitBeforeMutationEffects(root, didIncludeRenderPhaseUpdate);
+    commitMutationEffectsOnFiber(didIncludeRenderPhaseUpdate, root);
+    root.current = didIncludeRenderPhaseUpdate;
+    commitLayoutEffectOnFiber(
+      root,
+      didIncludeRenderPhaseUpdate.alternate,
+      didIncludeRenderPhaseUpdate
+    );
+    requestPaint();
+    executionContext = prevExecutionContext;
+    currentUpdatePriority = remainingLanes;
+    ReactCurrentBatchConfig.transition = spawnedLane;
+  } else root.current = didIncludeRenderPhaseUpdate;
+  rootDoesHavePassiveEffects &&
+    ((rootDoesHavePassiveEffects = !1),
+    (rootWithPendingPassiveEffects = root),
+    (pendingPassiveEffectsLanes = transitions));
+  remainingLanes = root.pendingLanes;
+  0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
+  onCommitRoot(didIncludeRenderPhaseUpdate.stateNode, renderPriorityLevel);
+  ensureRootIsScheduled(root);
+  if (null !== recoverableErrors)
+    for (
+      renderPriorityLevel = root.onRecoverableError,
+        didIncludeRenderPhaseUpdate = 0;
+      didIncludeRenderPhaseUpdate < recoverableErrors.length;
+      didIncludeRenderPhaseUpdate++
+    )
+      (spawnedLane = recoverableErrors[didIncludeRenderPhaseUpdate]),
+        (remainingLanes = {
+          digest: spawnedLane.digest,
+          componentStack: spawnedLane.stack
+        }),
+        renderPriorityLevel(spawnedLane.value, remainingLanes);
+  if (hasUncaughtError)
+    throw (
+      ((hasUncaughtError = !1),
+      (root = firstUncaughtError),
+      (firstUncaughtError = null),
+      root)
+    );
+  0 !== (pendingPassiveEffectsLanes & 3) &&
+    0 !== root.tag &&
+    flushPassiveEffects();
+  remainingLanes = root.pendingLanes;
+  0 !== (transitions & 4194218) && 0 !== (remainingLanes & 42)
+    ? root === rootWithNestedUpdates
+      ? nestedUpdateCount++
+      : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root))
+    : (nestedUpdateCount = 0);
+  flushSyncWorkAcrossRoots_impl(!1);
+  return null;
+}
+function flushPassiveEffects() {
+  if (null !== rootWithPendingPassiveEffects) {
+    var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes),
+      prevTransition = ReactCurrentBatchConfig.transition,
+      previousPriority = currentUpdatePriority;
+    try {
+      ReactCurrentBatchConfig.transition = null;
+      currentUpdatePriority = 32 > renderPriority ? 32 : renderPriority;
+      if (null === rootWithPendingPassiveEffects)
+        var JSCompiler_inline_result = !1;
+      else {
+        renderPriority = rootWithPendingPassiveEffects;
+        rootWithPendingPassiveEffects = null;
+        pendingPassiveEffectsLanes = 0;
+        if (0 !== (executionContext & 6))
+          throw Error("Cannot flush passive effects while already rendering.");
+        var prevExecutionContext = executionContext;
+        executionContext |= 4;
+        commitPassiveUnmountOnFiber(renderPriority.current);
+        commitPassiveMountOnFiber(renderPriority, renderPriority.current);
+        executionContext = prevExecutionContext;
+        flushSyncWorkAcrossRoots_impl(!1);
+        if (
+          injectedHook &&
+          "function" === typeof injectedHook.onPostCommitFiberRoot
+        )
+          try {
+            injectedHook.onPostCommitFiberRoot(rendererID, renderPriority);
+          } catch (err) {}
+        JSCompiler_inline_result = !0;
+      }
+      return JSCompiler_inline_result;
+    } finally {
+      (currentUpdatePriority = previousPriority),
+        (ReactCurrentBatchConfig.transition = prevTransition);
+    }
+  }
+  return !1;
+}
+function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
+  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
+  sourceFiber = createRootErrorUpdate(rootFiber, sourceFiber, 2);
+  rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
+  null !== rootFiber &&
+    (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
+}
+function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
+  if (3 === sourceFiber.tag)
+    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
+  else
+    for (; null !== nearestMountedAncestor; ) {
+      if (3 === nearestMountedAncestor.tag) {
+        captureCommitPhaseErrorOnRoot(
+          nearestMountedAncestor,
+          sourceFiber,
+          error
         );
-        workInProgress = workInProgress.child;
+        break;
+      } else if (1 === nearestMountedAncestor.tag) {
+        var instance = nearestMountedAncestor.stateNode;
+        if (
+          "function" ===
+            typeof nearestMountedAncestor.type.getDerivedStateFromError ||
+          ("function" === typeof instance.componentDidCatch &&
+            (null === legacyErrorBoundariesThatAlreadyFailed ||
+              !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
+        ) {
+          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
+          sourceFiber = createClassErrorUpdate(
+            nearestMountedAncestor,
+            sourceFiber,
+            2
+          );
+          nearestMountedAncestor = enqueueUpdate(
+            nearestMountedAncestor,
+            sourceFiber,
+            2
+          );
+          null !== nearestMountedAncestor &&
+            (markRootUpdated$1(nearestMountedAncestor, 2),
+            ensureRootIsScheduled(nearestMountedAncestor));
+          break;
+        }
       }
-      return workInProgress;
-    case 9:
-      return (
-        (context = workInProgress.type),
-        (Component = workInProgress.pendingProps.children),
-        prepareToReadContext(workInProgress, renderLanes),
-        (context = readContext(context)),
-        (Component = Component(context)),
-        (workInProgress.flags |= 1),
-        reconcileChildren(current, workInProgress, Component, renderLanes),
-        workInProgress.child
-      );
-    case 14:
-      return (
-        (Component = workInProgress.type),
-        (context = resolveDefaultProps(Component, workInProgress.pendingProps)),
-        (context = resolveDefaultProps(Component.type, context)),
-        updateMemoComponent(
-          current,
-          workInProgress,
-          Component,
-          context,
-          renderLanes
-        )
-      );
-    case 15:
-      return updateSimpleMemoComponent(
-        current,
-        workInProgress,
-        workInProgress.type,
-        workInProgress.pendingProps,
-        renderLanes
-      );
-    case 17:
-      return (
-        (Component = workInProgress.type),
-        (context = workInProgress.pendingProps),
-        (context =
-          workInProgress.elementType === Component
-            ? context
-            : resolveDefaultProps(Component, context)),
-        resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress),
-        (workInProgress.tag = 1),
-        isContextProvider(Component)
-          ? ((current = !0), pushContextProvider(workInProgress))
-          : (current = !1),
-        prepareToReadContext(workInProgress, renderLanes),
-        constructClassInstance(workInProgress, Component, context),
-        mountClassInstance(workInProgress, Component, context, renderLanes),
-        finishClassComponent(
-          null,
-          workInProgress,
-          Component,
-          !0,
-          current,
-          renderLanes
-        )
-      );
+      nearestMountedAncestor = nearestMountedAncestor.return;
+    }
+}
+function attachPingListener(root, wakeable, lanes) {
+  var pingCache = root.pingCache;
+  if (null === pingCache) {
+    pingCache = root.pingCache = new PossiblyWeakMap();
+    var threadIDs = new Set();
+    pingCache.set(wakeable, threadIDs);
+  } else
+    (threadIDs = pingCache.get(wakeable)),
+      void 0 === threadIDs &&
+        ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs));
+  threadIDs.has(lanes) ||
+    ((workInProgressRootDidAttachPingListener = !0),
+    threadIDs.add(lanes),
+    (root = pingSuspendedRoot.bind(null, root, wakeable, lanes)),
+    wakeable.then(root, root));
+}
+function pingSuspendedRoot(root, wakeable, pingedLanes) {
+  var pingCache = root.pingCache;
+  null !== pingCache && pingCache.delete(wakeable);
+  root.pingedLanes |= root.suspendedLanes & pingedLanes;
+  workInProgressRoot === root &&
+    (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&
+    (4 === workInProgressRootExitStatus ||
+    (3 === workInProgressRootExitStatus &&
+      (workInProgressRootRenderLanes & 62914560) ===
+        workInProgressRootRenderLanes &&
+      300 > now() - globalMostRecentFallbackTime)
+      ? 0 === (executionContext & 2) && prepareFreshStack(root, 0)
+      : (workInProgressRootPingedLanes |= pingedLanes));
+  ensureRootIsScheduled(root);
+}
+function retryTimedOutBoundary(boundaryFiber, retryLane) {
+  0 === retryLane &&
+    (retryLane = 0 === (boundaryFiber.mode & 1) ? 2 : claimNextRetryLane());
+  boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
+  null !== boundaryFiber &&
+    (markRootUpdated$1(boundaryFiber, retryLane),
+    ensureRootIsScheduled(boundaryFiber));
+}
+function retryDehydratedSuspenseBoundary(boundaryFiber) {
+  var suspenseState = boundaryFiber.memoizedState,
+    retryLane = 0;
+  null !== suspenseState && (retryLane = suspenseState.retryLane);
+  retryTimedOutBoundary(boundaryFiber, retryLane);
+}
+function resolveRetryWakeable(boundaryFiber, wakeable) {
+  var retryLane = 0;
+  switch (boundaryFiber.tag) {
+    case 13:
+      var retryCache = boundaryFiber.stateNode;
+      var suspenseState = boundaryFiber.memoizedState;
+      null !== suspenseState && (retryLane = suspenseState.retryLane);
+      break;
     case 19:
-      return updateSuspenseListComponent(current, workInProgress, renderLanes);
+      retryCache = boundaryFiber.stateNode;
+      break;
     case 22:
-      return updateOffscreenComponent(current, workInProgress, renderLanes);
+      retryCache = boundaryFiber.stateNode._retryCache;
+      break;
+    default:
+      throw Error(
+        "Pinged unknown suspense boundary type. This is probably a bug in React."
+      );
   }
-  throw Error(
-    "Unknown unit of work tag (" +
-      workInProgress.tag +
-      "). This error is likely caused by a bug in React. Please file an issue."
-  );
-};
+  null !== retryCache && retryCache.delete(wakeable);
+  retryTimedOutBoundary(boundaryFiber, retryLane);
+}
 function scheduleCallback(priorityLevel, callback) {
   return scheduleCallback$2(priorityLevel, callback);
 }
@@ -9061,6 +8765,7 @@ function createFiberFromTypeAndProps(
             case REACT_CONTEXT_TYPE:
               fiberTag = 9;
               break a;
+            case REACT_CONSUMER_TYPE:
             case REACT_FORWARD_REF_TYPE:
               fiberTag = 11;
               break a;
@@ -9214,63 +8919,19 @@ function findHostInstance(component) {
   return null === component ? null : getPublicInstance(component.stateNode);
 }
 function updateContainer(element, container, parentComponent, callback) {
-  var current = container.current,
-    lane = requestUpdateLane(current);
-  a: if (parentComponent) {
-    parentComponent = parentComponent._reactInternals;
-    b: {
-      if (
-        getNearestMountedFiber(parentComponent) !== parentComponent ||
-        1 !== parentComponent.tag
-      )
-        throw Error(
-          "Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue."
-        );
-      var JSCompiler_inline_result = parentComponent;
-      do {
-        switch (JSCompiler_inline_result.tag) {
-          case 3:
-            JSCompiler_inline_result =
-              JSCompiler_inline_result.stateNode.context;
-            break b;
-          case 1:
-            if (isContextProvider(JSCompiler_inline_result.type)) {
-              JSCompiler_inline_result =
-                JSCompiler_inline_result.stateNode
-                  .__reactInternalMemoizedMergedChildContext;
-              break b;
-            }
-        }
-        JSCompiler_inline_result = JSCompiler_inline_result.return;
-      } while (null !== JSCompiler_inline_result);
-      throw Error(
-        "Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue."
-      );
-    }
-    if (1 === parentComponent.tag) {
-      var Component = parentComponent.type;
-      if (isContextProvider(Component)) {
-        parentComponent = processChildContext(
-          parentComponent,
-          Component,
-          JSCompiler_inline_result
-        );
-        break a;
-      }
-    }
-    parentComponent = JSCompiler_inline_result;
-  } else parentComponent = emptyContextObject;
+  parentComponent = container.current;
+  var lane = requestUpdateLane(parentComponent);
   null === container.context
-    ? (container.context = parentComponent)
-    : (container.pendingContext = parentComponent);
+    ? (container.context = emptyContextObject)
+    : (container.pendingContext = emptyContextObject);
   container = createUpdate(lane);
   container.payload = { element: element };
   callback = void 0 === callback ? null : callback;
   null !== callback && (container.callback = callback);
-  element = enqueueUpdate(current, container, lane);
+  element = enqueueUpdate(parentComponent, container, lane);
   null !== element &&
-    (scheduleUpdateOnFiber(element, current, lane),
-    entangleTransitions(element, current, lane));
+    (scheduleUpdateOnFiber(element, parentComponent, lane),
+    entangleTransitions(element, parentComponent, lane));
   return lane;
 }
 function emptyFindFiberByHostInstance() {
@@ -9318,10 +8979,10 @@ batchedUpdatesImpl = function (fn, a) {
   }
 };
 var roots = new Map(),
-  devToolsConfig$jscomp$inline_1055 = {
+  devToolsConfig$jscomp$inline_1031 = {
     findFiberByHostInstance: getInstanceFromNode,
     bundleType: 0,
-    version: "18.3.0-canary-03d6f7cf0-20240209",
+    version: "18.3.0-canary-9372c6311-20240315",
     rendererPackageName: "react-native-renderer",
     rendererConfig: {
       getInspectorDataForInstance: getInspectorDataForInstance,
@@ -9337,11 +8998,11 @@ var roots = new Map(),
       }.bind(null, findNodeHandle)
     }
   };
-var internals$jscomp$inline_1280 = {
-  bundleType: devToolsConfig$jscomp$inline_1055.bundleType,
-  version: devToolsConfig$jscomp$inline_1055.version,
-  rendererPackageName: devToolsConfig$jscomp$inline_1055.rendererPackageName,
-  rendererConfig: devToolsConfig$jscomp$inline_1055.rendererConfig,
+var internals$jscomp$inline_1259 = {
+  bundleType: devToolsConfig$jscomp$inline_1031.bundleType,
+  version: devToolsConfig$jscomp$inline_1031.version,
+  rendererPackageName: devToolsConfig$jscomp$inline_1031.rendererPackageName,
+  rendererConfig: devToolsConfig$jscomp$inline_1031.rendererConfig,
   overrideHookState: null,
   overrideHookStateDeletePath: null,
   overrideHookStateRenamePath: null,
@@ -9357,26 +9018,26 @@ var internals$jscomp$inline_1280 = {
     return null === fiber ? null : fiber.stateNode;
   },
   findFiberByHostInstance:
-    devToolsConfig$jscomp$inline_1055.findFiberByHostInstance ||
+    devToolsConfig$jscomp$inline_1031.findFiberByHostInstance ||
     emptyFindFiberByHostInstance,
   findHostInstancesForRefresh: null,
   scheduleRefresh: null,
   scheduleRoot: null,
   setRefreshHandler: null,
   getCurrentFiber: null,
-  reconcilerVersion: "18.3.0-canary-03d6f7cf0-20240209"
+  reconcilerVersion: "18.3.0-canary-9372c6311-20240315"
 };
 if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
-  var hook$jscomp$inline_1281 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
+  var hook$jscomp$inline_1260 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
   if (
-    !hook$jscomp$inline_1281.isDisabled &&
-    hook$jscomp$inline_1281.supportsFiber
+    !hook$jscomp$inline_1260.isDisabled &&
+    hook$jscomp$inline_1260.supportsFiber
   )
     try {
-      (rendererID = hook$jscomp$inline_1281.inject(
-        internals$jscomp$inline_1280
+      (rendererID = hook$jscomp$inline_1260.inject(
+        internals$jscomp$inline_1259
       )),
-        (injectedHook = hook$jscomp$inline_1281);
+        (injectedHook = hook$jscomp$inline_1260);
     } catch (err) {}
 }
 exports.createPortal = function (children, containerTag) {
diff --git a/node_modules/react-native/Libraries/Renderer/implementations/ReactFabric-profiling.js b/node_modules/react-native/Libraries/Renderer/implementations/ReactFabric-profiling.js
index 25d43a4..8620586 100644
--- a/node_modules/react-native/Libraries/Renderer/implementations/ReactFabric-profiling.js
+++ b/node_modules/react-native/Libraries/Renderer/implementations/ReactFabric-profiling.js
@@ -8,7 +8,7 @@
  * @nolint
  * @providesModule ReactFabric-profiling
  * @preventMunge
- * @generated SignedSource<<51d6b522792ab4b6c4d286b5e09bbfcd>>
+ * @generated SignedSource<<f32dbb66df793572d4202ca75aacf891>>
  */
 
 "use strict";
@@ -19,69 +19,26 @@
 require("react-native/Libraries/ReactPrivate/ReactNativePrivateInitializeCore");
 var ReactNativePrivateInterface = require("react-native/Libraries/ReactPrivate/ReactNativePrivateInterface"),
   Scheduler = require("scheduler"),
-  React = require("react");
-function invokeGuardedCallbackImpl(name, func, context) {
-  var funcArgs = Array.prototype.slice.call(arguments, 3);
-  try {
-    func.apply(context, funcArgs);
-  } catch (error) {
-    this.onError(error);
-  }
-}
-var hasError = !1,
+  React = require("react"),
+  isArrayImpl = Array.isArray,
+  hasError = !1,
   caughtError = null,
-  hasRethrowError = !1,
-  rethrowError = null,
-  reporter = {
-    onError: function (error) {
-      hasError = !0;
-      caughtError = error;
-    }
-  };
-function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
-  hasError = !1;
-  caughtError = null;
-  invokeGuardedCallbackImpl.apply(reporter, arguments);
-}
-function invokeGuardedCallbackAndCatchFirstError(
-  name,
-  func,
-  context,
-  a,
-  b,
-  c,
-  d,
-  e,
-  f
-) {
-  invokeGuardedCallback.apply(this, arguments);
-  if (hasError) {
-    if (hasError) {
-      var error = caughtError;
-      hasError = !1;
-      caughtError = null;
-    } else
-      throw Error(
-        "clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue."
-      );
-    hasRethrowError || ((hasRethrowError = !0), (rethrowError = error));
-  }
-}
-var isArrayImpl = Array.isArray,
   getFiberCurrentPropsFromNode$1 = null,
   getInstanceFromNode$1 = null,
   getNodeFromInstance$1 = null;
 function executeDispatch(event, listener, inst) {
-  var type = event.type || "unknown-event";
   event.currentTarget = getNodeFromInstance$1(inst);
-  invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event);
+  try {
+    listener(event);
+  } catch (error) {
+    hasError || ((hasError = !0), (caughtError = error));
+  }
   event.currentTarget = null;
 }
 function executeDirectDispatch(event) {
   var dispatchListener = event._dispatchListeners,
     dispatchInstance = event._dispatchInstances;
-  if (isArrayImpl(dispatchListener))
-    throw Error("executeDirectDispatch(...): Invalid `event`.");
+  if (isArrayImpl(dispatchListener)) throw Error("Invalid `event`.");
   event.currentTarget = dispatchListener
     ? getNodeFromInstance$1(dispatchInstance)
     : null;
@@ -340,9 +297,7 @@ var instrumentationCallback,
   };
 function accumulate(current, next) {
   if (null == next)
-    throw Error(
-      "accumulate(...): Accumulated items must not be null or undefined."
-    );
+    throw Error("Accumulated items must not be null or undefined.");
   return null == current
     ? next
     : isArrayImpl(current)
@@ -353,9 +308,7 @@ function accumulate(current, next) {
 }
 function accumulateInto(current, next) {
   if (null == next)
-    throw Error(
-      "accumulateInto(...): Accumulated items must not be null or undefined."
-    );
+    throw Error("Accumulated items must not be null or undefined.");
   if (null == current) return next;
   if (isArrayImpl(current)) {
     if (isArrayImpl(next)) return current.push.apply(current, next), current;
@@ -944,7 +897,7 @@ eventPluginOrder = Array.prototype.slice.call([
   "ReactNativeBridgeEventPlugin"
 ]);
 recomputePluginOrdering();
-var injectedNamesToPlugins$jscomp$inline_251 = {
+var injectedNamesToPlugins$jscomp$inline_246 = {
     ResponderEventPlugin: ResponderEventPlugin,
     ReactNativeBridgeEventPlugin: {
       eventTypes: {},
@@ -990,32 +943,32 @@ var injectedNamesToPlugins$jscomp$inline_251 = {
       }
     }
   },
-  isOrderingDirty$jscomp$inline_252 = !1,
-  pluginName$jscomp$inline_253;
-for (pluginName$jscomp$inline_253 in injectedNamesToPlugins$jscomp$inline_251)
+  isOrderingDirty$jscomp$inline_247 = !1,
+  pluginName$jscomp$inline_248;
+for (pluginName$jscomp$inline_248 in injectedNamesToPlugins$jscomp$inline_246)
   if (
-    injectedNamesToPlugins$jscomp$inline_251.hasOwnProperty(
-      pluginName$jscomp$inline_253
+    injectedNamesToPlugins$jscomp$inline_246.hasOwnProperty(
+      pluginName$jscomp$inline_248
     )
   ) {
-    var pluginModule$jscomp$inline_254 =
-      injectedNamesToPlugins$jscomp$inline_251[pluginName$jscomp$inline_253];
+    var pluginModule$jscomp$inline_249 =
+      injectedNamesToPlugins$jscomp$inline_246[pluginName$jscomp$inline_248];
     if (
-      !namesToPlugins.hasOwnProperty(pluginName$jscomp$inline_253) ||
-      namesToPlugins[pluginName$jscomp$inline_253] !==
-        pluginModule$jscomp$inline_254
+      !namesToPlugins.hasOwnProperty(pluginName$jscomp$inline_248) ||
+      namesToPlugins[pluginName$jscomp$inline_248] !==
+        pluginModule$jscomp$inline_249
     ) {
-      if (namesToPlugins[pluginName$jscomp$inline_253])
+      if (namesToPlugins[pluginName$jscomp$inline_248])
         throw Error(
           "EventPluginRegistry: Cannot inject two different event plugins using the same name, `" +
-            (pluginName$jscomp$inline_253 + "`.")
+            (pluginName$jscomp$inline_248 + "`.")
         );
-      namesToPlugins[pluginName$jscomp$inline_253] =
-        pluginModule$jscomp$inline_254;
-      isOrderingDirty$jscomp$inline_252 = !0;
+      namesToPlugins[pluginName$jscomp$inline_248] =
+        pluginModule$jscomp$inline_249;
+      isOrderingDirty$jscomp$inline_247 = !0;
     }
   }
-isOrderingDirty$jscomp$inline_252 && recomputePluginOrdering();
+isOrderingDirty$jscomp$inline_247 && recomputePluginOrdering();
 var emptyObject = {},
   removedKeys = null,
   removedKeyCount = 0,
@@ -1308,12 +1261,9 @@ function dispatchEvent(target, topLevelType, nativeEvent) {
         throw Error(
           "processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented."
         );
-      if (hasRethrowError)
+      if (hasError)
         throw (
-          ((event = rethrowError),
-          (hasRethrowError = !1),
-          (rethrowError = null),
-          event)
+          ((event = caughtError), (hasError = !1), (caughtError = null), event)
         );
     }
   });
@@ -1513,7 +1463,7 @@ function createLaneMap(initial) {
   for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
   return laneMap;
 }
-function markRootUpdated(root, updateLane) {
+function markRootUpdated$1(root, updateLane) {
   root.pendingLanes |= updateLane;
   268435456 !== updateLane &&
     ((root.suspendedLanes = 0), (root.pingedLanes = 0));
@@ -1676,6 +1626,11 @@ function cloneHiddenInstance(instance) {
     canonical: instance.canonical
   };
 }
+var supportsMicrotasks =
+    "undefined" !== typeof RN$enableMicrotasksInReact &&
+    !!RN$enableMicrotasksInReact,
+  scheduleMicrotask =
+    "function" === typeof queueMicrotask ? queueMicrotask : scheduleTimeout;
 function getInstanceFromNode(node) {
   return null != node.canonical && null != node.canonical.internalInstanceHandle
     ? node.canonical.internalInstanceHandle
@@ -1714,6 +1669,7 @@ var REACT_ELEMENT_TYPE = Symbol.for("react.element"),
   REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
   REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
   REACT_PROVIDER_TYPE = Symbol.for("react.provider"),
+  REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
   REACT_CONTEXT_TYPE = Symbol.for("react.context"),
   REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
   REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
@@ -1734,115 +1690,7 @@ function getIteratorFn(maybeIterable) {
     maybeIterable["@@iterator"];
   return "function" === typeof maybeIterable ? maybeIterable : null;
 }
-var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
-function getComponentNameFromType(type) {
-  if (null == type) return null;
-  if ("function" === typeof type)
-    return type.$$typeof === REACT_CLIENT_REFERENCE
-      ? null
-      : type.displayName || type.name || null;
-  if ("string" === typeof type) return type;
-  switch (type) {
-    case REACT_FRAGMENT_TYPE:
-      return "Fragment";
-    case REACT_PORTAL_TYPE:
-      return "Portal";
-    case REACT_PROFILER_TYPE:
-      return "Profiler";
-    case REACT_STRICT_MODE_TYPE:
-      return "StrictMode";
-    case REACT_SUSPENSE_TYPE:
-      return "Suspense";
-    case REACT_SUSPENSE_LIST_TYPE:
-      return "SuspenseList";
-  }
-  if ("object" === typeof type)
-    switch (type.$$typeof) {
-      case REACT_CONTEXT_TYPE:
-        return (type.displayName || "Context") + ".Consumer";
-      case REACT_PROVIDER_TYPE:
-        return (type._context.displayName || "Context") + ".Provider";
-      case REACT_FORWARD_REF_TYPE:
-        var innerType = type.render;
-        type = type.displayName;
-        type ||
-          ((type = innerType.displayName || innerType.name || ""),
-          (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
-        return type;
-      case REACT_MEMO_TYPE:
-        return (
-          (innerType = type.displayName || null),
-          null !== innerType
-            ? innerType
-            : getComponentNameFromType(type.type) || "Memo"
-        );
-      case REACT_LAZY_TYPE:
-        innerType = type._payload;
-        type = type._init;
-        try {
-          return getComponentNameFromType(type(innerType));
-        } catch (x) {}
-    }
-  return null;
-}
-function getComponentNameFromFiber(fiber) {
-  var type = fiber.type;
-  switch (fiber.tag) {
-    case 24:
-      return "Cache";
-    case 9:
-      return (type.displayName || "Context") + ".Consumer";
-    case 10:
-      return (type._context.displayName || "Context") + ".Provider";
-    case 18:
-      return "DehydratedFragment";
-    case 11:
-      return (
-        (fiber = type.render),
-        (fiber = fiber.displayName || fiber.name || ""),
-        type.displayName ||
-          ("" !== fiber ? "ForwardRef(" + fiber + ")" : "ForwardRef")
-      );
-    case 7:
-      return "Fragment";
-    case 26:
-    case 27:
-    case 5:
-      return type;
-    case 4:
-      return "Portal";
-    case 3:
-      return "Root";
-    case 6:
-      return "Text";
-    case 16:
-      return getComponentNameFromType(type);
-    case 8:
-      return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
-    case 22:
-      return "Offscreen";
-    case 12:
-      return "Profiler";
-    case 21:
-      return "Scope";
-    case 13:
-      return "Suspense";
-    case 19:
-      return "SuspenseList";
-    case 25:
-      return "TracingMarker";
-    case 1:
-    case 0:
-    case 17:
-    case 2:
-    case 14:
-    case 15:
-      if ("function" === typeof type)
-        return type.displayName || type.name || null;
-      if ("string" === typeof type) return type;
-  }
-  return null;
-}
+Symbol.for("react.client.reference");
 function getNearestMountedFiber(fiber) {
   var node = fiber,
     nearestMounted = fiber;
@@ -1951,18 +1799,7 @@ function findCurrentHostFiberImpl(node) {
   }
   return null;
 }
-function describeComponentFrame(name, ownerName) {
-  var sourceInfo = "";
-  ownerName && (sourceInfo = " (created by " + ownerName + ")");
-  return "\n    in " + (name || "Unknown") + sourceInfo;
-}
-function describeFunctionComponentFrame(fn) {
-  return fn
-    ? describeComponentFrame(fn.displayName || fn.name || null, null)
-    : "";
-}
-var hasOwnProperty = Object.prototype.hasOwnProperty,
-  valueStack = [],
+var valueStack = [],
   index = -1;
 function createCursor(defaultValue) {
   return { current: defaultValue };
@@ -1976,89 +1813,7 @@ function push(cursor, value) {
   valueStack[index] = cursor.current;
   cursor.current = value;
 }
-var emptyContextObject = {},
-  contextStackCursor$1 = createCursor(emptyContextObject),
-  didPerformWorkStackCursor = createCursor(!1),
-  previousContext = emptyContextObject;
-function getMaskedContext(workInProgress, unmaskedContext) {
-  var contextTypes = workInProgress.type.contextTypes;
-  if (!contextTypes) return emptyContextObject;
-  var instance = workInProgress.stateNode;
-  if (
-    instance &&
-    instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext
-  )
-    return instance.__reactInternalMemoizedMaskedChildContext;
-  var context = {},
-    key;
-  for (key in contextTypes) context[key] = unmaskedContext[key];
-  instance &&
-    ((workInProgress = workInProgress.stateNode),
-    (workInProgress.__reactInternalMemoizedUnmaskedChildContext =
-      unmaskedContext),
-    (workInProgress.__reactInternalMemoizedMaskedChildContext = context));
-  return context;
-}
-function isContextProvider(type) {
-  type = type.childContextTypes;
-  return null !== type && void 0 !== type;
-}
-function popContext() {
-  pop(didPerformWorkStackCursor);
-  pop(contextStackCursor$1);
-}
-function pushTopLevelContextObject(fiber, context, didChange) {
-  if (contextStackCursor$1.current !== emptyContextObject)
-    throw Error(
-      "Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue."
-    );
-  push(contextStackCursor$1, context);
-  push(didPerformWorkStackCursor, didChange);
-}
-function processChildContext(fiber, type, parentContext) {
-  var instance = fiber.stateNode;
-  type = type.childContextTypes;
-  if ("function" !== typeof instance.getChildContext) return parentContext;
-  instance = instance.getChildContext();
-  for (var contextKey in instance)
-    if (!(contextKey in type))
-      throw Error(
-        (getComponentNameFromFiber(fiber) || "Unknown") +
-          '.getChildContext(): key "' +
-          contextKey +
-          '" is not defined in childContextTypes.'
-      );
-  return assign({}, parentContext, instance);
-}
-function pushContextProvider(workInProgress) {
-  workInProgress =
-    ((workInProgress = workInProgress.stateNode) &&
-      workInProgress.__reactInternalMemoizedMergedChildContext) ||
-    emptyContextObject;
-  previousContext = contextStackCursor$1.current;
-  push(contextStackCursor$1, workInProgress);
-  push(didPerformWorkStackCursor, didPerformWorkStackCursor.current);
-  return !0;
-}
-function invalidateContextProvider(workInProgress, type, didChange) {
-  var instance = workInProgress.stateNode;
-  if (!instance)
-    throw Error(
-      "Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue."
-    );
-  didChange
-    ? ((workInProgress = processChildContext(
-        workInProgress,
-        type,
-        previousContext
-      )),
-      (instance.__reactInternalMemoizedMergedChildContext = workInProgress),
-      pop(didPerformWorkStackCursor),
-      pop(contextStackCursor$1),
-      push(contextStackCursor$1, workInProgress))
-    : pop(didPerformWorkStackCursor);
-  push(didPerformWorkStackCursor, didChange);
-}
+var emptyContextObject = {};
 function is(x, y) {
   return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
 }
@@ -2195,7 +1950,7 @@ function ensureRootIsScheduled(root) {
   mightHavePendingSyncWork = !0;
   didScheduleMicrotask ||
     ((didScheduleMicrotask = !0),
-    scheduleCallback$2(ImmediatePriority, processRootScheduleInMicrotask));
+    scheduleImmediateTask(processRootScheduleInMicrotask));
   scheduleTaskForRootDuringMicrotask(root, now$1());
 }
 function flushSyncWorkAcrossRoots_impl(onlyLegacy) {
@@ -2267,6 +2022,7 @@ function flushSyncWorkAcrossRoots_impl(onlyLegacy) {
                       workInProgressRootRenderLanes$11,
                       workInProgressRootRecoverableErrors,
                       workInProgressTransitions,
+                      workInProgressRootDidIncludeRecursiveRenderUpdate,
                       workInProgressDeferredLane
                     ));
               }
@@ -2284,8 +2040,7 @@ function flushSyncWorkAcrossRoots_impl(onlyLegacy) {
         if ("function" === typeof AggregateError)
           throw new AggregateError(errors);
         for (onlyLegacy = 1; onlyLegacy < errors.length; onlyLegacy++)
-          (didPerformSomeWork = throwError.bind(null, errors[onlyLegacy])),
-            scheduleCallback$2(ImmediatePriority, didPerformSomeWork);
+          scheduleImmediateTask(throwError.bind(null, errors[onlyLegacy]));
       }
       throw errors[0];
     }
@@ -2385,6 +2140,15 @@ function scheduleTaskForRootDuringMicrotask(root, currentTime) {
   root.callbackNode = suspendedLanes;
   return currentTime;
 }
+function scheduleImmediateTask(cb) {
+  supportsMicrotasks
+    ? scheduleMicrotask(function () {
+        0 !== (executionContext & 6)
+          ? scheduleCallback$2(ImmediatePriority, cb)
+          : cb();
+      })
+    : scheduleCallback$2(ImmediatePriority, cb);
+}
 var hasForceUpdate = !1;
 function initializeUpdateQueue(fiber) {
   fiber.updateQueue = {
@@ -2621,6 +2385,7 @@ function commitCallbacks(updateQueue, context) {
     )
       callCallback(callbacks[updateQueue], context);
 }
+var hasOwnProperty = Object.prototype.hasOwnProperty;
 function shallowEqual(objA, objB) {
   if (objectIs(objA, objB)) return !0;
   if (
@@ -2643,6 +2408,16 @@ function shallowEqual(objA, objB) {
   }
   return !0;
 }
+function describeComponentFrame(name, ownerName) {
+  var sourceInfo = "";
+  ownerName && (sourceInfo = " (created by " + ownerName + ")");
+  return "\n    in " + (name || "Unknown") + sourceInfo;
+}
+function describeFunctionComponentFrame(fn) {
+  return fn
+    ? describeComponentFrame(fn.displayName || fn.name || null, null)
+    : "";
+}
 function describeFiber(fiber) {
   switch (fiber.tag) {
     case 26:
@@ -2667,6 +2442,18 @@ function describeFiber(fiber) {
       return "";
   }
 }
+function getStackByFiberInDevAndProd(workInProgress) {
+  try {
+    var info = "";
+    do
+      (info += describeFiber(workInProgress)),
+        (workInProgress = workInProgress.return);
+    while (workInProgress);
+    return info;
+  } catch (x) {
+    return "\nError generating stack: " + x.message + "\n" + x.stack;
+  }
+}
 var SuspenseException = Error(
     "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`"
   ),
@@ -2719,16 +2506,16 @@ function trackUsedThenable(thenableState, thenable, index) {
             }
           }
         );
-        switch (thenable.status) {
-          case "fulfilled":
-            return thenable.value;
-          case "rejected":
-            throw (
-              ((thenableState = thenable.reason),
-              checkIfUseWrappedInAsyncCatch(thenableState),
-              thenableState)
-            );
-        }
+      }
+      switch (thenable.status) {
+        case "fulfilled":
+          return thenable.value;
+        case "rejected":
+          throw (
+            ((thenableState = thenable.reason),
+            checkIfUseWrappedInAsyncCatch(thenableState),
+            thenableState)
+          );
       }
       suspendedThenable = thenable;
       throw SuspenseException;
@@ -2758,56 +2545,54 @@ function unwrapThenable(thenable) {
   null === thenableState$1 && (thenableState$1 = []);
   return trackUsedThenable(thenableState$1, thenable, index);
 }
-function coerceRef(returnFiber, current, element) {
-  returnFiber = element.ref;
-  if (
-    null !== returnFiber &&
-    "function" !== typeof returnFiber &&
-    "object" !== typeof returnFiber
-  ) {
-    if (element._owner) {
-      element = element._owner;
-      if (element) {
-        if (1 !== element.tag)
-          throw Error(
-            "Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref"
-          );
-        var inst = element.stateNode;
-      }
-      if (!inst)
-        throw Error(
-          "Missing owner for string ref " +
-            returnFiber +
-            ". This error is likely caused by a bug in React. Please file an issue."
-        );
-      var resolvedInst = inst,
-        stringRef = "" + returnFiber;
-      if (
-        null !== current &&
-        null !== current.ref &&
-        "function" === typeof current.ref &&
-        current.ref._stringRef === stringRef
-      )
-        return current.ref;
-      current = function (value) {
-        var refs = resolvedInst.refs;
-        null === value ? delete refs[stringRef] : (refs[stringRef] = value);
-      };
-      current._stringRef = stringRef;
-      return current;
-    }
-    if ("string" !== typeof returnFiber)
-      throw Error(
-        "Expected ref to be a function, a string, an object returned by React.createRef(), or null."
-      );
-    if (!element._owner)
-      throw Error(
-        "Element ref was specified as a string (" +
-          returnFiber +
-          ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information."
-      );
+function convertStringRefToCallbackRef(
+  returnFiber,
+  current,
+  element,
+  mixedRef
+) {
+  function ref(value) {
+    var refs = inst.refs;
+    null === value ? delete refs[stringRef] : (refs[stringRef] = value);
   }
-  return returnFiber;
+  var stringRef = "" + mixedRef;
+  returnFiber = element._owner;
+  if (!returnFiber)
+    throw Error(
+      "Element ref was specified as a string (" +
+        stringRef +
+        ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://react.dev/link/refs-must-have-owner for more information."
+    );
+  if (1 !== returnFiber.tag)
+    throw Error(
+      "Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://react.dev/link/strict-mode-string-ref"
+    );
+  var inst = returnFiber.stateNode;
+  if (!inst)
+    throw Error(
+      "Missing owner for string ref " +
+        stringRef +
+        ". This error is likely caused by a bug in React. Please file an issue."
+    );
+  if (
+    null !== current &&
+    null !== current.ref &&
+    "function" === typeof current.ref &&
+    current.ref._stringRef === stringRef
+  )
+    return current.ref;
+  ref._stringRef = stringRef;
+  return ref;
+}
+function coerceRef(returnFiber, current, workInProgress, element) {
+  var mixedRef = element.ref;
+  returnFiber =
+    "string" === typeof mixedRef ||
+    "number" === typeof mixedRef ||
+    "boolean" === typeof mixedRef
+      ? convertStringRefToCallbackRef(returnFiber, current, element, mixedRef)
+      : mixedRef;
+  workInProgress.ref = returnFiber;
 }
 function throwOnInvalidObjectType(returnFiber, newChild) {
   returnFiber = Object.prototype.toString.call(newChild);
@@ -2839,13 +2624,13 @@ function createChildReconciler(shouldTrackSideEffects) {
         (currentFirstChild = currentFirstChild.sibling);
     return null;
   }
-  function mapRemainingChildren(returnFiber, currentFirstChild) {
-    for (returnFiber = new Map(); null !== currentFirstChild; )
+  function mapRemainingChildren(currentFirstChild) {
+    for (var existingChildren = new Map(); null !== currentFirstChild; )
       null !== currentFirstChild.key
-        ? returnFiber.set(currentFirstChild.key, currentFirstChild)
-        : returnFiber.set(currentFirstChild.index, currentFirstChild),
+        ? existingChildren.set(currentFirstChild.key, currentFirstChild)
+        : existingChildren.set(currentFirstChild.index, currentFirstChild),
         (currentFirstChild = currentFirstChild.sibling);
-    return returnFiber;
+    return existingChildren;
   }
   function useFiber(fiber, pendingProps) {
     fiber = createWorkInProgress(fiber, pendingProps);
@@ -2905,7 +2690,7 @@ function createChildReconciler(shouldTrackSideEffects) {
     )
       return (
         (lanes = useFiber(current, element.props)),
-        (lanes.ref = coerceRef(returnFiber, current, element)),
+        coerceRef(returnFiber, current, lanes, element),
         (lanes.return = returnFiber),
         lanes
       );
@@ -2917,7 +2702,7 @@ function createChildReconciler(shouldTrackSideEffects) {
       returnFiber.mode,
       lanes
     );
-    lanes.ref = coerceRef(returnFiber, current, element);
+    coerceRef(returnFiber, current, lanes, element);
     lanes.return = returnFiber;
     return lanes;
   }
@@ -2979,7 +2764,7 @@ function createChildReconciler(shouldTrackSideEffects) {
               returnFiber.mode,
               lanes
             )),
-            (lanes.ref = coerceRef(returnFiber, null, newChild)),
+            coerceRef(returnFiber, null, lanes, newChild),
             (lanes.return = returnFiber),
             lanes
           );
@@ -3013,7 +2798,7 @@ function createChildReconciler(shouldTrackSideEffects) {
       if (newChild.$$typeof === REACT_CONTEXT_TYPE)
         return createChild(
           returnFiber,
-          readContextDuringReconcilation(returnFiber, newChild, lanes),
+          readContextDuringReconciliation(returnFiber, newChild, lanes),
           lanes
         );
       throwOnInvalidObjectType(returnFiber, newChild);
@@ -3060,7 +2845,7 @@ function createChildReconciler(shouldTrackSideEffects) {
         return updateSlot(
           returnFiber,
           oldFiber,
-          readContextDuringReconcilation(returnFiber, newChild, lanes),
+          readContextDuringReconciliation(returnFiber, newChild, lanes),
           lanes
         );
       throwOnInvalidObjectType(returnFiber, newChild);
@@ -3128,7 +2913,7 @@ function createChildReconciler(shouldTrackSideEffects) {
           existingChildren,
           returnFiber,
           newIdx,
-          readContextDuringReconcilation(returnFiber, newChild, lanes),
+          readContextDuringReconciliation(returnFiber, newChild, lanes),
           lanes
         );
       throwOnInvalidObjectType(returnFiber, newChild);
@@ -3194,7 +2979,7 @@ function createChildReconciler(shouldTrackSideEffects) {
       return resultingFirstChild;
     }
     for (
-      oldFiber = mapRemainingChildren(returnFiber, oldFiber);
+      oldFiber = mapRemainingChildren(oldFiber);
       newIdx < newChildren.length;
       newIdx++
     )
@@ -3282,7 +3067,7 @@ function createChildReconciler(shouldTrackSideEffects) {
       return iteratorFn;
     }
     for (
-      oldFiber = mapRemainingChildren(returnFiber, oldFiber);
+      oldFiber = mapRemainingChildren(oldFiber);
       !step.done;
       newIdx++, step = newChildrenIterable.next()
     )
@@ -3344,11 +3129,7 @@ function createChildReconciler(shouldTrackSideEffects) {
                 ) {
                   deleteRemainingChildren(returnFiber, child.sibling);
                   currentFirstChild = useFiber(child, newChild.props);
-                  currentFirstChild.ref = coerceRef(
-                    returnFiber,
-                    child,
-                    newChild
-                  );
+                  coerceRef(returnFiber, child, currentFirstChild, newChild);
                   currentFirstChild.return = returnFiber;
                   returnFiber = currentFirstChild;
                   break a;
@@ -3375,11 +3156,7 @@ function createChildReconciler(shouldTrackSideEffects) {
                   returnFiber.mode,
                   lanes
                 )),
-                (lanes.ref = coerceRef(
-                  returnFiber,
-                  currentFirstChild,
-                  newChild
-                )),
+                coerceRef(returnFiber, currentFirstChild, lanes, newChild),
                 (lanes.return = returnFiber),
                 (returnFiber = lanes));
           }
@@ -3425,7 +3202,7 @@ function createChildReconciler(shouldTrackSideEffects) {
         case REACT_LAZY_TYPE:
           return (
             (child = newChild._init),
-            reconcileChildFibers(
+            reconcileChildFibersImpl(
               returnFiber,
               currentFirstChild,
               child(newChild._payload),
@@ -3458,7 +3235,7 @@ function createChildReconciler(shouldTrackSideEffects) {
         return reconcileChildFibersImpl(
           returnFiber,
           currentFirstChild,
-          readContextDuringReconcilation(returnFiber, newChild, lanes),
+          readContextDuringReconciliation(returnFiber, newChild, lanes),
           lanes
         );
       throwOnInvalidObjectType(returnFiber, newChild);
@@ -3482,12 +3259,7 @@ function createChildReconciler(shouldTrackSideEffects) {
         placeSingleChild(returnFiber))
       : deleteRemainingChildren(returnFiber, currentFirstChild);
   }
-  function reconcileChildFibers(
-    returnFiber,
-    currentFirstChild,
-    newChild,
-    lanes
-  ) {
+  return function (returnFiber, currentFirstChild, newChild, lanes) {
     thenableIndexCounter$1 = 0;
     returnFiber = reconcileChildFibersImpl(
       returnFiber,
@@ -3497,8 +3269,7 @@ function createChildReconciler(shouldTrackSideEffects) {
     );
     thenableState$1 = null;
     return returnFiber;
-  }
-  return reconcileChildFibers;
+  };
 }
 var reconcileChildFibers = createChildReconciler(!0),
   mountChildFibers = createChildReconciler(!1),
@@ -3591,7 +3362,7 @@ var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher,
   globalClientIdCounter = 0;
 function throwInvalidHookError() {
   throw Error(
-    "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem."
+    "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
   );
 }
 function areHookInputsEqual(nextDeps, prevDeps) {
@@ -4530,30 +4301,17 @@ function checkShouldComponentUpdate(
     : !0;
 }
 function constructClassInstance(workInProgress, ctor, props) {
-  var isLegacyContextConsumer = !1,
-    unmaskedContext = emptyContextObject;
-  var context = ctor.contextType;
-  "object" === typeof context && null !== context
-    ? (context = readContext(context))
-    : ((unmaskedContext = isContextProvider(ctor)
-        ? previousContext
-        : contextStackCursor$1.current),
-      (isLegacyContextConsumer = ctor.contextTypes),
-      (context = (isLegacyContextConsumer =
-        null !== isLegacyContextConsumer && void 0 !== isLegacyContextConsumer)
-        ? getMaskedContext(workInProgress, unmaskedContext)
-        : emptyContextObject));
+  var context = emptyContextObject,
+    contextType = ctor.contextType;
+  "object" === typeof contextType &&
+    null !== contextType &&
+    (context = readContext(contextType));
   ctor = new ctor(props, context);
   workInProgress.memoizedState =
     null !== ctor.state && void 0 !== ctor.state ? ctor.state : null;
   ctor.updater = classComponentUpdater;
   workInProgress.stateNode = ctor;
   ctor._reactInternals = workInProgress;
-  isLegacyContextConsumer &&
-    ((workInProgress = workInProgress.stateNode),
-    (workInProgress.__reactInternalMemoizedUnmaskedChildContext =
-      unmaskedContext),
-    (workInProgress.__reactInternalMemoizedMaskedChildContext = context));
   return ctor;
 }
 function callComponentWillReceiveProps(
@@ -4577,12 +4335,10 @@ function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {
   instance.refs = {};
   initializeUpdateQueue(workInProgress);
   var contextType = ctor.contextType;
-  "object" === typeof contextType && null !== contextType
-    ? (instance.context = readContext(contextType))
-    : ((contextType = isContextProvider(ctor)
-        ? previousContext
-        : contextStackCursor$1.current),
-      (instance.context = getMaskedContext(workInProgress, contextType)));
+  instance.context =
+    "object" === typeof contextType && null !== contextType
+      ? readContext(contextType)
+      : emptyContextObject;
   instance.state = workInProgress.memoizedState;
   contextType = ctor.getDerivedStateFromProps;
   "function" === typeof contextType &&
@@ -4604,22 +4360,23 @@ function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {
   "function" === typeof instance.componentDidMount &&
     (workInProgress.flags |= 4194308);
 }
+var CapturedStacks = new WeakMap();
 function createCapturedValueAtFiber(value, source) {
-  try {
-    var info = "",
-      node = source;
-    do (info += describeFiber(node)), (node = node.return);
-    while (node);
-    var JSCompiler_inline_result = info;
-  } catch (x) {
-    JSCompiler_inline_result =
-      "\nError generating stack: " + x.message + "\n" + x.stack;
-  }
+  if ("object" === typeof value && null !== value) {
+    var stack = CapturedStacks.get(value);
+    "string" !== typeof stack &&
+      ((stack = getStackByFiberInDevAndProd(source)),
+      CapturedStacks.set(value, stack));
+  } else stack = getStackByFiberInDevAndProd(source);
+  return { value: value, source: source, stack: stack, digest: null };
+}
+function createCapturedValueFromError(value, digest, stack) {
+  "string" === typeof stack && CapturedStacks.set(value, stack);
   return {
     value: value,
-    source: source,
-    stack: JSCompiler_inline_result,
-    digest: null
+    source: null,
+    stack: null != stack ? stack : null,
+    digest: null != digest ? digest : null
   };
 }
 if (
@@ -4966,7 +4723,7 @@ function updateOffscreenComponent(current, workInProgress, renderLanes) {
     nextChildren = nextProps.children,
     nextIsDetached = 0 !== (workInProgress.stateNode._pendingVisibility & 2),
     prevState = null !== current ? current.memoizedState : null;
-  markRef$1(current, workInProgress);
+  markRef(current, workInProgress);
   if ("hidden" === nextProps.mode || nextIsDetached) {
     if (0 !== (workInProgress.flags & 128)) {
       renderLanes =
@@ -5020,13 +4777,20 @@ function deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes) {
   pushOffscreenSuspenseHandler(workInProgress);
   return null;
 }
-function markRef$1(current, workInProgress) {
+function markRef(current, workInProgress) {
   var ref = workInProgress.ref;
-  if (
-    (null === current && null !== ref) ||
-    (null !== current && current.ref !== ref)
-  )
-    (workInProgress.flags |= 512), (workInProgress.flags |= 2097152);
+  if (null === ref)
+    null !== current &&
+      null !== current.ref &&
+      (workInProgress.flags |= 2097664);
+  else {
+    if ("function" !== typeof ref && "object" !== typeof ref)
+      throw Error(
+        "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
+      );
+    if (null === current || current.ref !== ref)
+      workInProgress.flags |= 2097664;
+  }
 }
 function updateFunctionComponent(
   current,
@@ -5035,17 +4799,13 @@ function updateFunctionComponent(
   nextProps,
   renderLanes
 ) {
-  var context = isContextProvider(Component)
-    ? previousContext
-    : contextStackCursor$1.current;
-  context = getMaskedContext(workInProgress, context);
   prepareToReadContext(workInProgress, renderLanes);
   Component = renderWithHooks(
     current,
     workInProgress,
     Component,
     nextProps,
-    context,
+    void 0,
     renderLanes
   );
   if (null !== current && !didReceiveUpdate)
@@ -5089,10 +4849,6 @@ function updateClassComponent(
   nextProps,
   renderLanes
 ) {
-  if (isContextProvider(Component)) {
-    var hasContext = !0;
-    pushContextProvider(workInProgress);
-  } else hasContext = !1;
   prepareToReadContext(workInProgress, renderLanes);
   if (null === workInProgress.stateNode)
     resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress),
@@ -5104,36 +4860,30 @@ function updateClassComponent(
       oldProps = workInProgress.memoizedProps;
     instance.props = oldProps;
     var oldContext = instance.context,
-      contextType = Component.contextType;
-    "object" === typeof contextType && null !== contextType
-      ? (contextType = readContext(contextType))
-      : ((contextType = isContextProvider(Component)
-          ? previousContext
-          : contextStackCursor$1.current),
-        (contextType = getMaskedContext(workInProgress, contextType)));
-    var getDerivedStateFromProps = Component.getDerivedStateFromProps,
-      hasNewLifecycles =
-        "function" === typeof getDerivedStateFromProps ||
-        "function" === typeof instance.getSnapshotBeforeUpdate;
-    hasNewLifecycles ||
+      contextType = Component.contextType,
+      nextContext = emptyContextObject;
+    "object" === typeof contextType &&
+      null !== contextType &&
+      (nextContext = readContext(contextType));
+    var getDerivedStateFromProps = Component.getDerivedStateFromProps;
+    (contextType =
+      "function" === typeof getDerivedStateFromProps ||
+      "function" === typeof instance.getSnapshotBeforeUpdate) ||
       ("function" !== typeof instance.UNSAFE_componentWillReceiveProps &&
         "function" !== typeof instance.componentWillReceiveProps) ||
-      ((oldProps !== nextProps || oldContext !== contextType) &&
+      ((oldProps !== nextProps || oldContext !== nextContext) &&
         callComponentWillReceiveProps(
           workInProgress,
           instance,
           nextProps,
-          contextType
+          nextContext
         ));
     hasForceUpdate = !1;
     var oldState = workInProgress.memoizedState;
     instance.state = oldState;
     processUpdateQueue(workInProgress, nextProps, instance, renderLanes);
     oldContext = workInProgress.memoizedState;
-    oldProps !== nextProps ||
-    oldState !== oldContext ||
-    didPerformWorkStackCursor.current ||
-    hasForceUpdate
+    oldProps !== nextProps || oldState !== oldContext || hasForceUpdate
       ? ("function" === typeof getDerivedStateFromProps &&
           (applyDerivedStateFromProps(
             workInProgress,
@@ -5151,9 +4901,9 @@ function updateClassComponent(
             nextProps,
             oldState,
             oldContext,
-            contextType
+            nextContext
           ))
-          ? (hasNewLifecycles ||
+          ? (contextType ||
               ("function" !== typeof instance.UNSAFE_componentWillMount &&
                 "function" !== typeof instance.componentWillMount) ||
               ("function" === typeof instance.componentWillMount &&
@@ -5168,7 +4918,7 @@ function updateClassComponent(
             (workInProgress.memoizedState = oldContext)),
         (instance.props = nextProps),
         (instance.state = oldContext),
-        (instance.context = contextType),
+        (instance.context = nextContext),
         (nextProps = oldProps))
       : ("function" === typeof instance.componentDidMount &&
           (workInProgress.flags |= 4194308),
@@ -5176,48 +4926,46 @@ function updateClassComponent(
   } else {
     instance = workInProgress.stateNode;
     cloneUpdateQueue(current, workInProgress);
-    oldProps = workInProgress.memoizedProps;
+    nextContext = workInProgress.memoizedProps;
     contextType =
       workInProgress.type === workInProgress.elementType
-        ? oldProps
-        : resolveDefaultProps(workInProgress.type, oldProps);
+        ? nextContext
+        : resolveDefaultProps(workInProgress.type, nextContext);
     instance.props = contextType;
-    hasNewLifecycles = workInProgress.pendingProps;
-    oldState = instance.context;
+    getDerivedStateFromProps = workInProgress.pendingProps;
+    var oldContext$jscomp$0 = instance.context;
     oldContext = Component.contextType;
-    "object" === typeof oldContext && null !== oldContext
-      ? (oldContext = readContext(oldContext))
-      : ((oldContext = isContextProvider(Component)
-          ? previousContext
-          : contextStackCursor$1.current),
-        (oldContext = getMaskedContext(workInProgress, oldContext)));
-    var getDerivedStateFromProps$jscomp$0 = Component.getDerivedStateFromProps;
-    (getDerivedStateFromProps =
-      "function" === typeof getDerivedStateFromProps$jscomp$0 ||
+    oldProps = emptyContextObject;
+    "object" === typeof oldContext &&
+      null !== oldContext &&
+      (oldProps = readContext(oldContext));
+    oldState = Component.getDerivedStateFromProps;
+    (oldContext =
+      "function" === typeof oldState ||
       "function" === typeof instance.getSnapshotBeforeUpdate) ||
       ("function" !== typeof instance.UNSAFE_componentWillReceiveProps &&
         "function" !== typeof instance.componentWillReceiveProps) ||
-      ((oldProps !== hasNewLifecycles || oldState !== oldContext) &&
+      ((nextContext !== getDerivedStateFromProps ||
+        oldContext$jscomp$0 !== oldProps) &&
         callComponentWillReceiveProps(
           workInProgress,
           instance,
           nextProps,
-          oldContext
+          oldProps
         ));
     hasForceUpdate = !1;
-    oldState = workInProgress.memoizedState;
-    instance.state = oldState;
+    oldContext$jscomp$0 = workInProgress.memoizedState;
+    instance.state = oldContext$jscomp$0;
     processUpdateQueue(workInProgress, nextProps, instance, renderLanes);
     var newState = workInProgress.memoizedState;
-    oldProps !== hasNewLifecycles ||
-    oldState !== newState ||
-    didPerformWorkStackCursor.current ||
+    nextContext !== getDerivedStateFromProps ||
+    oldContext$jscomp$0 !== newState ||
     hasForceUpdate
-      ? ("function" === typeof getDerivedStateFromProps$jscomp$0 &&
+      ? ("function" === typeof oldState &&
           (applyDerivedStateFromProps(
             workInProgress,
             Component,
-            getDerivedStateFromProps$jscomp$0,
+            oldState,
             nextProps
           ),
           (newState = workInProgress.memoizedState)),
@@ -5228,47 +4976,47 @@ function updateClassComponent(
             Component,
             contextType,
             nextProps,
-            oldState,
+            oldContext$jscomp$0,
             newState,
-            oldContext
+            oldProps
           ) ||
           !1)
-          ? (getDerivedStateFromProps ||
+          ? (oldContext ||
               ("function" !== typeof instance.UNSAFE_componentWillUpdate &&
                 "function" !== typeof instance.componentWillUpdate) ||
               ("function" === typeof instance.componentWillUpdate &&
-                instance.componentWillUpdate(nextProps, newState, oldContext),
+                instance.componentWillUpdate(nextProps, newState, oldProps),
               "function" === typeof instance.UNSAFE_componentWillUpdate &&
                 instance.UNSAFE_componentWillUpdate(
                   nextProps,
                   newState,
-                  oldContext
+                  oldProps
                 )),
             "function" === typeof instance.componentDidUpdate &&
               (workInProgress.flags |= 4),
             "function" === typeof instance.getSnapshotBeforeUpdate &&
               (workInProgress.flags |= 1024))
           : ("function" !== typeof instance.componentDidUpdate ||
-              (oldProps === current.memoizedProps &&
-                oldState === current.memoizedState) ||
+              (nextContext === current.memoizedProps &&
+                oldContext$jscomp$0 === current.memoizedState) ||
               (workInProgress.flags |= 4),
             "function" !== typeof instance.getSnapshotBeforeUpdate ||
-              (oldProps === current.memoizedProps &&
-                oldState === current.memoizedState) ||
+              (nextContext === current.memoizedProps &&
+                oldContext$jscomp$0 === current.memoizedState) ||
               (workInProgress.flags |= 1024),
             (workInProgress.memoizedProps = nextProps),
             (workInProgress.memoizedState = newState)),
         (instance.props = nextProps),
         (instance.state = newState),
-        (instance.context = oldContext),
+        (instance.context = oldProps),
         (nextProps = contextType))
       : ("function" !== typeof instance.componentDidUpdate ||
-          (oldProps === current.memoizedProps &&
-            oldState === current.memoizedState) ||
+          (nextContext === current.memoizedProps &&
+            oldContext$jscomp$0 === current.memoizedState) ||
           (workInProgress.flags |= 4),
         "function" !== typeof instance.getSnapshotBeforeUpdate ||
-          (oldProps === current.memoizedProps &&
-            oldState === current.memoizedState) ||
+          (nextContext === current.memoizedProps &&
+            oldContext$jscomp$0 === current.memoizedState) ||
           (workInProgress.flags |= 1024),
         (nextProps = !1));
   }
@@ -5277,7 +5025,7 @@ function updateClassComponent(
     workInProgress,
     Component,
     nextProps,
-    hasContext,
+    !1,
     renderLanes
   );
 }
@@ -5289,26 +5037,18 @@ function finishClassComponent(
   hasContext,
   renderLanes
 ) {
-  markRef$1(current, workInProgress);
-  var didCaptureError = 0 !== (workInProgress.flags & 128);
-  if (!shouldUpdate && !didCaptureError)
-    return (
-      hasContext && invalidateContextProvider(workInProgress, Component, !1),
-      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
-    );
+  markRef(current, workInProgress);
+  hasContext = 0 !== (workInProgress.flags & 128);
+  if (!shouldUpdate && !hasContext)
+    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
   shouldUpdate = workInProgress.stateNode;
   ReactCurrentOwner$1.current = workInProgress;
-  if (
-    didCaptureError &&
-    "function" !== typeof Component.getDerivedStateFromError
-  ) {
-    var nextChildren = null;
-    profilerStartTime = -1;
-  } else nextChildren = shouldUpdate.render();
+  hasContext && "function" !== typeof Component.getDerivedStateFromError
+    ? ((Component = null), (profilerStartTime = -1))
+    : (Component = shouldUpdate.render());
   workInProgress.flags |= 1;
-  null !== current && didCaptureError
-    ? ((didCaptureError = nextChildren),
-      (workInProgress.child = reconcileChildFibers(
+  null !== current && hasContext
+    ? ((workInProgress.child = reconcileChildFibers(
         workInProgress,
         current.child,
         null,
@@ -5317,26 +5057,13 @@ function finishClassComponent(
       (workInProgress.child = reconcileChildFibers(
         workInProgress,
         null,
-        didCaptureError,
+        Component,
         renderLanes
       )))
-    : reconcileChildren(current, workInProgress, nextChildren, renderLanes);
+    : reconcileChildren(current, workInProgress, Component, renderLanes);
   workInProgress.memoizedState = shouldUpdate.state;
-  hasContext && invalidateContextProvider(workInProgress, Component, !0);
   return workInProgress.child;
 }
-function pushHostRootContext(workInProgress) {
-  var root = workInProgress.stateNode;
-  root.pendingContext
-    ? pushTopLevelContextObject(
-        workInProgress,
-        root.pendingContext,
-        root.pendingContext !== root.context
-      )
-    : root.context &&
-      pushTopLevelContextObject(workInProgress, root.context, !1);
-  pushHostContainer(workInProgress, root.containerInfo);
-}
 var SUSPENDED_MARKER = { dehydrated: null, treeContext: null, retryLane: 0 };
 function mountSuspenseOffscreenState(renderLanes) {
   return { baseLanes: renderLanes, cachePool: null };
@@ -5540,18 +5267,16 @@ function updateDehydratedSuspenseComponent(
       return (
         pushPrimaryTreeSuspenseHandler(workInProgress),
         (workInProgress.flags &= -257),
+        (didPrimaryChildrenDefer = createCapturedValueFromError(
+          Error(
+            "There was an error while hydrating this Suspense boundary. Switched to client rendering."
+          )
+        )),
         retrySuspenseComponentWithoutHydrating(
           current,
           workInProgress,
           renderLanes,
-          {
-            value: Error(
-              "There was an error while hydrating this Suspense boundary. Switched to client rendering."
-            ),
-            source: null,
-            stack: null,
-            digest: null
-          }
+          didPrimaryChildrenDefer
         )
       );
     if (null !== workInProgress.memoizedState)
@@ -5608,17 +5333,16 @@ function updateDehydratedSuspenseComponent(
         "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."
       )),
       (suspenseState.digest = didPrimaryChildrenDefer),
+      (didPrimaryChildrenDefer = createCapturedValueFromError(
+        suspenseState,
+        didPrimaryChildrenDefer,
+        void 0
+      )),
       retrySuspenseComponentWithoutHydrating(
         current,
         workInProgress,
         renderLanes,
-        {
-          value: suspenseState,
-          source: null,
-          stack: null,
-          digest:
-            null != didPrimaryChildrenDefer ? didPrimaryChildrenDefer : null
-        }
+        didPrimaryChildrenDefer
       )
     );
   didPrimaryChildrenDefer = 0 !== (renderLanes & current.childLanes);
@@ -5849,36 +5573,32 @@ function attemptEarlyBailoutIfNoScheduledUpdate(
 ) {
   switch (workInProgress.tag) {
     case 3:
-      pushHostRootContext(workInProgress);
+      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
       break;
     case 27:
     case 5:
       pushHostContext(workInProgress);
       break;
-    case 1:
-      isContextProvider(workInProgress.type) &&
-        pushContextProvider(workInProgress);
-      break;
     case 4:
       pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
       break;
     case 10:
-      var context = workInProgress.type._context,
-        nextValue = workInProgress.memoizedProps.value;
+      var newValue = workInProgress.memoizedProps.value,
+        context = workInProgress.type._context;
       push(valueCursor, context._currentValue2);
-      context._currentValue2 = nextValue;
+      context._currentValue2 = newValue;
       break;
     case 12:
       0 !== (renderLanes & workInProgress.childLanes) &&
         (workInProgress.flags |= 4);
-      context = workInProgress.stateNode;
-      context.effectDuration = 0;
-      context.passiveEffectDuration = 0;
+      newValue = workInProgress.stateNode;
+      newValue.effectDuration = 0;
+      newValue.passiveEffectDuration = 0;
       break;
     case 13:
-      context = workInProgress.memoizedState;
-      if (null !== context) {
-        if (null !== context.dehydrated)
+      newValue = workInProgress.memoizedState;
+      if (null !== newValue) {
+        if (null !== newValue.dehydrated)
           return (
             pushPrimaryTreeSuspenseHandler(workInProgress),
             (workInProgress.flags |= 128),
@@ -5897,9 +5617,9 @@ function attemptEarlyBailoutIfNoScheduledUpdate(
       pushPrimaryTreeSuspenseHandler(workInProgress);
       break;
     case 19:
-      context = 0 !== (renderLanes & workInProgress.childLanes);
+      newValue = 0 !== (renderLanes & workInProgress.childLanes);
       if (0 !== (current.flags & 128)) {
-        if (context)
+        if (newValue)
           return updateSuspenseListComponent(
             current,
             workInProgress,
@@ -5907,13 +5627,13 @@ function attemptEarlyBailoutIfNoScheduledUpdate(
           );
         workInProgress.flags |= 128;
       }
-      nextValue = workInProgress.memoizedState;
-      null !== nextValue &&
-        ((nextValue.rendering = null),
-        (nextValue.tail = null),
-        (nextValue.lastEffect = null));
+      context = workInProgress.memoizedState;
+      null !== context &&
+        ((context.rendering = null),
+        (context.tail = null),
+        (context.lastEffect = null));
       push(suspenseStackCursor, suspenseStackCursor.current);
-      if (context) break;
+      if (newValue) break;
       else return null;
     case 22:
     case 23:
@@ -5924,601 +5644,409 @@ function attemptEarlyBailoutIfNoScheduledUpdate(
   }
   return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
 }
-var valueCursor = createCursor(null),
-  currentlyRenderingFiber = null,
-  lastContextDependency = null,
-  lastFullyObservedContext = null;
-function resetContextDependencies() {
-  lastFullyObservedContext =
-    lastContextDependency =
-    currentlyRenderingFiber =
-      null;
-}
-function popProvider(context) {
-  context._currentValue2 = valueCursor.current;
-  pop(valueCursor);
-}
-function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {
-  for (; null !== parent; ) {
-    var alternate = parent.alternate;
-    (parent.childLanes & renderLanes) !== renderLanes
-      ? ((parent.childLanes |= renderLanes),
-        null !== alternate && (alternate.childLanes |= renderLanes))
-      : null !== alternate &&
-        (alternate.childLanes & renderLanes) !== renderLanes &&
-        (alternate.childLanes |= renderLanes);
-    if (parent === propagationRoot) break;
-    parent = parent.return;
-  }
-}
-function prepareToReadContext(workInProgress, renderLanes) {
-  currentlyRenderingFiber = workInProgress;
-  lastFullyObservedContext = lastContextDependency = null;
-  workInProgress = workInProgress.dependencies;
-  null !== workInProgress &&
-    null !== workInProgress.firstContext &&
-    (0 !== (workInProgress.lanes & renderLanes) && (didReceiveUpdate = !0),
-    (workInProgress.firstContext = null));
-}
-function readContext(context) {
-  return readContextForConsumer(currentlyRenderingFiber, context);
-}
-function readContextDuringReconcilation(consumer, context, renderLanes) {
-  null === currentlyRenderingFiber &&
-    prepareToReadContext(consumer, renderLanes);
-  return readContextForConsumer(consumer, context);
-}
-function readContextForConsumer(consumer, context) {
-  var value = context._currentValue2;
-  if (lastFullyObservedContext !== context)
-    if (
-      ((context = { context: context, memoizedValue: value, next: null }),
-      null === lastContextDependency)
-    ) {
-      if (null === consumer)
-        throw Error(
-          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
+function beginWork(current, workInProgress, renderLanes) {
+  if (null !== current)
+    if (current.memoizedProps !== workInProgress.pendingProps)
+      didReceiveUpdate = !0;
+    else {
+      if (
+        0 === (current.lanes & renderLanes) &&
+        0 === (workInProgress.flags & 128)
+      )
+        return (
+          (didReceiveUpdate = !1),
+          attemptEarlyBailoutIfNoScheduledUpdate(
+            current,
+            workInProgress,
+            renderLanes
+          )
         );
-      lastContextDependency = context;
-      consumer.dependencies = { lanes: 0, firstContext: context };
-    } else lastContextDependency = lastContextDependency.next = context;
-  return value;
-}
-var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
-function handleAsyncAction() {}
-function doesRequireClone(current, completedWork) {
-  if (null !== current && current.child === completedWork.child) return !1;
-  if (0 !== (completedWork.flags & 16)) return !0;
-  for (current = completedWork.child; null !== current; ) {
-    if (0 !== (current.flags & 12854) || 0 !== (current.subtreeFlags & 12854))
-      return !0;
-    current = current.sibling;
-  }
-  return !1;
-}
-function appendAllChildren(
-  parent,
-  workInProgress,
-  needsVisibilityToggle,
-  isHidden
-) {
-  for (var node = workInProgress.child; null !== node; ) {
-    if (5 === node.tag) {
-      var instance = node.stateNode;
-      needsVisibilityToggle &&
-        isHidden &&
-        (instance = cloneHiddenInstance(instance));
-      appendChildNode(parent.node, instance.node);
-    } else if (6 === node.tag) {
-      instance = node.stateNode;
-      if (needsVisibilityToggle && isHidden)
-        throw Error("Not yet implemented.");
-      appendChildNode(parent.node, instance.node);
-    } else if (4 !== node.tag)
-      if (22 === node.tag && null !== node.memoizedState)
-        (instance = node.child),
-          null !== instance && (instance.return = node),
-          appendAllChildren(parent, node, !0, !0);
-      else if (null !== node.child) {
-        node.child.return = node;
-        node = node.child;
-        continue;
-      }
-    if (node === workInProgress) break;
-    for (; null === node.sibling; ) {
-      if (null === node.return || node.return === workInProgress) return;
-      node = node.return;
-    }
-    node.sibling.return = node.return;
-    node = node.sibling;
-  }
-}
-function appendAllChildrenToContainer(
-  containerChildSet,
-  workInProgress,
-  needsVisibilityToggle,
-  isHidden
-) {
-  for (var node = workInProgress.child; null !== node; ) {
-    if (5 === node.tag) {
-      var instance = node.stateNode;
-      needsVisibilityToggle &&
-        isHidden &&
-        (instance = cloneHiddenInstance(instance));
-      appendChildNodeToSet(containerChildSet, instance.node);
-    } else if (6 === node.tag) {
-      instance = node.stateNode;
-      if (needsVisibilityToggle && isHidden)
-        throw Error("Not yet implemented.");
-      appendChildNodeToSet(containerChildSet, instance.node);
-    } else if (4 !== node.tag)
-      if (22 === node.tag && null !== node.memoizedState)
-        (instance = node.child),
-          null !== instance && (instance.return = node),
-          appendAllChildrenToContainer(
-            containerChildSet,
-            node,
-            !(
-              null !== node.memoizedProps &&
-              "manual" === node.memoizedProps.mode
-            ),
-            !0
-          );
-      else if (null !== node.child) {
-        node.child.return = node;
-        node = node.child;
-        continue;
-      }
-    if (node === workInProgress) break;
-    for (; null === node.sibling; ) {
-      if (null === node.return || node.return === workInProgress) return;
-      node = node.return;
+      didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;
     }
-    node.sibling.return = node.return;
-    node = node.sibling;
-  }
-}
-function updateHostContainer(current, workInProgress) {
-  if (doesRequireClone(current, workInProgress)) {
-    current = workInProgress.stateNode;
-    var container = current.containerInfo,
-      newChildSet = createChildNodeSet();
-    appendAllChildrenToContainer(newChildSet, workInProgress, !1, !1);
-    current.pendingChildren = newChildSet;
-    workInProgress.flags |= 4;
-    completeRoot(container, newChildSet);
-  }
-}
-function scheduleRetryEffect(workInProgress, retryQueue) {
-  null !== retryQueue
-    ? (workInProgress.flags |= 4)
-    : workInProgress.flags & 16384 &&
-      ((retryQueue =
-        22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),
-      (workInProgress.lanes |= retryQueue));
-}
-function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
-  switch (renderState.tailMode) {
-    case "hidden":
-      hasRenderedATailFallback = renderState.tail;
-      for (var lastTailNode = null; null !== hasRenderedATailFallback; )
-        null !== hasRenderedATailFallback.alternate &&
-          (lastTailNode = hasRenderedATailFallback),
-          (hasRenderedATailFallback = hasRenderedATailFallback.sibling);
-      null === lastTailNode
-        ? (renderState.tail = null)
-        : (lastTailNode.sibling = null);
-      break;
-    case "collapsed":
-      lastTailNode = renderState.tail;
-      for (var lastTailNode$64 = null; null !== lastTailNode; )
-        null !== lastTailNode.alternate && (lastTailNode$64 = lastTailNode),
-          (lastTailNode = lastTailNode.sibling);
-      null === lastTailNode$64
-        ? hasRenderedATailFallback || null === renderState.tail
-          ? (renderState.tail = null)
-          : (renderState.tail.sibling = null)
-        : (lastTailNode$64.sibling = null);
-  }
-}
-function bubbleProperties(completedWork) {
-  var didBailout =
-      null !== completedWork.alternate &&
-      completedWork.alternate.child === completedWork.child,
-    newChildLanes = 0,
-    subtreeFlags = 0;
-  if (didBailout)
-    if (0 !== (completedWork.mode & 2)) {
-      for (
-        var treeBaseDuration$66 = completedWork.selfBaseDuration,
-          child$67 = completedWork.child;
-        null !== child$67;
-
-      )
-        (newChildLanes |= child$67.lanes | child$67.childLanes),
-          (subtreeFlags |= child$67.subtreeFlags & 31457280),
-          (subtreeFlags |= child$67.flags & 31457280),
-          (treeBaseDuration$66 += child$67.treeBaseDuration),
-          (child$67 = child$67.sibling);
-      completedWork.treeBaseDuration = treeBaseDuration$66;
-    } else
-      for (
-        treeBaseDuration$66 = completedWork.child;
-        null !== treeBaseDuration$66;
-
-      )
-        (newChildLanes |=
-          treeBaseDuration$66.lanes | treeBaseDuration$66.childLanes),
-          (subtreeFlags |= treeBaseDuration$66.subtreeFlags & 31457280),
-          (subtreeFlags |= treeBaseDuration$66.flags & 31457280),
-          (treeBaseDuration$66.return = completedWork),
-          (treeBaseDuration$66 = treeBaseDuration$66.sibling);
-  else if (0 !== (completedWork.mode & 2)) {
-    treeBaseDuration$66 = completedWork.actualDuration;
-    child$67 = completedWork.selfBaseDuration;
-    for (var child = completedWork.child; null !== child; )
-      (newChildLanes |= child.lanes | child.childLanes),
-        (subtreeFlags |= child.subtreeFlags),
-        (subtreeFlags |= child.flags),
-        (treeBaseDuration$66 += child.actualDuration),
-        (child$67 += child.treeBaseDuration),
-        (child = child.sibling);
-    completedWork.actualDuration = treeBaseDuration$66;
-    completedWork.treeBaseDuration = child$67;
-  } else
-    for (
-      treeBaseDuration$66 = completedWork.child;
-      null !== treeBaseDuration$66;
-
-    )
-      (newChildLanes |=
-        treeBaseDuration$66.lanes | treeBaseDuration$66.childLanes),
-        (subtreeFlags |= treeBaseDuration$66.subtreeFlags),
-        (subtreeFlags |= treeBaseDuration$66.flags),
-        (treeBaseDuration$66.return = completedWork),
-        (treeBaseDuration$66 = treeBaseDuration$66.sibling);
-  completedWork.subtreeFlags |= subtreeFlags;
-  completedWork.childLanes = newChildLanes;
-  return didBailout;
-}
-function completeWork(current, workInProgress, renderLanes) {
-  var newProps = workInProgress.pendingProps;
+  else didReceiveUpdate = !1;
+  workInProgress.lanes = 0;
   switch (workInProgress.tag) {
     case 2:
-    case 16:
-    case 15:
-    case 0:
-    case 11:
-    case 7:
-    case 8:
-    case 12:
-    case 9:
-    case 14:
-      return bubbleProperties(workInProgress), null;
-    case 1:
-      return (
-        isContextProvider(workInProgress.type) && popContext(),
-        bubbleProperties(workInProgress),
-        null
-      );
-    case 3:
-      return (
-        (renderLanes = workInProgress.stateNode),
-        popHostContainer(),
-        pop(didPerformWorkStackCursor),
-        pop(contextStackCursor$1),
-        renderLanes.pendingContext &&
-          ((renderLanes.context = renderLanes.pendingContext),
-          (renderLanes.pendingContext = null)),
-        (null !== current && null !== current.child) ||
-          null === current ||
-          (current.memoizedState.isDehydrated &&
-            0 === (workInProgress.flags & 256)) ||
-          ((workInProgress.flags |= 1024),
-          null !== hydrationErrors &&
-            (queueRecoverableErrors(hydrationErrors),
-            (hydrationErrors = null))),
-        updateHostContainer(current, workInProgress),
-        bubbleProperties(workInProgress),
-        null
+      var Component = workInProgress.type;
+      resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress);
+      current = workInProgress.pendingProps;
+      prepareToReadContext(workInProgress, renderLanes);
+      var value = renderWithHooks(
+        null,
+        workInProgress,
+        Component,
+        current,
+        void 0,
+        renderLanes
       );
-    case 26:
-    case 27:
-    case 5:
-      popHostContext(workInProgress);
-      renderLanes = workInProgress.type;
-      if (null !== current && null != workInProgress.stateNode) {
-        renderLanes = current.stateNode;
-        var oldProps = current.memoizedProps,
-          requiresClone = doesRequireClone(current, workInProgress);
-        if (requiresClone || oldProps !== newProps) {
-          b: {
-            oldProps = diffProperties(
-              null,
-              oldProps,
-              newProps,
-              renderLanes.canonical.viewConfig.validAttributes
-            );
-            renderLanes.canonical.currentProps = newProps;
-            newProps = renderLanes.node;
-            if (requiresClone)
-              newProps =
-                null !== oldProps
-                  ? cloneNodeWithNewChildrenAndProps(newProps, oldProps)
-                  : cloneNodeWithNewChildren(newProps);
-            else if (null !== oldProps)
-              newProps = cloneNodeWithNewProps(newProps, oldProps);
-            else {
-              newProps = renderLanes;
-              break b;
-            }
-            newProps = { node: newProps, canonical: renderLanes.canonical };
-          }
-          newProps === renderLanes
-            ? (workInProgress.stateNode = renderLanes)
-            : ((workInProgress.stateNode = newProps),
-              requiresClone
-                ? appendAllChildren(newProps, workInProgress, !1, !1)
-                : (workInProgress.flags |= 4));
-        } else workInProgress.stateNode = renderLanes;
-        current.ref !== workInProgress.ref && (workInProgress.flags |= 2097664);
-      } else {
-        if (!newProps) {
-          if (null === workInProgress.stateNode)
-            throw Error(
-              "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
+      workInProgress.flags |= 1;
+      "object" === typeof value &&
+      null !== value &&
+      "function" === typeof value.render &&
+      void 0 === value.$$typeof
+        ? ((workInProgress.tag = 1),
+          (workInProgress.memoizedState = null),
+          (workInProgress.updateQueue = null),
+          (workInProgress.memoizedState =
+            null !== value.state && void 0 !== value.state
+              ? value.state
+              : null),
+          initializeUpdateQueue(workInProgress),
+          (value.updater = classComponentUpdater),
+          (workInProgress.stateNode = value),
+          (value._reactInternals = workInProgress),
+          mountClassInstance(workInProgress, Component, current, renderLanes),
+          (workInProgress = finishClassComponent(
+            null,
+            workInProgress,
+            Component,
+            !0,
+            !1,
+            renderLanes
+          )))
+        : ((workInProgress.tag = 0),
+          reconcileChildren(null, workInProgress, value, renderLanes),
+          (workInProgress = workInProgress.child));
+      return workInProgress;
+    case 16:
+      Component = workInProgress.elementType;
+      a: {
+        resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress);
+        current = workInProgress.pendingProps;
+        value = Component._init;
+        Component = value(Component._payload);
+        workInProgress.type = Component;
+        value = workInProgress.tag = resolveLazyComponentTag(Component);
+        current = resolveDefaultProps(Component, current);
+        switch (value) {
+          case 0:
+            workInProgress = updateFunctionComponent(
+              null,
+              workInProgress,
+              Component,
+              current,
+              renderLanes
             );
-          bubbleProperties(workInProgress);
-          return null;
+            break a;
+          case 1:
+            workInProgress = updateClassComponent(
+              null,
+              workInProgress,
+              Component,
+              current,
+              renderLanes
+            );
+            break a;
+          case 11:
+            workInProgress = updateForwardRef(
+              null,
+              workInProgress,
+              Component,
+              current,
+              renderLanes
+            );
+            break a;
+          case 14:
+            workInProgress = updateMemoComponent(
+              null,
+              workInProgress,
+              Component,
+              resolveDefaultProps(Component.type, current),
+              renderLanes
+            );
+            break a;
         }
-        requiresClone = rootInstanceStackCursor.current;
-        current = nextReactTag;
-        nextReactTag += 2;
-        renderLanes = getViewConfigForType(renderLanes);
-        oldProps = diffProperties(
-          null,
-          emptyObject,
-          newProps,
-          renderLanes.validAttributes
+        throw Error(
+          "Element type is invalid. Received a promise that resolves to: " +
+            Component +
+            ". Lazy element type must resolve to a class or function."
         );
-        requiresClone = createNode(
+      }
+      return workInProgress;
+    case 0:
+      return (
+        (Component = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === Component
+            ? value
+            : resolveDefaultProps(Component, value)),
+        updateFunctionComponent(
           current,
-          renderLanes.uiViewClassName,
-          requiresClone,
-          oldProps,
-          workInProgress
-        );
-        oldProps = ReactNativePrivateInterface.createPublicInstance(
+          workInProgress,
+          Component,
+          value,
+          renderLanes
+        )
+      );
+    case 1:
+      return (
+        (Component = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === Component
+            ? value
+            : resolveDefaultProps(Component, value)),
+        updateClassComponent(
           current,
-          renderLanes,
-          workInProgress
-        );
-        current = {
-          node: requiresClone,
-          canonical: {
-            nativeTag: current,
-            viewConfig: renderLanes,
-            currentProps: newProps,
-            internalInstanceHandle: workInProgress,
-            publicInstance: oldProps
-          }
-        };
-        appendAllChildren(current, workInProgress, !1, !1);
-        workInProgress.stateNode = current;
-        null !== workInProgress.ref && (workInProgress.flags |= 2097664);
-      }
-      bubbleProperties(workInProgress);
-      workInProgress.flags &= -16777217;
-      return null;
+          workInProgress,
+          Component,
+          value,
+          renderLanes
+        )
+      );
+    case 3:
+      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
+      if (null === current)
+        throw Error("Should have a current fiber. This is a bug in React.");
+      value = workInProgress.pendingProps;
+      Component = workInProgress.memoizedState.element;
+      cloneUpdateQueue(current, workInProgress);
+      processUpdateQueue(workInProgress, value, null, renderLanes);
+      value = workInProgress.memoizedState.element;
+      value === Component
+        ? (workInProgress = bailoutOnAlreadyFinishedWork(
+            current,
+            workInProgress,
+            renderLanes
+          ))
+        : (reconcileChildren(current, workInProgress, value, renderLanes),
+          (workInProgress = workInProgress.child));
+      return workInProgress;
+    case 26:
+    case 27:
+    case 5:
+      return (
+        pushHostContext(workInProgress),
+        (Component = workInProgress.pendingProps.children),
+        markRef(current, workInProgress),
+        reconcileChildren(current, workInProgress, Component, renderLanes),
+        workInProgress.child
+      );
     case 6:
-      if (current && null != workInProgress.stateNode)
-        current.memoizedProps !== newProps
-          ? ((workInProgress.stateNode = createTextInstance(
-              newProps,
-              rootInstanceStackCursor.current,
-              contextStackCursor.current,
-              workInProgress
-            )),
-            (workInProgress.flags |= 4))
-          : (workInProgress.stateNode = current.stateNode);
-      else {
-        if ("string" !== typeof newProps && null === workInProgress.stateNode)
-          throw Error(
-            "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
-          );
-        workInProgress.stateNode = createTextInstance(
-          newProps,
-          rootInstanceStackCursor.current,
-          contextStackCursor.current,
-          workInProgress
-        );
-      }
-      bubbleProperties(workInProgress);
       return null;
     case 13:
-      popSuspenseHandler(workInProgress);
-      newProps = workInProgress.memoizedState;
-      if (
-        null === current ||
-        (null !== current.memoizedState &&
-          null !== current.memoizedState.dehydrated)
-      ) {
-        if (null !== newProps && null !== newProps.dehydrated) {
-          if (null === current) {
-            throw Error(
-              "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
-            );
-            throw Error(
-              "Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
-            );
-          }
-          0 === (workInProgress.flags & 128) &&
-            (workInProgress.memoizedState = null);
-          workInProgress.flags |= 4;
-          bubbleProperties(workInProgress);
-          0 !== (workInProgress.mode & 2) &&
-            null !== newProps &&
-            ((requiresClone = workInProgress.child),
-            null !== requiresClone &&
-              (workInProgress.treeBaseDuration -=
-                requiresClone.treeBaseDuration));
-          requiresClone = !1;
-        } else
-          null !== hydrationErrors &&
-            (queueRecoverableErrors(hydrationErrors), (hydrationErrors = null)),
-            (requiresClone = !0);
-        if (!requiresClone)
-          return workInProgress.flags & 256 ? workInProgress : null;
-      }
-      if (0 !== (workInProgress.flags & 128))
-        return (
-          (workInProgress.lanes = renderLanes),
-          0 !== (workInProgress.mode & 2) &&
-            transferActualDuration(workInProgress),
-          workInProgress
-        );
-      renderLanes = null !== newProps;
-      renderLanes !== (null !== current && null !== current.memoizedState) &&
-        renderLanes &&
-        (workInProgress.child.flags |= 8192);
-      scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
-      bubbleProperties(workInProgress);
-      0 !== (workInProgress.mode & 2) &&
-        renderLanes &&
-        ((current = workInProgress.child),
-        null !== current &&
-          (workInProgress.treeBaseDuration -= current.treeBaseDuration));
-      return null;
+      return updateSuspenseComponent(current, workInProgress, renderLanes);
     case 4:
       return (
-        popHostContainer(),
-        updateHostContainer(current, workInProgress),
-        bubbleProperties(workInProgress),
-        null
+        pushHostContainer(
+          workInProgress,
+          workInProgress.stateNode.containerInfo
+        ),
+        (Component = workInProgress.pendingProps),
+        null === current
+          ? (workInProgress.child = reconcileChildFibers(
+              workInProgress,
+              null,
+              Component,
+              renderLanes
+            ))
+          : reconcileChildren(current, workInProgress, Component, renderLanes),
+        workInProgress.child
       );
-    case 10:
+    case 11:
       return (
-        popProvider(workInProgress.type._context),
-        bubbleProperties(workInProgress),
-        null
+        (Component = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === Component
+            ? value
+            : resolveDefaultProps(Component, value)),
+        updateForwardRef(current, workInProgress, Component, value, renderLanes)
       );
-    case 17:
+    case 7:
       return (
-        isContextProvider(workInProgress.type) && popContext(),
-        bubbleProperties(workInProgress),
-        null
+        reconcileChildren(
+          current,
+          workInProgress,
+          workInProgress.pendingProps,
+          renderLanes
+        ),
+        workInProgress.child
       );
-    case 19:
-      pop(suspenseStackCursor);
-      requiresClone = workInProgress.memoizedState;
-      if (null === requiresClone) return bubbleProperties(workInProgress), null;
-      newProps = 0 !== (workInProgress.flags & 128);
-      oldProps = requiresClone.rendering;
-      if (null === oldProps)
-        if (newProps) cutOffTailIfNeeded(requiresClone, !1);
-        else {
-          if (
-            0 !== workInProgressRootExitStatus ||
-            (null !== current && 0 !== (current.flags & 128))
-          )
-            for (current = workInProgress.child; null !== current; ) {
-              oldProps = findFirstSuspended(current);
-              if (null !== oldProps) {
-                workInProgress.flags |= 128;
-                cutOffTailIfNeeded(requiresClone, !1);
-                current = oldProps.updateQueue;
-                workInProgress.updateQueue = current;
-                scheduleRetryEffect(workInProgress, current);
-                workInProgress.subtreeFlags = 0;
-                current = renderLanes;
-                for (renderLanes = workInProgress.child; null !== renderLanes; )
-                  resetWorkInProgress(renderLanes, current),
-                    (renderLanes = renderLanes.sibling);
-                push(
-                  suspenseStackCursor,
-                  (suspenseStackCursor.current & 1) | 2
-                );
-                return workInProgress.child;
-              }
-              current = current.sibling;
+    case 8:
+      return (
+        reconcileChildren(
+          current,
+          workInProgress,
+          workInProgress.pendingProps.children,
+          renderLanes
+        ),
+        workInProgress.child
+      );
+    case 12:
+      return (
+        (workInProgress.flags |= 4),
+        (Component = workInProgress.stateNode),
+        (Component.effectDuration = 0),
+        (Component.passiveEffectDuration = 0),
+        reconcileChildren(
+          current,
+          workInProgress,
+          workInProgress.pendingProps.children,
+          renderLanes
+        ),
+        workInProgress.child
+      );
+    case 10:
+      a: {
+        Component = workInProgress.type._context;
+        value = workInProgress.pendingProps;
+        var oldProps = workInProgress.memoizedProps,
+          newValue = value.value;
+        push(valueCursor, Component._currentValue2);
+        Component._currentValue2 = newValue;
+        if (null !== oldProps)
+          if (objectIs(oldProps.value, newValue)) {
+            if (oldProps.children === value.children) {
+              workInProgress = bailoutOnAlreadyFinishedWork(
+                current,
+                workInProgress,
+                renderLanes
+              );
+              break a;
             }
-          null !== requiresClone.tail &&
-            now$1() > workInProgressRootRenderTargetTime &&
-            ((workInProgress.flags |= 128),
-            (newProps = !0),
-            cutOffTailIfNeeded(requiresClone, !1),
-            (workInProgress.lanes = 4194304));
-        }
-      else {
-        if (!newProps)
-          if (((current = findFirstSuspended(oldProps)), null !== current)) {
-            if (
-              ((workInProgress.flags |= 128),
-              (newProps = !0),
-              (current = current.updateQueue),
-              (workInProgress.updateQueue = current),
-              scheduleRetryEffect(workInProgress, current),
-              cutOffTailIfNeeded(requiresClone, !0),
-              null === requiresClone.tail &&
-                "hidden" === requiresClone.tailMode &&
-                !oldProps.alternate)
-            )
-              return bubbleProperties(workInProgress), null;
           } else
-            2 * now$1() - requiresClone.renderingStartTime >
-              workInProgressRootRenderTargetTime &&
-              536870912 !== renderLanes &&
-              ((workInProgress.flags |= 128),
-              (newProps = !0),
-              cutOffTailIfNeeded(requiresClone, !1),
-              (workInProgress.lanes = 4194304));
-        requiresClone.isBackwards
-          ? ((oldProps.sibling = workInProgress.child),
-            (workInProgress.child = oldProps))
-          : ((current = requiresClone.last),
-            null !== current
-              ? (current.sibling = oldProps)
-              : (workInProgress.child = oldProps),
-            (requiresClone.last = oldProps));
+            for (
+              oldProps = workInProgress.child,
+                null !== oldProps && (oldProps.return = workInProgress);
+              null !== oldProps;
+
+            ) {
+              var list = oldProps.dependencies;
+              if (null !== list) {
+                newValue = oldProps.child;
+                for (
+                  var dependency = list.firstContext;
+                  null !== dependency;
+
+                ) {
+                  if (dependency.context === Component) {
+                    if (1 === oldProps.tag) {
+                      dependency = createUpdate(renderLanes & -renderLanes);
+                      dependency.tag = 2;
+                      var updateQueue = oldProps.updateQueue;
+                      if (null !== updateQueue) {
+                        updateQueue = updateQueue.shared;
+                        var pending = updateQueue.pending;
+                        null === pending
+                          ? (dependency.next = dependency)
+                          : ((dependency.next = pending.next),
+                            (pending.next = dependency));
+                        updateQueue.pending = dependency;
+                      }
+                    }
+                    oldProps.lanes |= renderLanes;
+                    dependency = oldProps.alternate;
+                    null !== dependency && (dependency.lanes |= renderLanes);
+                    scheduleContextWorkOnParentPath(
+                      oldProps.return,
+                      renderLanes,
+                      workInProgress
+                    );
+                    list.lanes |= renderLanes;
+                    break;
+                  }
+                  dependency = dependency.next;
+                }
+              } else if (10 === oldProps.tag)
+                newValue =
+                  oldProps.type === workInProgress.type ? null : oldProps.child;
+              else if (18 === oldProps.tag) {
+                newValue = oldProps.return;
+                if (null === newValue)
+                  throw Error(
+                    "We just came from a parent so we must have had a parent. This is a bug in React."
+                  );
+                newValue.lanes |= renderLanes;
+                list = newValue.alternate;
+                null !== list && (list.lanes |= renderLanes);
+                scheduleContextWorkOnParentPath(
+                  newValue,
+                  renderLanes,
+                  workInProgress
+                );
+                newValue = oldProps.sibling;
+              } else newValue = oldProps.child;
+              if (null !== newValue) newValue.return = oldProps;
+              else
+                for (newValue = oldProps; null !== newValue; ) {
+                  if (newValue === workInProgress) {
+                    newValue = null;
+                    break;
+                  }
+                  oldProps = newValue.sibling;
+                  if (null !== oldProps) {
+                    oldProps.return = newValue.return;
+                    newValue = oldProps;
+                    break;
+                  }
+                  newValue = newValue.return;
+                }
+              oldProps = newValue;
+            }
+        reconcileChildren(current, workInProgress, value.children, renderLanes);
+        workInProgress = workInProgress.child;
       }
-      if (null !== requiresClone.tail)
-        return (
-          (workInProgress = requiresClone.tail),
-          (requiresClone.rendering = workInProgress),
-          (requiresClone.tail = workInProgress.sibling),
-          (requiresClone.renderingStartTime = now$1()),
-          (workInProgress.sibling = null),
-          (current = suspenseStackCursor.current),
-          push(suspenseStackCursor, newProps ? (current & 1) | 2 : current & 1),
-          workInProgress
-        );
-      bubbleProperties(workInProgress);
-      return null;
-    case 22:
-    case 23:
+      return workInProgress;
+    case 9:
       return (
-        popSuspenseHandler(workInProgress),
-        popHiddenContext(),
-        (newProps = null !== workInProgress.memoizedState),
-        null !== current
-          ? (null !== current.memoizedState) !== newProps &&
-            (workInProgress.flags |= 8192)
-          : newProps && (workInProgress.flags |= 8192),
-        newProps && 0 !== (workInProgress.mode & 1)
-          ? 0 !== (renderLanes & 536870912) &&
-            0 === (workInProgress.flags & 128) &&
-            (bubbleProperties(workInProgress),
-            workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192))
-          : bubbleProperties(workInProgress),
-        (current = workInProgress.updateQueue),
-        null !== current &&
-          scheduleRetryEffect(workInProgress, current.retryQueue),
-        null
+        (value = workInProgress.type),
+        (Component = workInProgress.pendingProps.children),
+        prepareToReadContext(workInProgress, renderLanes),
+        (value = readContext(value)),
+        (Component = Component(value)),
+        (workInProgress.flags |= 1),
+        reconcileChildren(current, workInProgress, Component, renderLanes),
+        workInProgress.child
       );
-    case 24:
-      return null;
-    case 25:
-      return null;
+    case 14:
+      return (
+        (Component = workInProgress.type),
+        (value = resolveDefaultProps(Component, workInProgress.pendingProps)),
+        (value = resolveDefaultProps(Component.type, value)),
+        updateMemoComponent(
+          current,
+          workInProgress,
+          Component,
+          value,
+          renderLanes
+        )
+      );
+    case 15:
+      return updateSimpleMemoComponent(
+        current,
+        workInProgress,
+        workInProgress.type,
+        workInProgress.pendingProps,
+        renderLanes
+      );
+    case 17:
+      return (
+        (Component = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === Component
+            ? value
+            : resolveDefaultProps(Component, value)),
+        resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress),
+        (workInProgress.tag = 1),
+        prepareToReadContext(workInProgress, renderLanes),
+        constructClassInstance(workInProgress, Component, value),
+        mountClassInstance(workInProgress, Component, value, renderLanes),
+        finishClassComponent(
+          null,
+          workInProgress,
+          Component,
+          !0,
+          !1,
+          renderLanes
+        )
+      );
+    case 19:
+      return updateSuspenseListComponent(current, workInProgress, renderLanes);
+    case 22:
+      return updateOffscreenComponent(current, workInProgress, renderLanes);
   }
   throw Error(
     "Unknown unit of work tag (" +
@@ -6526,2847 +6054,3013 @@ function completeWork(current, workInProgress, renderLanes) {
       "). This error is likely caused by a bug in React. Please file an issue."
   );
 }
-function unwindWork(current, workInProgress) {
-  switch (workInProgress.tag) {
-    case 1:
-      return (
-        isContextProvider(workInProgress.type) && popContext(),
-        (current = workInProgress.flags),
-        current & 65536
-          ? ((workInProgress.flags = (current & -65537) | 128),
-            0 !== (workInProgress.mode & 2) &&
-              transferActualDuration(workInProgress),
-            workInProgress)
-          : null
-      );
-    case 3:
-      return (
-        popHostContainer(),
-        pop(didPerformWorkStackCursor),
-        pop(contextStackCursor$1),
-        (current = workInProgress.flags),
-        0 !== (current & 65536) && 0 === (current & 128)
-          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
-          : null
-      );
-    case 26:
-    case 27:
-    case 5:
-      return popHostContext(workInProgress), null;
-    case 13:
-      popSuspenseHandler(workInProgress);
-      current = workInProgress.memoizedState;
-      if (
-        null !== current &&
-        null !== current.dehydrated &&
-        null === workInProgress.alternate
-      )
-        throw Error(
-          "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
-        );
-      current = workInProgress.flags;
-      return current & 65536
-        ? ((workInProgress.flags = (current & -65537) | 128),
-          0 !== (workInProgress.mode & 2) &&
-            transferActualDuration(workInProgress),
-          workInProgress)
-        : null;
-    case 19:
-      return pop(suspenseStackCursor), null;
-    case 4:
-      return popHostContainer(), null;
-    case 10:
-      return popProvider(workInProgress.type._context), null;
-    case 22:
-    case 23:
-      return (
-        popSuspenseHandler(workInProgress),
-        popHiddenContext(),
-        (current = workInProgress.flags),
-        current & 65536
-          ? ((workInProgress.flags = (current & -65537) | 128),
-            0 !== (workInProgress.mode & 2) &&
-              transferActualDuration(workInProgress),
-            workInProgress)
-          : null
-      );
-    case 24:
-      return null;
-    case 25:
-      return null;
-    default:
-      return null;
-  }
+var valueCursor = createCursor(null),
+  currentlyRenderingFiber = null,
+  lastContextDependency = null,
+  lastFullyObservedContext = null;
+function resetContextDependencies() {
+  lastFullyObservedContext =
+    lastContextDependency =
+    currentlyRenderingFiber =
+      null;
 }
-function unwindInterruptedWork(current, interruptedWork) {
-  switch (interruptedWork.tag) {
-    case 1:
-      current = interruptedWork.type.childContextTypes;
-      null !== current && void 0 !== current && popContext();
-      break;
-    case 3:
-      popHostContainer();
-      pop(didPerformWorkStackCursor);
-      pop(contextStackCursor$1);
-      break;
-    case 26:
-    case 27:
-    case 5:
-      popHostContext(interruptedWork);
-      break;
-    case 4:
-      popHostContainer();
-      break;
-    case 13:
-      popSuspenseHandler(interruptedWork);
-      break;
-    case 19:
-      pop(suspenseStackCursor);
-      break;
-    case 10:
-      popProvider(interruptedWork.type._context);
-      break;
-    case 22:
-    case 23:
-      popSuspenseHandler(interruptedWork), popHiddenContext();
+function popProvider(context) {
+  context._currentValue2 = valueCursor.current;
+  pop(valueCursor);
+}
+function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {
+  for (; null !== parent; ) {
+    var alternate = parent.alternate;
+    (parent.childLanes & renderLanes) !== renderLanes
+      ? ((parent.childLanes |= renderLanes),
+        null !== alternate && (alternate.childLanes |= renderLanes))
+      : null !== alternate &&
+        (alternate.childLanes & renderLanes) !== renderLanes &&
+        (alternate.childLanes |= renderLanes);
+    if (parent === propagationRoot) break;
+    parent = parent.return;
   }
 }
-var offscreenSubtreeIsHidden = !1,
-  offscreenSubtreeWasHidden = !1,
-  PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
-  nextEffect = null,
-  inProgressLanes = null,
-  inProgressRoot = null;
-function shouldProfile(current) {
-  return 0 !== (current.mode & 2) && 0 !== (executionContext & 4);
+function prepareToReadContext(workInProgress, renderLanes) {
+  currentlyRenderingFiber = workInProgress;
+  lastFullyObservedContext = lastContextDependency = null;
+  workInProgress = workInProgress.dependencies;
+  null !== workInProgress &&
+    null !== workInProgress.firstContext &&
+    (0 !== (workInProgress.lanes & renderLanes) && (didReceiveUpdate = !0),
+    (workInProgress.firstContext = null));
 }
-function callComponentWillUnmountWithTimer(current, instance) {
-  instance.props = current.memoizedProps;
-  instance.state = current.memoizedState;
-  if (shouldProfile(current))
-    try {
-      startLayoutEffectTimer(), instance.componentWillUnmount();
-    } finally {
-      recordLayoutEffectDuration(current);
-    }
-  else instance.componentWillUnmount();
+function readContext(context) {
+  return readContextForConsumer(currentlyRenderingFiber, context);
 }
-function safelyAttachRef(current, nearestMountedAncestor) {
-  try {
-    var ref = current.ref;
-    if (null !== ref) {
-      var instance = current.stateNode;
-      switch (current.tag) {
-        case 26:
-        case 27:
-        case 5:
-          var instanceToUse = getPublicInstance(instance);
-          break;
-        default:
-          instanceToUse = instance;
-      }
-      if ("function" === typeof ref)
-        if (shouldProfile(current))
-          try {
-            startLayoutEffectTimer(), (current.refCleanup = ref(instanceToUse));
-          } finally {
-            recordLayoutEffectDuration(current);
-          }
-        else current.refCleanup = ref(instanceToUse);
-      else ref.current = instanceToUse;
-    }
-  } catch (error) {
-    captureCommitPhaseError(current, nearestMountedAncestor, error);
+function readContextDuringReconciliation(consumer, context, renderLanes) {
+  null === currentlyRenderingFiber &&
+    prepareToReadContext(consumer, renderLanes);
+  return readContextForConsumer(consumer, context);
+}
+function readContextForConsumer(consumer, context) {
+  var value = context._currentValue2;
+  if (lastFullyObservedContext !== context)
+    if (
+      ((context = { context: context, memoizedValue: value, next: null }),
+      null === lastContextDependency)
+    ) {
+      if (null === consumer)
+        throw Error(
+          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
+        );
+      lastContextDependency = context;
+      consumer.dependencies = { lanes: 0, firstContext: context };
+    } else lastContextDependency = lastContextDependency.next = context;
+  return value;
+}
+var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
+function handleAsyncAction() {}
+function doesRequireClone(current, completedWork) {
+  if (null !== current && current.child === completedWork.child) return !1;
+  if (0 !== (completedWork.flags & 16)) return !0;
+  for (current = completedWork.child; null !== current; ) {
+    if (0 !== (current.flags & 12854) || 0 !== (current.subtreeFlags & 12854))
+      return !0;
+    current = current.sibling;
   }
+  return !1;
 }
-function safelyDetachRef(current, nearestMountedAncestor) {
-  var ref = current.ref,
-    refCleanup = current.refCleanup;
-  if (null !== ref)
-    if ("function" === typeof refCleanup)
-      try {
-        if (shouldProfile(current))
-          try {
-            startLayoutEffectTimer(), refCleanup();
-          } finally {
-            recordLayoutEffectDuration(current);
-          }
-        else refCleanup();
-      } catch (error) {
-        captureCommitPhaseError(current, nearestMountedAncestor, error);
-      } finally {
-        (current.refCleanup = null),
-          (current = current.alternate),
-          null != current && (current.refCleanup = null);
-      }
-    else if ("function" === typeof ref)
-      try {
-        if (shouldProfile(current))
-          try {
-            startLayoutEffectTimer(), ref(null);
-          } finally {
-            recordLayoutEffectDuration(current);
-          }
-        else ref(null);
-      } catch (error$85) {
-        captureCommitPhaseError(current, nearestMountedAncestor, error$85);
+function appendAllChildren(
+  parent,
+  workInProgress,
+  needsVisibilityToggle,
+  isHidden
+) {
+  for (var node = workInProgress.child; null !== node; ) {
+    if (5 === node.tag) {
+      var instance = node.stateNode;
+      needsVisibilityToggle &&
+        isHidden &&
+        (instance = cloneHiddenInstance(instance));
+      appendChildNode(parent.node, instance.node);
+    } else if (6 === node.tag) {
+      instance = node.stateNode;
+      if (needsVisibilityToggle && isHidden)
+        throw Error("Not yet implemented.");
+      appendChildNode(parent.node, instance.node);
+    } else if (4 !== node.tag)
+      if (22 === node.tag && null !== node.memoizedState)
+        (instance = node.child),
+          null !== instance && (instance.return = node),
+          appendAllChildren(parent, node, !0, !0);
+      else if (null !== node.child) {
+        node.child.return = node;
+        node = node.child;
+        continue;
       }
-    else ref.current = null;
-}
-function safelyCallDestroy(current, nearestMountedAncestor, destroy) {
-  try {
-    destroy();
-  } catch (error) {
-    captureCommitPhaseError(current, nearestMountedAncestor, error);
+    if (node === workInProgress) break;
+    for (; null === node.sibling; ) {
+      if (null === node.return || node.return === workInProgress) return;
+      node = node.return;
+    }
+    node.sibling.return = node.return;
+    node = node.sibling;
   }
 }
-var shouldFireAfterActiveInstanceBlur = !1;
-function commitBeforeMutationEffects(root, firstChild) {
-  for (nextEffect = firstChild; null !== nextEffect; )
-    if (
-      ((root = nextEffect),
-      (firstChild = root.child),
-      0 !== (root.subtreeFlags & 1028) && null !== firstChild)
-    )
-      (firstChild.return = root), (nextEffect = firstChild);
-    else
-      for (; null !== nextEffect; ) {
-        root = nextEffect;
-        try {
-          var current = root.alternate,
-            flags = root.flags;
-          switch (root.tag) {
-            case 0:
-              break;
-            case 11:
-            case 15:
-              break;
-            case 1:
-              if (0 !== (flags & 1024) && null !== current) {
-                var prevProps = current.memoizedProps,
-                  prevState = current.memoizedState,
-                  instance = root.stateNode,
-                  snapshot = instance.getSnapshotBeforeUpdate(
-                    root.elementType === root.type
-                      ? prevProps
-                      : resolveDefaultProps(root.type, prevProps),
-                    prevState
-                  );
-                instance.__reactInternalSnapshotBeforeUpdate = snapshot;
-              }
-              break;
-            case 3:
-              break;
-            case 5:
-            case 26:
-            case 27:
-            case 6:
-            case 4:
-            case 17:
-              break;
-            default:
-              if (0 !== (flags & 1024))
-                throw Error(
-                  "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
-                );
-          }
-        } catch (error) {
-          captureCommitPhaseError(root, root.return, error);
-        }
-        firstChild = root.sibling;
-        if (null !== firstChild) {
-          firstChild.return = root.return;
-          nextEffect = firstChild;
-          break;
-        }
-        nextEffect = root.return;
-      }
-  current = shouldFireAfterActiveInstanceBlur;
-  shouldFireAfterActiveInstanceBlur = !1;
-  return current;
-}
-function commitHookEffectListUnmount(
-  flags,
-  finishedWork,
-  nearestMountedAncestor
+function appendAllChildrenToContainer(
+  containerChildSet,
+  workInProgress,
+  needsVisibilityToggle,
+  isHidden
 ) {
-  var updateQueue = finishedWork.updateQueue;
-  updateQueue = null !== updateQueue ? updateQueue.lastEffect : null;
-  if (null !== updateQueue) {
-    var effect = (updateQueue = updateQueue.next);
-    do {
-      if ((effect.tag & flags) === flags) {
-        var inst = effect.inst,
-          destroy = inst.destroy;
-        void 0 !== destroy &&
-          ((inst.destroy = void 0),
-          safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy));
+  for (var node = workInProgress.child; null !== node; ) {
+    if (5 === node.tag) {
+      var instance = node.stateNode;
+      needsVisibilityToggle &&
+        isHidden &&
+        (instance = cloneHiddenInstance(instance));
+      appendChildNodeToSet(containerChildSet, instance.node);
+    } else if (6 === node.tag) {
+      instance = node.stateNode;
+      if (needsVisibilityToggle && isHidden)
+        throw Error("Not yet implemented.");
+      appendChildNodeToSet(containerChildSet, instance.node);
+    } else if (4 !== node.tag)
+      if (22 === node.tag && null !== node.memoizedState)
+        (instance = node.child),
+          null !== instance && (instance.return = node),
+          appendAllChildrenToContainer(
+            containerChildSet,
+            node,
+            !(
+              null !== node.memoizedProps &&
+              "manual" === node.memoizedProps.mode
+            ),
+            !0
+          );
+      else if (null !== node.child) {
+        node.child.return = node;
+        node = node.child;
+        continue;
       }
-      effect = effect.next;
-    } while (effect !== updateQueue);
+    if (node === workInProgress) break;
+    for (; null === node.sibling; ) {
+      if (null === node.return || node.return === workInProgress) return;
+      node = node.return;
+    }
+    node.sibling.return = node.return;
+    node = node.sibling;
   }
 }
-function commitHookEffectListMount(flags, finishedWork) {
-  finishedWork = finishedWork.updateQueue;
-  finishedWork = null !== finishedWork ? finishedWork.lastEffect : null;
-  if (null !== finishedWork) {
-    var effect = (finishedWork = finishedWork.next);
-    do {
-      if ((effect.tag & flags) === flags) {
-        var create$86 = effect.create,
-          inst = effect.inst;
-        create$86 = create$86();
-        inst.destroy = create$86;
-      }
-      effect = effect.next;
-    } while (effect !== finishedWork);
+function updateHostContainer(current, workInProgress) {
+  if (doesRequireClone(current, workInProgress)) {
+    current = workInProgress.stateNode;
+    var container = current.containerInfo,
+      newChildSet = createChildNodeSet();
+    appendAllChildrenToContainer(newChildSet, workInProgress, !1, !1);
+    current.pendingChildren = newChildSet;
+    workInProgress.flags |= 4;
+    completeRoot(container, newChildSet);
   }
 }
-function commitHookLayoutEffects(finishedWork, hookFlags) {
-  if (shouldProfile(finishedWork)) {
-    try {
-      startLayoutEffectTimer(),
-        commitHookEffectListMount(hookFlags, finishedWork);
-    } catch (error) {
-      captureCommitPhaseError(finishedWork, finishedWork.return, error);
-    }
-    recordLayoutEffectDuration(finishedWork);
-  } else
-    try {
-      commitHookEffectListMount(hookFlags, finishedWork);
-    } catch (error$88) {
-      captureCommitPhaseError(finishedWork, finishedWork.return, error$88);
-    }
+function scheduleRetryEffect(workInProgress, retryQueue) {
+  null !== retryQueue
+    ? (workInProgress.flags |= 4)
+    : workInProgress.flags & 16384 &&
+      ((retryQueue =
+        22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),
+      (workInProgress.lanes |= retryQueue));
 }
-function commitClassCallbacks(finishedWork) {
-  var updateQueue = finishedWork.updateQueue;
-  if (null !== updateQueue) {
-    var instance = finishedWork.stateNode;
-    try {
-      commitCallbacks(updateQueue, instance);
-    } catch (error) {
-      captureCommitPhaseError(finishedWork, finishedWork.return, error);
-    }
+function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
+  switch (renderState.tailMode) {
+    case "hidden":
+      hasRenderedATailFallback = renderState.tail;
+      for (var lastTailNode = null; null !== hasRenderedATailFallback; )
+        null !== hasRenderedATailFallback.alternate &&
+          (lastTailNode = hasRenderedATailFallback),
+          (hasRenderedATailFallback = hasRenderedATailFallback.sibling);
+      null === lastTailNode
+        ? (renderState.tail = null)
+        : (lastTailNode.sibling = null);
+      break;
+    case "collapsed":
+      lastTailNode = renderState.tail;
+      for (var lastTailNode$64 = null; null !== lastTailNode; )
+        null !== lastTailNode.alternate && (lastTailNode$64 = lastTailNode),
+          (lastTailNode = lastTailNode.sibling);
+      null === lastTailNode$64
+        ? hasRenderedATailFallback || null === renderState.tail
+          ? (renderState.tail = null)
+          : (renderState.tail.sibling = null)
+        : (lastTailNode$64.sibling = null);
   }
 }
-function commitHostComponentMount(finishedWork) {
-  try {
-    throw Error(
-      "The current renderer does not support mutation. This error is likely caused by a bug in React. Please file an issue."
-    );
-  } catch (error) {
-    captureCommitPhaseError(finishedWork, finishedWork.return, error);
-  }
+function bubbleProperties(completedWork) {
+  var didBailout =
+      null !== completedWork.alternate &&
+      completedWork.alternate.child === completedWork.child,
+    newChildLanes = 0,
+    subtreeFlags = 0;
+  if (didBailout)
+    if (0 !== (completedWork.mode & 2)) {
+      for (
+        var treeBaseDuration$66 = completedWork.selfBaseDuration,
+          child$67 = completedWork.child;
+        null !== child$67;
+
+      )
+        (newChildLanes |= child$67.lanes | child$67.childLanes),
+          (subtreeFlags |= child$67.subtreeFlags & 31457280),
+          (subtreeFlags |= child$67.flags & 31457280),
+          (treeBaseDuration$66 += child$67.treeBaseDuration),
+          (child$67 = child$67.sibling);
+      completedWork.treeBaseDuration = treeBaseDuration$66;
+    } else
+      for (
+        treeBaseDuration$66 = completedWork.child;
+        null !== treeBaseDuration$66;
+
+      )
+        (newChildLanes |=
+          treeBaseDuration$66.lanes | treeBaseDuration$66.childLanes),
+          (subtreeFlags |= treeBaseDuration$66.subtreeFlags & 31457280),
+          (subtreeFlags |= treeBaseDuration$66.flags & 31457280),
+          (treeBaseDuration$66.return = completedWork),
+          (treeBaseDuration$66 = treeBaseDuration$66.sibling);
+  else if (0 !== (completedWork.mode & 2)) {
+    treeBaseDuration$66 = completedWork.actualDuration;
+    child$67 = completedWork.selfBaseDuration;
+    for (var child = completedWork.child; null !== child; )
+      (newChildLanes |= child.lanes | child.childLanes),
+        (subtreeFlags |= child.subtreeFlags),
+        (subtreeFlags |= child.flags),
+        (treeBaseDuration$66 += child.actualDuration),
+        (child$67 += child.treeBaseDuration),
+        (child = child.sibling);
+    completedWork.actualDuration = treeBaseDuration$66;
+    completedWork.treeBaseDuration = child$67;
+  } else
+    for (
+      treeBaseDuration$66 = completedWork.child;
+      null !== treeBaseDuration$66;
+
+    )
+      (newChildLanes |=
+        treeBaseDuration$66.lanes | treeBaseDuration$66.childLanes),
+        (subtreeFlags |= treeBaseDuration$66.subtreeFlags),
+        (subtreeFlags |= treeBaseDuration$66.flags),
+        (treeBaseDuration$66.return = completedWork),
+        (treeBaseDuration$66 = treeBaseDuration$66.sibling);
+  completedWork.subtreeFlags |= subtreeFlags;
+  completedWork.childLanes = newChildLanes;
+  return didBailout;
 }
-function commitProfilerUpdate(finishedWork, current) {
-  if (executionContext & 4)
-    try {
-      var _finishedWork$memoize2 = finishedWork.memoizedProps,
-        onCommit = _finishedWork$memoize2.onCommit,
-        onRender = _finishedWork$memoize2.onRender,
-        effectDuration = finishedWork.stateNode.effectDuration;
-      _finishedWork$memoize2 = commitTime;
-      current = null === current ? "mount" : "update";
-      currentUpdateIsNested && (current = "nested-update");
-      "function" === typeof onRender &&
-        onRender(
-          finishedWork.memoizedProps.id,
-          current,
-          finishedWork.actualDuration,
-          finishedWork.treeBaseDuration,
-          finishedWork.actualStartTime,
-          _finishedWork$memoize2
-        );
-      "function" === typeof onCommit &&
-        onCommit(
-          finishedWork.memoizedProps.id,
-          current,
-          effectDuration,
-          _finishedWork$memoize2
-        );
-      enqueuePendingPassiveProfilerEffect(finishedWork);
-      var parentFiber = finishedWork.return;
-      a: for (; null !== parentFiber; ) {
-        switch (parentFiber.tag) {
-          case 3:
-            parentFiber.stateNode.effectDuration += effectDuration;
-            break a;
-          case 12:
-            parentFiber.stateNode.effectDuration += effectDuration;
-            break a;
-        }
-        parentFiber = parentFiber.return;
-      }
-    } catch (error) {
-      captureCommitPhaseError(finishedWork, finishedWork.return, error);
-    }
-}
-function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
-  var flags = finishedWork.flags;
-  switch (finishedWork.tag) {
+function completeWork(current, workInProgress, renderLanes) {
+  var newProps = workInProgress.pendingProps;
+  switch (workInProgress.tag) {
+    case 2:
+    case 16:
+    case 15:
     case 0:
     case 11:
-    case 15:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      flags & 4 && commitHookLayoutEffects(finishedWork, 5);
-      break;
+    case 7:
+    case 8:
+    case 12:
+    case 9:
+    case 14:
+      return bubbleProperties(workInProgress), null;
     case 1:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      if (flags & 4)
-        if (((finishedRoot = finishedWork.stateNode), null === current))
-          if (shouldProfile(finishedWork)) {
-            try {
-              startLayoutEffectTimer(), finishedRoot.componentDidMount();
-            } catch (error) {
-              captureCommitPhaseError(finishedWork, finishedWork.return, error);
-            }
-            recordLayoutEffectDuration(finishedWork);
-          } else
-            try {
-              finishedRoot.componentDidMount();
-            } catch (error$89) {
-              captureCommitPhaseError(
-                finishedWork,
-                finishedWork.return,
-                error$89
-              );
-            }
-        else {
-          var prevProps =
-            finishedWork.elementType === finishedWork.type
-              ? current.memoizedProps
-              : resolveDefaultProps(finishedWork.type, current.memoizedProps);
-          current = current.memoizedState;
-          if (shouldProfile(finishedWork)) {
-            try {
-              startLayoutEffectTimer(),
-                finishedRoot.componentDidUpdate(
-                  prevProps,
-                  current,
-                  finishedRoot.__reactInternalSnapshotBeforeUpdate
-                );
-            } catch (error$90) {
-              captureCommitPhaseError(
-                finishedWork,
-                finishedWork.return,
-                error$90
-              );
-            }
-            recordLayoutEffectDuration(finishedWork);
-          } else
-            try {
-              finishedRoot.componentDidUpdate(
-                prevProps,
-                current,
-                finishedRoot.__reactInternalSnapshotBeforeUpdate
-              );
-            } catch (error$91) {
-              captureCommitPhaseError(
-                finishedWork,
-                finishedWork.return,
-                error$91
-              );
-            }
-        }
-      flags & 64 && commitClassCallbacks(finishedWork);
-      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
-      break;
+      return bubbleProperties(workInProgress), null;
     case 3:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      if (flags & 64 && ((flags = finishedWork.updateQueue), null !== flags)) {
-        finishedRoot = null;
-        if (null !== finishedWork.child)
-          switch (finishedWork.child.tag) {
-            case 27:
-            case 5:
-              finishedRoot = getPublicInstance(finishedWork.child.stateNode);
-              break;
-            case 1:
-              finishedRoot = finishedWork.child.stateNode;
-          }
-        try {
-          commitCallbacks(flags, finishedRoot);
-        } catch (error) {
-          captureCommitPhaseError(finishedWork, finishedWork.return, error);
-        }
-      }
-      break;
+      return (
+        (renderLanes = workInProgress.stateNode),
+        popHostContainer(),
+        renderLanes.pendingContext &&
+          ((renderLanes.context = renderLanes.pendingContext),
+          (renderLanes.pendingContext = null)),
+        (null !== current && null !== current.child) ||
+          null === current ||
+          (current.memoizedState.isDehydrated &&
+            0 === (workInProgress.flags & 256)) ||
+          ((workInProgress.flags |= 1024),
+          null !== hydrationErrors &&
+            (queueRecoverableErrors(hydrationErrors),
+            (hydrationErrors = null))),
+        updateHostContainer(current, workInProgress),
+        bubbleProperties(workInProgress),
+        null
+      );
     case 26:
     case 27:
     case 5:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      null === current && flags & 4 && commitHostComponentMount(finishedWork);
-      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
-      break;
-    case 12:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      flags & 4 && commitProfilerUpdate(finishedWork, current);
-      break;
-    case 13:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      break;
-    case 22:
-      if (0 !== (finishedWork.mode & 1)) {
+      popHostContext(workInProgress);
+      renderLanes = workInProgress.type;
+      if (null !== current && null != workInProgress.stateNode) {
+        renderLanes = current.stateNode;
+        var oldProps = current.memoizedProps;
         if (
-          ((prevProps =
-            null !== finishedWork.memoizedState || offscreenSubtreeIsHidden),
-          !prevProps)
+          (current = doesRequireClone(current, workInProgress)) ||
+          oldProps !== newProps
         ) {
-          current =
-            (null !== current && null !== current.memoizedState) ||
-            offscreenSubtreeWasHidden;
-          var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
-            prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
-          offscreenSubtreeIsHidden = prevProps;
-          (offscreenSubtreeWasHidden = current) &&
-          !prevOffscreenSubtreeWasHidden
-            ? recursivelyTraverseReappearLayoutEffects(
-                finishedRoot,
-                finishedWork,
-                0 !== (finishedWork.subtreeFlags & 8772)
-              )
-            : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
-          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
+          b: {
+            oldProps = diffProperties(
+              null,
+              oldProps,
+              newProps,
+              renderLanes.canonical.viewConfig.validAttributes
+            );
+            renderLanes.canonical.currentProps = newProps;
+            newProps = renderLanes.node;
+            if (current)
+              newProps =
+                null !== oldProps
+                  ? cloneNodeWithNewChildrenAndProps(newProps, oldProps)
+                  : cloneNodeWithNewChildren(newProps);
+            else if (null !== oldProps)
+              newProps = cloneNodeWithNewProps(newProps, oldProps);
+            else {
+              newProps = renderLanes;
+              break b;
+            }
+            newProps = { node: newProps, canonical: renderLanes.canonical };
+          }
+          newProps === renderLanes
+            ? (workInProgress.stateNode = renderLanes)
+            : ((workInProgress.stateNode = newProps),
+              current
+                ? appendAllChildren(newProps, workInProgress, !1, !1)
+                : (workInProgress.flags |= 4));
+        } else workInProgress.stateNode = renderLanes;
+      } else {
+        if (!newProps) {
+          if (null === workInProgress.stateNode)
+            throw Error(
+              "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
+            );
+          bubbleProperties(workInProgress);
+          return null;
         }
-      } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      flags & 512 &&
-        ("manual" === finishedWork.memoizedProps.mode
-          ? safelyAttachRef(finishedWork, finishedWork.return)
-          : safelyDetachRef(finishedWork, finishedWork.return));
-      break;
-    default:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-  }
-}
-function detachFiberAfterEffects(fiber) {
-  var alternate = fiber.alternate;
-  null !== alternate &&
-    ((fiber.alternate = null), detachFiberAfterEffects(alternate));
-  fiber.child = null;
-  fiber.deletions = null;
-  fiber.sibling = null;
-  fiber.stateNode = null;
-  fiber.return = null;
-  fiber.dependencies = null;
-  fiber.memoizedProps = null;
-  fiber.memoizedState = null;
-  fiber.pendingProps = null;
-  fiber.stateNode = null;
-  fiber.updateQueue = null;
-}
-function recursivelyTraverseDeletionEffects(
-  finishedRoot,
-  nearestMountedAncestor,
-  parent
-) {
-  for (parent = parent.child; null !== parent; )
-    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent),
-      (parent = parent.sibling);
-}
-function commitDeletionEffectsOnFiber(
-  finishedRoot,
-  nearestMountedAncestor,
-  deletedFiber
-) {
-  if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
-    try {
-      injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
-    } catch (err) {}
-  switch (deletedFiber.tag) {
-    case 26:
-    case 27:
-    case 5:
-      offscreenSubtreeWasHidden ||
-        safelyDetachRef(deletedFiber, nearestMountedAncestor);
+        oldProps = rootInstanceStackCursor.current;
+        current = nextReactTag;
+        nextReactTag += 2;
+        renderLanes = getViewConfigForType(renderLanes);
+        var updatePayload = diffProperties(
+          null,
+          emptyObject,
+          newProps,
+          renderLanes.validAttributes
+        );
+        oldProps = createNode(
+          current,
+          renderLanes.uiViewClassName,
+          oldProps,
+          updatePayload,
+          workInProgress
+        );
+        updatePayload = ReactNativePrivateInterface.createPublicInstance(
+          current,
+          renderLanes,
+          workInProgress
+        );
+        current = {
+          node: oldProps,
+          canonical: {
+            nativeTag: current,
+            viewConfig: renderLanes,
+            currentProps: newProps,
+            internalInstanceHandle: workInProgress,
+            publicInstance: updatePayload
+          }
+        };
+        appendAllChildren(current, workInProgress, !1, !1);
+        workInProgress.stateNode = current;
+      }
+      bubbleProperties(workInProgress);
+      workInProgress.flags &= -16777217;
+      return null;
     case 6:
-      recursivelyTraverseDeletionEffects(
-        finishedRoot,
-        nearestMountedAncestor,
-        deletedFiber
-      );
-      break;
-    case 18:
-      break;
-    case 4:
-      createChildNodeSet();
-      recursivelyTraverseDeletionEffects(
-        finishedRoot,
-        nearestMountedAncestor,
-        deletedFiber
-      );
-      break;
-    case 0:
-    case 11:
-    case 14:
-    case 15:
-      if (!offscreenSubtreeWasHidden) {
-        var updateQueue = deletedFiber.updateQueue;
-        if (
-          null !== updateQueue &&
-          ((updateQueue = updateQueue.lastEffect), null !== updateQueue)
-        ) {
-          var effect = (updateQueue = updateQueue.next);
-          do {
-            var tag = effect.tag,
-              inst = effect.inst,
-              destroy = inst.destroy;
-            void 0 !== destroy &&
-              (0 !== (tag & 2)
-                ? ((inst.destroy = void 0),
-                  safelyCallDestroy(
-                    deletedFiber,
-                    nearestMountedAncestor,
-                    destroy
-                  ))
-                : 0 !== (tag & 4) &&
-                  (shouldProfile(deletedFiber)
-                    ? (startLayoutEffectTimer(),
-                      (inst.destroy = void 0),
-                      safelyCallDestroy(
-                        deletedFiber,
-                        nearestMountedAncestor,
-                        destroy
-                      ),
-                      recordLayoutEffectDuration(deletedFiber))
-                    : ((inst.destroy = void 0),
-                      safelyCallDestroy(
-                        deletedFiber,
-                        nearestMountedAncestor,
-                        destroy
-                      ))));
-            effect = effect.next;
-          } while (effect !== updateQueue);
-        }
+      if (current && null != workInProgress.stateNode)
+        current.memoizedProps !== newProps
+          ? ((workInProgress.stateNode = createTextInstance(
+              newProps,
+              rootInstanceStackCursor.current,
+              contextStackCursor.current,
+              workInProgress
+            )),
+            (workInProgress.flags |= 4))
+          : (workInProgress.stateNode = current.stateNode);
+      else {
+        if ("string" !== typeof newProps && null === workInProgress.stateNode)
+          throw Error(
+            "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
+          );
+        workInProgress.stateNode = createTextInstance(
+          newProps,
+          rootInstanceStackCursor.current,
+          contextStackCursor.current,
+          workInProgress
+        );
       }
-      recursivelyTraverseDeletionEffects(
-        finishedRoot,
-        nearestMountedAncestor,
-        deletedFiber
-      );
-      break;
-    case 1:
+      bubbleProperties(workInProgress);
+      return null;
+    case 13:
+      newProps = workInProgress.memoizedState;
       if (
-        !offscreenSubtreeWasHidden &&
-        (safelyDetachRef(deletedFiber, nearestMountedAncestor),
-        (updateQueue = deletedFiber.stateNode),
-        "function" === typeof updateQueue.componentWillUnmount)
-      )
-        try {
-          callComponentWillUnmountWithTimer(deletedFiber, updateQueue);
-        } catch (error) {
-          captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
+        null === current ||
+        (null !== current.memoizedState &&
+          null !== current.memoizedState.dehydrated)
+      ) {
+        if (null !== newProps && null !== newProps.dehydrated) {
+          if (null === current) {
+            throw Error(
+              "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
+            );
+            throw Error(
+              "Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
+            );
+          }
+          0 === (workInProgress.flags & 128) &&
+            (workInProgress.memoizedState = null);
+          workInProgress.flags |= 4;
+          bubbleProperties(workInProgress);
+          0 !== (workInProgress.mode & 2) &&
+            null !== newProps &&
+            ((oldProps = workInProgress.child),
+            null !== oldProps &&
+              (workInProgress.treeBaseDuration -= oldProps.treeBaseDuration));
+          oldProps = !1;
+        } else
+          null !== hydrationErrors &&
+            (queueRecoverableErrors(hydrationErrors), (hydrationErrors = null)),
+            (oldProps = !0);
+        if (!oldProps) {
+          if (workInProgress.flags & 256)
+            return popSuspenseHandler(workInProgress), workInProgress;
+          popSuspenseHandler(workInProgress);
+          return null;
         }
-      recursivelyTraverseDeletionEffects(
-        finishedRoot,
-        nearestMountedAncestor,
-        deletedFiber
-      );
-      break;
-    case 21:
-      recursivelyTraverseDeletionEffects(
-        finishedRoot,
-        nearestMountedAncestor,
-        deletedFiber
-      );
-      break;
-    case 22:
-      safelyDetachRef(deletedFiber, nearestMountedAncestor);
-      deletedFiber.mode & 1
-        ? ((offscreenSubtreeWasHidden =
-            (updateQueue = offscreenSubtreeWasHidden) ||
-            null !== deletedFiber.memoizedState),
-          recursivelyTraverseDeletionEffects(
-            finishedRoot,
-            nearestMountedAncestor,
-            deletedFiber
-          ),
-          (offscreenSubtreeWasHidden = updateQueue))
-        : recursivelyTraverseDeletionEffects(
-            finishedRoot,
-            nearestMountedAncestor,
-            deletedFiber
-          );
-      break;
-    default:
-      recursivelyTraverseDeletionEffects(
-        finishedRoot,
-        nearestMountedAncestor,
-        deletedFiber
-      );
-  }
-}
-function getRetryCache(finishedWork) {
-  switch (finishedWork.tag) {
-    case 13:
-    case 19:
-      var retryCache = finishedWork.stateNode;
-      null === retryCache &&
-        (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
-      return retryCache;
-    case 22:
+      }
+      popSuspenseHandler(workInProgress);
+      if (0 !== (workInProgress.flags & 128))
+        return (
+          (workInProgress.lanes = renderLanes),
+          0 !== (workInProgress.mode & 2) &&
+            transferActualDuration(workInProgress),
+          workInProgress
+        );
+      renderLanes = null !== newProps;
+      renderLanes !== (null !== current && null !== current.memoizedState) &&
+        renderLanes &&
+        (workInProgress.child.flags |= 8192);
+      scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
+      bubbleProperties(workInProgress);
+      0 !== (workInProgress.mode & 2) &&
+        renderLanes &&
+        ((current = workInProgress.child),
+        null !== current &&
+          (workInProgress.treeBaseDuration -= current.treeBaseDuration));
+      return null;
+    case 4:
       return (
-        (finishedWork = finishedWork.stateNode),
-        (retryCache = finishedWork._retryCache),
-        null === retryCache &&
-          (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),
-        retryCache
+        popHostContainer(),
+        updateHostContainer(current, workInProgress),
+        bubbleProperties(workInProgress),
+        null
       );
-    default:
-      throw Error(
-        "Unexpected Suspense handler tag (" +
-          finishedWork.tag +
-          "). This is a bug in React."
+    case 10:
+      return (
+        popProvider(workInProgress.type._context),
+        bubbleProperties(workInProgress),
+        null
       );
-  }
-}
-function attachSuspenseRetryListeners(finishedWork, wakeables) {
-  var retryCache = getRetryCache(finishedWork);
-  wakeables.forEach(function (wakeable) {
-    var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
-    if (!retryCache.has(wakeable)) {
-      retryCache.add(wakeable);
-      if (isDevToolsPresent)
-        if (null !== inProgressLanes && null !== inProgressRoot)
-          restorePendingUpdaters(inProgressRoot, inProgressLanes);
-        else
-          throw Error(
-            "Expected finished root and lanes to be set. This is a bug in React."
-          );
-      wakeable.then(retry, retry);
-    }
-  });
-}
-function commitMutationEffects(root, finishedWork, committedLanes) {
-  inProgressLanes = committedLanes;
-  inProgressRoot = root;
-  commitMutationEffectsOnFiber(finishedWork, root);
-  inProgressRoot = inProgressLanes = null;
-}
-function recursivelyTraverseMutationEffects(root, parentFiber) {
-  var deletions = parentFiber.deletions;
-  if (null !== deletions)
-    for (var i = 0; i < deletions.length; i++) {
-      var childToDelete = deletions[i];
-      try {
-        commitDeletionEffectsOnFiber(root, parentFiber, childToDelete);
-        var alternate = childToDelete.alternate;
-        null !== alternate && (alternate.return = null);
-        childToDelete.return = null;
-      } catch (error) {
-        captureCommitPhaseError(childToDelete, parentFiber, error);
-      }
-    }
-  if (parentFiber.subtreeFlags & 12854)
-    for (parentFiber = parentFiber.child; null !== parentFiber; )
-      commitMutationEffectsOnFiber(parentFiber, root),
-        (parentFiber = parentFiber.sibling);
-}
-function commitMutationEffectsOnFiber(finishedWork, root) {
-  var current = finishedWork.alternate,
-    flags = finishedWork.flags;
-  switch (finishedWork.tag) {
-    case 0:
-    case 11:
-    case 14:
-    case 15:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      if (flags & 4) {
-        try {
-          commitHookEffectListUnmount(3, finishedWork, finishedWork.return),
-            commitHookEffectListMount(3, finishedWork);
-        } catch (error) {
-          captureCommitPhaseError(finishedWork, finishedWork.return, error);
+    case 17:
+      return bubbleProperties(workInProgress), null;
+    case 19:
+      pop(suspenseStackCursor);
+      oldProps = workInProgress.memoizedState;
+      if (null === oldProps) return bubbleProperties(workInProgress), null;
+      newProps = 0 !== (workInProgress.flags & 128);
+      updatePayload = oldProps.rendering;
+      if (null === updatePayload)
+        if (newProps) cutOffTailIfNeeded(oldProps, !1);
+        else {
+          if (
+            0 !== workInProgressRootExitStatus ||
+            (null !== current && 0 !== (current.flags & 128))
+          )
+            for (current = workInProgress.child; null !== current; ) {
+              updatePayload = findFirstSuspended(current);
+              if (null !== updatePayload) {
+                workInProgress.flags |= 128;
+                cutOffTailIfNeeded(oldProps, !1);
+                current = updatePayload.updateQueue;
+                workInProgress.updateQueue = current;
+                scheduleRetryEffect(workInProgress, current);
+                workInProgress.subtreeFlags = 0;
+                current = renderLanes;
+                for (renderLanes = workInProgress.child; null !== renderLanes; )
+                  resetWorkInProgress(renderLanes, current),
+                    (renderLanes = renderLanes.sibling);
+                push(
+                  suspenseStackCursor,
+                  (suspenseStackCursor.current & 1) | 2
+                );
+                return workInProgress.child;
+              }
+              current = current.sibling;
+            }
+          null !== oldProps.tail &&
+            now$1() > workInProgressRootRenderTargetTime &&
+            ((workInProgress.flags |= 128),
+            (newProps = !0),
+            cutOffTailIfNeeded(oldProps, !1),
+            (workInProgress.lanes = 4194304));
         }
-        if (shouldProfile(finishedWork)) {
-          try {
-            startLayoutEffectTimer(),
-              commitHookEffectListUnmount(5, finishedWork, finishedWork.return);
-          } catch (error$94) {
-            captureCommitPhaseError(
-              finishedWork,
-              finishedWork.return,
-              error$94
-            );
-          }
-          recordLayoutEffectDuration(finishedWork);
-        } else
-          try {
-            commitHookEffectListUnmount(5, finishedWork, finishedWork.return);
-          } catch (error$95) {
-            captureCommitPhaseError(
-              finishedWork,
-              finishedWork.return,
-              error$95
-            );
-          }
+      else {
+        if (!newProps)
+          if (
+            ((current = findFirstSuspended(updatePayload)), null !== current)
+          ) {
+            if (
+              ((workInProgress.flags |= 128),
+              (newProps = !0),
+              (current = current.updateQueue),
+              (workInProgress.updateQueue = current),
+              scheduleRetryEffect(workInProgress, current),
+              cutOffTailIfNeeded(oldProps, !0),
+              null === oldProps.tail &&
+                "hidden" === oldProps.tailMode &&
+                !updatePayload.alternate)
+            )
+              return bubbleProperties(workInProgress), null;
+          } else
+            2 * now$1() - oldProps.renderingStartTime >
+              workInProgressRootRenderTargetTime &&
+              536870912 !== renderLanes &&
+              ((workInProgress.flags |= 128),
+              (newProps = !0),
+              cutOffTailIfNeeded(oldProps, !1),
+              (workInProgress.lanes = 4194304));
+        oldProps.isBackwards
+          ? ((updatePayload.sibling = workInProgress.child),
+            (workInProgress.child = updatePayload))
+          : ((current = oldProps.last),
+            null !== current
+              ? (current.sibling = updatePayload)
+              : (workInProgress.child = updatePayload),
+            (oldProps.last = updatePayload));
       }
-      break;
-    case 1:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      flags & 512 &&
+      if (null !== oldProps.tail)
+        return (
+          (workInProgress = oldProps.tail),
+          (oldProps.rendering = workInProgress),
+          (oldProps.tail = workInProgress.sibling),
+          (oldProps.renderingStartTime = now$1()),
+          (workInProgress.sibling = null),
+          (current = suspenseStackCursor.current),
+          push(suspenseStackCursor, newProps ? (current & 1) | 2 : current & 1),
+          workInProgress
+        );
+      bubbleProperties(workInProgress);
+      return null;
+    case 22:
+    case 23:
+      return (
+        popSuspenseHandler(workInProgress),
+        popHiddenContext(),
+        (newProps = null !== workInProgress.memoizedState),
+        null !== current
+          ? (null !== current.memoizedState) !== newProps &&
+            (workInProgress.flags |= 8192)
+          : newProps && (workInProgress.flags |= 8192),
+        newProps && 0 !== (workInProgress.mode & 1)
+          ? 0 !== (renderLanes & 536870912) &&
+            0 === (workInProgress.flags & 128) &&
+            (bubbleProperties(workInProgress),
+            workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192))
+          : bubbleProperties(workInProgress),
+        (current = workInProgress.updateQueue),
         null !== current &&
-        safelyDetachRef(current, current.return);
-      flags & 64 &&
-        offscreenSubtreeIsHidden &&
-        ((finishedWork = finishedWork.updateQueue),
-        null !== finishedWork &&
-          ((flags = finishedWork.callbacks),
-          null !== flags &&
-            ((current = finishedWork.shared.hiddenCallbacks),
-            (finishedWork.shared.hiddenCallbacks =
-              null === current ? flags : current.concat(flags)))));
-      break;
+          scheduleRetryEffect(workInProgress, current.retryQueue),
+        null
+      );
+    case 24:
+      return null;
+    case 25:
+      return null;
+  }
+  throw Error(
+    "Unknown unit of work tag (" +
+      workInProgress.tag +
+      "). This error is likely caused by a bug in React. Please file an issue."
+  );
+}
+function unwindWork(current, workInProgress) {
+  switch (workInProgress.tag) {
+    case 1:
+      return (
+        (current = workInProgress.flags),
+        current & 65536
+          ? ((workInProgress.flags = (current & -65537) | 128),
+            0 !== (workInProgress.mode & 2) &&
+              transferActualDuration(workInProgress),
+            workInProgress)
+          : null
+      );
+    case 3:
+      return (
+        popHostContainer(),
+        (current = workInProgress.flags),
+        0 !== (current & 65536) && 0 === (current & 128)
+          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
+          : null
+      );
     case 26:
     case 27:
     case 5:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      flags & 512 &&
+      return popHostContext(workInProgress), null;
+    case 13:
+      popSuspenseHandler(workInProgress);
+      current = workInProgress.memoizedState;
+      if (
         null !== current &&
-        safelyDetachRef(current, current.return);
-      break;
-    case 6:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      break;
+        null !== current.dehydrated &&
+        null === workInProgress.alternate
+      )
+        throw Error(
+          "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
+        );
+      current = workInProgress.flags;
+      return current & 65536
+        ? ((workInProgress.flags = (current & -65537) | 128),
+          0 !== (workInProgress.mode & 2) &&
+            transferActualDuration(workInProgress),
+          workInProgress)
+        : null;
+    case 19:
+      return pop(suspenseStackCursor), null;
+    case 4:
+      return popHostContainer(), null;
+    case 10:
+      return popProvider(workInProgress.type._context), null;
+    case 22:
+    case 23:
+      return (
+        popSuspenseHandler(workInProgress),
+        popHiddenContext(),
+        (current = workInProgress.flags),
+        current & 65536
+          ? ((workInProgress.flags = (current & -65537) | 128),
+            0 !== (workInProgress.mode & 2) &&
+              transferActualDuration(workInProgress),
+            workInProgress)
+          : null
+      );
+    case 24:
+      return null;
+    case 25:
+      return null;
+    default:
+      return null;
+  }
+}
+function unwindInterruptedWork(current, interruptedWork) {
+  switch (interruptedWork.tag) {
     case 3:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
+      popHostContainer();
+      break;
+    case 26:
+    case 27:
+    case 5:
+      popHostContext(interruptedWork);
       break;
     case 4:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
+      popHostContainer();
       break;
     case 13:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      finishedWork.child.flags & 8192 &&
-        ((current = null !== current && null !== current.memoizedState),
-        null === finishedWork.memoizedState ||
-          current ||
-          (globalMostRecentFallbackTime = now$1()));
-      flags & 4 &&
-        ((flags = finishedWork.updateQueue),
-        null !== flags &&
-          ((finishedWork.updateQueue = null),
-          attachSuspenseRetryListeners(finishedWork, flags)));
-      break;
-    case 22:
-      flags & 512 &&
-        null !== current &&
-        safelyDetachRef(current, current.return);
-      var isHidden = null !== finishedWork.memoizedState,
-        wasHidden = null !== current && null !== current.memoizedState;
-      if (finishedWork.mode & 1) {
-        var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
-          prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
-        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || isHidden;
-        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
-        recursivelyTraverseMutationEffects(root, finishedWork);
-        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
-        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
-      } else recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      root = finishedWork.stateNode;
-      root._current = finishedWork;
-      root._visibility &= -3;
-      root._visibility |= root._pendingVisibility & 2;
-      flags & 8192 &&
-        ((root._visibility = isHidden
-          ? root._visibility & -2
-          : root._visibility | 1),
-        isHidden &&
-          ((isHidden = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden),
-          null === current ||
-            wasHidden ||
-            isHidden ||
-            (0 !== (finishedWork.mode & 1) &&
-              recursivelyTraverseDisappearLayoutEffects(finishedWork))));
-      flags & 4 &&
-        ((flags = finishedWork.updateQueue),
-        null !== flags &&
-          ((current = flags.retryQueue),
-          null !== current &&
-            ((flags.retryQueue = null),
-            attachSuspenseRetryListeners(finishedWork, current))));
+      popSuspenseHandler(interruptedWork);
       break;
     case 19:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      flags & 4 &&
-        ((flags = finishedWork.updateQueue),
-        null !== flags &&
-          ((finishedWork.updateQueue = null),
-          attachSuspenseRetryListeners(finishedWork, flags)));
+      pop(suspenseStackCursor);
       break;
-    case 21:
+    case 10:
+      popProvider(interruptedWork.type._context);
       break;
-    default:
-      recursivelyTraverseMutationEffects(root, finishedWork),
-        commitReconciliationEffects(finishedWork);
+    case 22:
+    case 23:
+      popSuspenseHandler(interruptedWork), popHiddenContext();
   }
 }
-function commitReconciliationEffects(finishedWork) {
-  var flags = finishedWork.flags;
-  flags & 2 && (finishedWork.flags &= -3);
-  flags & 4096 && (finishedWork.flags &= -4097);
-}
-function commitLayoutEffects(finishedWork, root, committedLanes) {
-  inProgressLanes = committedLanes;
-  inProgressRoot = root;
-  commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);
-  inProgressRoot = inProgressLanes = null;
+var offscreenSubtreeIsHidden = !1,
+  offscreenSubtreeWasHidden = !1,
+  PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
+  nextEffect = null,
+  inProgressLanes = null,
+  inProgressRoot = null;
+function shouldProfile(current) {
+  return 0 !== (current.mode & 2) && 0 !== (executionContext & 4);
 }
-function recursivelyTraverseLayoutEffects(root, parentFiber) {
-  if (parentFiber.subtreeFlags & 8772)
-    for (parentFiber = parentFiber.child; null !== parentFiber; )
-      commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),
-        (parentFiber = parentFiber.sibling);
+function callComponentWillUnmountWithTimer(current, instance) {
+  instance.props = current.memoizedProps;
+  instance.state = current.memoizedState;
+  if (shouldProfile(current))
+    try {
+      startLayoutEffectTimer(), instance.componentWillUnmount();
+    } finally {
+      recordLayoutEffectDuration(current);
+    }
+  else instance.componentWillUnmount();
 }
-function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
-  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
-    var finishedWork = parentFiber;
-    switch (finishedWork.tag) {
-      case 0:
-      case 11:
-      case 14:
-      case 15:
-        if (shouldProfile(finishedWork))
+function safelyAttachRef(current, nearestMountedAncestor) {
+  try {
+    var ref = current.ref;
+    if (null !== ref) {
+      var instance = current.stateNode;
+      switch (current.tag) {
+        case 26:
+        case 27:
+        case 5:
+          var instanceToUse = getPublicInstance(instance);
+          break;
+        default:
+          instanceToUse = instance;
+      }
+      if ("function" === typeof ref)
+        if (shouldProfile(current))
           try {
-            startLayoutEffectTimer(),
-              commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
+            startLayoutEffectTimer(), (current.refCleanup = ref(instanceToUse));
           } finally {
-            recordLayoutEffectDuration(finishedWork);
-          }
-        else commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
-        recursivelyTraverseDisappearLayoutEffects(finishedWork);
-        break;
-      case 1:
-        safelyDetachRef(finishedWork, finishedWork.return);
-        var instance = finishedWork.stateNode;
-        if ("function" === typeof instance.componentWillUnmount) {
-          var current = finishedWork,
-            nearestMountedAncestor = finishedWork.return;
-          try {
-            callComponentWillUnmountWithTimer(current, instance);
-          } catch (error) {
-            captureCommitPhaseError(current, nearestMountedAncestor, error);
+            recordLayoutEffectDuration(current);
           }
-        }
-        recursivelyTraverseDisappearLayoutEffects(finishedWork);
-        break;
-      case 26:
-      case 27:
-      case 5:
-        safelyDetachRef(finishedWork, finishedWork.return);
-        recursivelyTraverseDisappearLayoutEffects(finishedWork);
-        break;
-      case 22:
-        safelyDetachRef(finishedWork, finishedWork.return);
-        null === finishedWork.memoizedState &&
-          recursivelyTraverseDisappearLayoutEffects(finishedWork);
-        break;
-      default:
-        recursivelyTraverseDisappearLayoutEffects(finishedWork);
+        else current.refCleanup = ref(instanceToUse);
+      else ref.current = instanceToUse;
     }
-    parentFiber = parentFiber.sibling;
+  } catch (error) {
+    captureCommitPhaseError(current, nearestMountedAncestor, error);
   }
 }
-function recursivelyTraverseReappearLayoutEffects(
-  finishedRoot$jscomp$0,
-  parentFiber,
-  includeWorkInProgressEffects
-) {
-  includeWorkInProgressEffects =
-    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
-  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
-    var current = parentFiber.alternate,
-      finishedRoot = finishedRoot$jscomp$0,
-      finishedWork = parentFiber,
-      flags = finishedWork.flags;
-    switch (finishedWork.tag) {
-      case 0:
-      case 11:
-      case 15:
-        recursivelyTraverseReappearLayoutEffects(
-          finishedRoot,
-          finishedWork,
-          includeWorkInProgressEffects
-        );
-        commitHookLayoutEffects(finishedWork, 4);
-        break;
-      case 1:
-        recursivelyTraverseReappearLayoutEffects(
-          finishedRoot,
-          finishedWork,
-          includeWorkInProgressEffects
-        );
-        finishedRoot = finishedWork.stateNode;
-        if ("function" === typeof finishedRoot.componentDidMount)
+function safelyDetachRef(current, nearestMountedAncestor) {
+  var ref = current.ref,
+    refCleanup = current.refCleanup;
+  if (null !== ref)
+    if ("function" === typeof refCleanup)
+      try {
+        if (shouldProfile(current))
           try {
-            finishedRoot.componentDidMount();
-          } catch (error) {
-            captureCommitPhaseError(finishedWork, finishedWork.return, error);
+            startLayoutEffectTimer(), refCleanup();
+          } finally {
+            recordLayoutEffectDuration(current);
           }
-        current = finishedWork.updateQueue;
-        if (null !== current) {
-          var hiddenCallbacks = current.shared.hiddenCallbacks;
-          if (null !== hiddenCallbacks)
-            for (
-              current.shared.hiddenCallbacks = null, current = 0;
-              current < hiddenCallbacks.length;
-              current++
-            )
-              callCallback(hiddenCallbacks[current], finishedRoot);
-        }
-        includeWorkInProgressEffects &&
-          flags & 64 &&
-          commitClassCallbacks(finishedWork);
-        safelyAttachRef(finishedWork, finishedWork.return);
-        break;
-      case 26:
-      case 27:
-      case 5:
-        recursivelyTraverseReappearLayoutEffects(
-          finishedRoot,
-          finishedWork,
-          includeWorkInProgressEffects
-        );
-        includeWorkInProgressEffects &&
-          null === current &&
-          flags & 4 &&
-          commitHostComponentMount(finishedWork);
-        safelyAttachRef(finishedWork, finishedWork.return);
-        break;
-      case 12:
-        recursivelyTraverseReappearLayoutEffects(
-          finishedRoot,
-          finishedWork,
-          includeWorkInProgressEffects
-        );
-        includeWorkInProgressEffects &&
-          flags & 4 &&
-          commitProfilerUpdate(finishedWork, current);
-        break;
-      case 13:
-        recursivelyTraverseReappearLayoutEffects(
-          finishedRoot,
-          finishedWork,
-          includeWorkInProgressEffects
-        );
-        break;
-      case 22:
-        null === finishedWork.memoizedState &&
-          recursivelyTraverseReappearLayoutEffects(
-            finishedRoot,
-            finishedWork,
-            includeWorkInProgressEffects
-          );
-        safelyAttachRef(finishedWork, finishedWork.return);
-        break;
-      default:
-        recursivelyTraverseReappearLayoutEffects(
-          finishedRoot,
-          finishedWork,
-          includeWorkInProgressEffects
-        );
-    }
-    parentFiber = parentFiber.sibling;
+        else refCleanup();
+      } catch (error) {
+        captureCommitPhaseError(current, nearestMountedAncestor, error);
+      } finally {
+        (current.refCleanup = null),
+          (current = current.alternate),
+          null != current && (current.refCleanup = null);
+      }
+    else if ("function" === typeof ref)
+      try {
+        if (shouldProfile(current))
+          try {
+            startLayoutEffectTimer(), ref(null);
+          } finally {
+            recordLayoutEffectDuration(current);
+          }
+        else ref(null);
+      } catch (error$84) {
+        captureCommitPhaseError(current, nearestMountedAncestor, error$84);
+      }
+    else ref.current = null;
+}
+function safelyCallDestroy(current, nearestMountedAncestor, destroy) {
+  try {
+    destroy();
+  } catch (error) {
+    captureCommitPhaseError(current, nearestMountedAncestor, error);
   }
 }
-function commitHookPassiveMountEffects(finishedWork, hookFlags) {
+var shouldFireAfterActiveInstanceBlur = !1;
+function commitBeforeMutationEffects(root, firstChild) {
+  for (nextEffect = firstChild; null !== nextEffect; )
+    if (
+      ((root = nextEffect),
+      (firstChild = root.child),
+      0 !== (root.subtreeFlags & 1028) && null !== firstChild)
+    )
+      (firstChild.return = root), (nextEffect = firstChild);
+    else
+      for (; null !== nextEffect; ) {
+        root = nextEffect;
+        try {
+          var current = root.alternate,
+            flags = root.flags;
+          switch (root.tag) {
+            case 0:
+              break;
+            case 11:
+            case 15:
+              break;
+            case 1:
+              if (0 !== (flags & 1024) && null !== current) {
+                var prevProps = current.memoizedProps,
+                  prevState = current.memoizedState,
+                  instance = root.stateNode,
+                  snapshot = instance.getSnapshotBeforeUpdate(
+                    root.elementType === root.type
+                      ? prevProps
+                      : resolveDefaultProps(root.type, prevProps),
+                    prevState
+                  );
+                instance.__reactInternalSnapshotBeforeUpdate = snapshot;
+              }
+              break;
+            case 3:
+              break;
+            case 5:
+            case 26:
+            case 27:
+            case 6:
+            case 4:
+            case 17:
+              break;
+            default:
+              if (0 !== (flags & 1024))
+                throw Error(
+                  "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
+                );
+          }
+        } catch (error) {
+          captureCommitPhaseError(root, root.return, error);
+        }
+        firstChild = root.sibling;
+        if (null !== firstChild) {
+          firstChild.return = root.return;
+          nextEffect = firstChild;
+          break;
+        }
+        nextEffect = root.return;
+      }
+  current = shouldFireAfterActiveInstanceBlur;
+  shouldFireAfterActiveInstanceBlur = !1;
+  return current;
+}
+function commitHookEffectListUnmount(
+  flags,
+  finishedWork,
+  nearestMountedAncestor
+) {
+  var updateQueue = finishedWork.updateQueue;
+  updateQueue = null !== updateQueue ? updateQueue.lastEffect : null;
+  if (null !== updateQueue) {
+    var effect = (updateQueue = updateQueue.next);
+    do {
+      if ((effect.tag & flags) === flags) {
+        var inst = effect.inst,
+          destroy = inst.destroy;
+        void 0 !== destroy &&
+          ((inst.destroy = void 0),
+          safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy));
+      }
+      effect = effect.next;
+    } while (effect !== updateQueue);
+  }
+}
+function commitHookEffectListMount(flags, finishedWork) {
+  finishedWork = finishedWork.updateQueue;
+  finishedWork = null !== finishedWork ? finishedWork.lastEffect : null;
+  if (null !== finishedWork) {
+    var effect = (finishedWork = finishedWork.next);
+    do {
+      if ((effect.tag & flags) === flags) {
+        var create$85 = effect.create,
+          inst = effect.inst;
+        create$85 = create$85();
+        inst.destroy = create$85;
+      }
+      effect = effect.next;
+    } while (effect !== finishedWork);
+  }
+}
+function commitHookLayoutEffects(finishedWork, hookFlags) {
   if (shouldProfile(finishedWork)) {
-    passiveEffectStartTime = now();
     try {
-      commitHookEffectListMount(hookFlags, finishedWork);
+      startLayoutEffectTimer(),
+        commitHookEffectListMount(hookFlags, finishedWork);
     } catch (error) {
       captureCommitPhaseError(finishedWork, finishedWork.return, error);
     }
-    recordPassiveEffectDuration(finishedWork);
+    recordLayoutEffectDuration(finishedWork);
   } else
     try {
       commitHookEffectListMount(hookFlags, finishedWork);
-    } catch (error$103) {
-      captureCommitPhaseError(finishedWork, finishedWork.return, error$103);
+    } catch (error$87) {
+      captureCommitPhaseError(finishedWork, finishedWork.return, error$87);
     }
 }
-function recursivelyTraversePassiveMountEffects(root, parentFiber) {
-  if (parentFiber.subtreeFlags & 10256)
-    for (parentFiber = parentFiber.child; null !== parentFiber; )
-      commitPassiveMountOnFiber(root, parentFiber),
-        (parentFiber = parentFiber.sibling);
+function commitClassCallbacks(finishedWork) {
+  var updateQueue = finishedWork.updateQueue;
+  if (null !== updateQueue) {
+    var instance = finishedWork.stateNode;
+    try {
+      commitCallbacks(updateQueue, instance);
+    } catch (error) {
+      captureCommitPhaseError(finishedWork, finishedWork.return, error);
+    }
+  }
 }
-function commitPassiveMountOnFiber(finishedRoot, finishedWork) {
+function commitHostComponentMount(finishedWork) {
+  try {
+    throw Error(
+      "The current renderer does not support mutation. This error is likely caused by a bug in React. Please file an issue."
+    );
+  } catch (error) {
+    captureCommitPhaseError(finishedWork, finishedWork.return, error);
+  }
+}
+function commitProfilerUpdate(finishedWork, current) {
+  if (executionContext & 4)
+    try {
+      var _finishedWork$memoize2 = finishedWork.memoizedProps,
+        onCommit = _finishedWork$memoize2.onCommit,
+        onRender = _finishedWork$memoize2.onRender,
+        effectDuration = finishedWork.stateNode.effectDuration;
+      _finishedWork$memoize2 = commitTime;
+      current = null === current ? "mount" : "update";
+      currentUpdateIsNested && (current = "nested-update");
+      "function" === typeof onRender &&
+        onRender(
+          finishedWork.memoizedProps.id,
+          current,
+          finishedWork.actualDuration,
+          finishedWork.treeBaseDuration,
+          finishedWork.actualStartTime,
+          _finishedWork$memoize2
+        );
+      "function" === typeof onCommit &&
+        onCommit(
+          finishedWork.memoizedProps.id,
+          current,
+          effectDuration,
+          _finishedWork$memoize2
+        );
+      enqueuePendingPassiveProfilerEffect(finishedWork);
+      var parentFiber = finishedWork.return;
+      a: for (; null !== parentFiber; ) {
+        switch (parentFiber.tag) {
+          case 3:
+            parentFiber.stateNode.effectDuration += effectDuration;
+            break a;
+          case 12:
+            parentFiber.stateNode.effectDuration += effectDuration;
+            break a;
+        }
+        parentFiber = parentFiber.return;
+      }
+    } catch (error) {
+      captureCommitPhaseError(finishedWork, finishedWork.return, error);
+    }
+}
+function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
   var flags = finishedWork.flags;
   switch (finishedWork.tag) {
     case 0:
     case 11:
     case 15:
-      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
-      flags & 2048 && commitHookPassiveMountEffects(finishedWork, 9);
-      break;
-    case 3:
-      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
-      break;
-    case 23:
-      break;
-    case 22:
-      flags = finishedWork.stateNode;
-      null !== finishedWork.memoizedState
-        ? flags._visibility & 4
-          ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork)
-          : finishedWork.mode & 1 ||
-            ((flags._visibility |= 4),
-            recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork))
-        : flags._visibility & 4
-        ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork)
-        : ((flags._visibility |= 4),
-          recursivelyTraverseReconnectPassiveEffects(
-            finishedRoot,
-            finishedWork
-          ));
-      break;
-    case 24:
-      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      flags & 4 && commitHookLayoutEffects(finishedWork, 5);
       break;
-    default:
-      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
-  }
-}
-function recursivelyTraverseReconnectPassiveEffects(
-  finishedRoot$jscomp$0,
-  parentFiber
-) {
-  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
-    var finishedRoot = finishedRoot$jscomp$0,
-      finishedWork = parentFiber;
-    switch (finishedWork.tag) {
-      case 0:
-      case 11:
-      case 15:
-        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork);
-        commitHookPassiveMountEffects(finishedWork, 8);
-        break;
-      case 23:
-        break;
-      case 22:
-        var instance = finishedWork.stateNode;
-        null !== finishedWork.memoizedState
-          ? instance._visibility & 4
-            ? recursivelyTraverseReconnectPassiveEffects(
-                finishedRoot,
-                finishedWork
-              )
-            : finishedWork.mode & 1 ||
-              ((instance._visibility |= 4),
-              recursivelyTraverseReconnectPassiveEffects(
-                finishedRoot,
-                finishedWork
-              ))
-          : ((instance._visibility |= 4),
-            recursivelyTraverseReconnectPassiveEffects(
-              finishedRoot,
-              finishedWork
-            ));
-        break;
-      case 24:
-        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork);
-        break;
-      default:
-        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork);
-    }
-    parentFiber = parentFiber.sibling;
-  }
-}
-var suspenseyCommitFlag = 8192;
-function recursivelyAccumulateSuspenseyCommit(parentFiber) {
-  if (parentFiber.subtreeFlags & suspenseyCommitFlag)
-    for (parentFiber = parentFiber.child; null !== parentFiber; )
-      accumulateSuspenseyCommitOnFiber(parentFiber),
-        (parentFiber = parentFiber.sibling);
-}
-function accumulateSuspenseyCommitOnFiber(fiber) {
-  switch (fiber.tag) {
-    case 26:
-      recursivelyAccumulateSuspenseyCommit(fiber);
-      if (fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState)
-        throw Error(
-          "The current renderer does not support Resources. This error is likely caused by a bug in React. Please file an issue."
-        );
+    case 1:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      if (flags & 4)
+        if (((finishedRoot = finishedWork.stateNode), null === current))
+          if (shouldProfile(finishedWork)) {
+            try {
+              startLayoutEffectTimer(), finishedRoot.componentDidMount();
+            } catch (error) {
+              captureCommitPhaseError(finishedWork, finishedWork.return, error);
+            }
+            recordLayoutEffectDuration(finishedWork);
+          } else
+            try {
+              finishedRoot.componentDidMount();
+            } catch (error$88) {
+              captureCommitPhaseError(
+                finishedWork,
+                finishedWork.return,
+                error$88
+              );
+            }
+        else {
+          var prevProps =
+            finishedWork.elementType === finishedWork.type
+              ? current.memoizedProps
+              : resolveDefaultProps(finishedWork.type, current.memoizedProps);
+          current = current.memoizedState;
+          if (shouldProfile(finishedWork)) {
+            try {
+              startLayoutEffectTimer(),
+                finishedRoot.componentDidUpdate(
+                  prevProps,
+                  current,
+                  finishedRoot.__reactInternalSnapshotBeforeUpdate
+                );
+            } catch (error$89) {
+              captureCommitPhaseError(
+                finishedWork,
+                finishedWork.return,
+                error$89
+              );
+            }
+            recordLayoutEffectDuration(finishedWork);
+          } else
+            try {
+              finishedRoot.componentDidUpdate(
+                prevProps,
+                current,
+                finishedRoot.__reactInternalSnapshotBeforeUpdate
+              );
+            } catch (error$90) {
+              captureCommitPhaseError(
+                finishedWork,
+                finishedWork.return,
+                error$90
+              );
+            }
+        }
+      flags & 64 && commitClassCallbacks(finishedWork);
+      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
+      break;
+    case 3:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      if (flags & 64 && ((flags = finishedWork.updateQueue), null !== flags)) {
+        finishedRoot = null;
+        if (null !== finishedWork.child)
+          switch (finishedWork.child.tag) {
+            case 27:
+            case 5:
+              finishedRoot = getPublicInstance(finishedWork.child.stateNode);
+              break;
+            case 1:
+              finishedRoot = finishedWork.child.stateNode;
+          }
+        try {
+          commitCallbacks(flags, finishedRoot);
+        } catch (error) {
+          captureCommitPhaseError(finishedWork, finishedWork.return, error);
+        }
+      }
       break;
+    case 26:
+    case 27:
     case 5:
-      recursivelyAccumulateSuspenseyCommit(fiber);
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      null === current && flags & 4 && commitHostComponentMount(finishedWork);
+      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
       break;
-    case 3:
-    case 4:
-      recursivelyAccumulateSuspenseyCommit(fiber);
+    case 12:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      flags & 4 && commitProfilerUpdate(finishedWork, current);
+      break;
+    case 13:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
       break;
     case 22:
-      if (null === fiber.memoizedState) {
-        var current = fiber.alternate;
-        null !== current && null !== current.memoizedState
-          ? ((current = suspenseyCommitFlag),
-            (suspenseyCommitFlag = 16777216),
-            recursivelyAccumulateSuspenseyCommit(fiber),
-            (suspenseyCommitFlag = current))
-          : recursivelyAccumulateSuspenseyCommit(fiber);
-      }
+      if (0 !== (finishedWork.mode & 1)) {
+        if (
+          ((prevProps =
+            null !== finishedWork.memoizedState || offscreenSubtreeIsHidden),
+          !prevProps)
+        ) {
+          current =
+            (null !== current && null !== current.memoizedState) ||
+            offscreenSubtreeWasHidden;
+          var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
+            prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
+          offscreenSubtreeIsHidden = prevProps;
+          (offscreenSubtreeWasHidden = current) &&
+          !prevOffscreenSubtreeWasHidden
+            ? recursivelyTraverseReappearLayoutEffects(
+                finishedRoot,
+                finishedWork,
+                0 !== (finishedWork.subtreeFlags & 8772)
+              )
+            : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
+          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
+        }
+      } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      flags & 512 &&
+        ("manual" === finishedWork.memoizedProps.mode
+          ? safelyAttachRef(finishedWork, finishedWork.return)
+          : safelyDetachRef(finishedWork, finishedWork.return));
       break;
     default:
-      recursivelyAccumulateSuspenseyCommit(fiber);
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
   }
 }
-function detachAlternateSiblings(parentFiber) {
-  var previousFiber = parentFiber.alternate;
-  if (
-    null !== previousFiber &&
-    ((parentFiber = previousFiber.child), null !== parentFiber)
-  ) {
-    previousFiber.child = null;
-    do
-      (previousFiber = parentFiber.sibling),
-        (parentFiber.sibling = null),
-        (parentFiber = previousFiber);
-    while (null !== parentFiber);
-  }
+function detachFiberAfterEffects(fiber) {
+  var alternate = fiber.alternate;
+  null !== alternate &&
+    ((fiber.alternate = null), detachFiberAfterEffects(alternate));
+  fiber.child = null;
+  fiber.deletions = null;
+  fiber.sibling = null;
+  fiber.stateNode = null;
+  fiber.return = null;
+  fiber.dependencies = null;
+  fiber.memoizedProps = null;
+  fiber.memoizedState = null;
+  fiber.pendingProps = null;
+  fiber.stateNode = null;
+  fiber.updateQueue = null;
 }
-function commitHookPassiveUnmountEffects(
-  finishedWork,
+function recursivelyTraverseDeletionEffects(
+  finishedRoot,
   nearestMountedAncestor,
-  hookFlags
+  parent
 ) {
-  shouldProfile(finishedWork)
-    ? ((passiveEffectStartTime = now()),
-      commitHookEffectListUnmount(
-        hookFlags,
-        finishedWork,
-        nearestMountedAncestor
-      ),
-      recordPassiveEffectDuration(finishedWork))
-    : commitHookEffectListUnmount(
-        hookFlags,
-        finishedWork,
-        nearestMountedAncestor
-      );
+  for (parent = parent.child; null !== parent; )
+    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent),
+      (parent = parent.sibling);
 }
-function recursivelyTraversePassiveUnmountEffects(parentFiber) {
-  var deletions = parentFiber.deletions;
-  if (0 !== (parentFiber.flags & 16)) {
-    if (null !== deletions)
-      for (var i = 0; i < deletions.length; i++) {
-        var childToDelete = deletions[i];
-        nextEffect = childToDelete;
-        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
-          childToDelete,
-          parentFiber
-        );
-      }
-    detachAlternateSiblings(parentFiber);
-  }
-  if (parentFiber.subtreeFlags & 10256)
-    for (parentFiber = parentFiber.child; null !== parentFiber; )
-      commitPassiveUnmountOnFiber(parentFiber),
-        (parentFiber = parentFiber.sibling);
-}
-function commitPassiveUnmountOnFiber(finishedWork) {
-  switch (finishedWork.tag) {
+function commitDeletionEffectsOnFiber(
+  finishedRoot,
+  nearestMountedAncestor,
+  deletedFiber
+) {
+  if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
+    try {
+      injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
+    } catch (err) {}
+  switch (deletedFiber.tag) {
+    case 26:
+    case 27:
+    case 5:
+      offscreenSubtreeWasHidden ||
+        safelyDetachRef(deletedFiber, nearestMountedAncestor);
+    case 6:
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
+      break;
+    case 18:
+      break;
+    case 4:
+      createChildNodeSet();
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
+      break;
     case 0:
     case 11:
+    case 14:
     case 15:
-      recursivelyTraversePassiveUnmountEffects(finishedWork);
-      finishedWork.flags & 2048 &&
-        commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, 9);
+      if (!offscreenSubtreeWasHidden) {
+        var updateQueue = deletedFiber.updateQueue;
+        if (
+          null !== updateQueue &&
+          ((updateQueue = updateQueue.lastEffect), null !== updateQueue)
+        ) {
+          var effect = (updateQueue = updateQueue.next);
+          do {
+            var tag = effect.tag,
+              inst = effect.inst,
+              destroy = inst.destroy;
+            void 0 !== destroy &&
+              (0 !== (tag & 2)
+                ? ((inst.destroy = void 0),
+                  safelyCallDestroy(
+                    deletedFiber,
+                    nearestMountedAncestor,
+                    destroy
+                  ))
+                : 0 !== (tag & 4) &&
+                  (shouldProfile(deletedFiber)
+                    ? (startLayoutEffectTimer(),
+                      (inst.destroy = void 0),
+                      safelyCallDestroy(
+                        deletedFiber,
+                        nearestMountedAncestor,
+                        destroy
+                      ),
+                      recordLayoutEffectDuration(deletedFiber))
+                    : ((inst.destroy = void 0),
+                      safelyCallDestroy(
+                        deletedFiber,
+                        nearestMountedAncestor,
+                        destroy
+                      ))));
+            effect = effect.next;
+          } while (effect !== updateQueue);
+        }
+      }
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
+      break;
+    case 1:
+      if (
+        !offscreenSubtreeWasHidden &&
+        (safelyDetachRef(deletedFiber, nearestMountedAncestor),
+        (updateQueue = deletedFiber.stateNode),
+        "function" === typeof updateQueue.componentWillUnmount)
+      )
+        try {
+          callComponentWillUnmountWithTimer(deletedFiber, updateQueue);
+        } catch (error) {
+          captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
+        }
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
+      break;
+    case 21:
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
       break;
     case 22:
-      var instance = finishedWork.stateNode;
-      null !== finishedWork.memoizedState &&
-      instance._visibility & 4 &&
-      (null === finishedWork.return || 13 !== finishedWork.return.tag)
-        ? ((instance._visibility &= -5),
-          recursivelyTraverseDisconnectPassiveEffects(finishedWork))
-        : recursivelyTraversePassiveUnmountEffects(finishedWork);
+      safelyDetachRef(deletedFiber, nearestMountedAncestor);
+      deletedFiber.mode & 1
+        ? ((offscreenSubtreeWasHidden =
+            (updateQueue = offscreenSubtreeWasHidden) ||
+            null !== deletedFiber.memoizedState),
+          recursivelyTraverseDeletionEffects(
+            finishedRoot,
+            nearestMountedAncestor,
+            deletedFiber
+          ),
+          (offscreenSubtreeWasHidden = updateQueue))
+        : recursivelyTraverseDeletionEffects(
+            finishedRoot,
+            nearestMountedAncestor,
+            deletedFiber
+          );
       break;
     default:
-      recursivelyTraversePassiveUnmountEffects(finishedWork);
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
   }
 }
-function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
-  var deletions = parentFiber.deletions;
-  if (0 !== (parentFiber.flags & 16)) {
-    if (null !== deletions)
-      for (var i = 0; i < deletions.length; i++) {
-        var childToDelete = deletions[i];
-        nextEffect = childToDelete;
-        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
-          childToDelete,
-          parentFiber
-        );
-      }
-    detachAlternateSiblings(parentFiber);
-  }
-  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
-    deletions = parentFiber;
-    switch (deletions.tag) {
-      case 0:
-      case 11:
-      case 15:
-        commitHookPassiveUnmountEffects(deletions, deletions.return, 8);
-        recursivelyTraverseDisconnectPassiveEffects(deletions);
-        break;
-      case 22:
-        i = deletions.stateNode;
-        i._visibility & 4 &&
-          ((i._visibility &= -5),
-          recursivelyTraverseDisconnectPassiveEffects(deletions));
-        break;
-      default:
-        recursivelyTraverseDisconnectPassiveEffects(deletions);
-    }
-    parentFiber = parentFiber.sibling;
+function getRetryCache(finishedWork) {
+  switch (finishedWork.tag) {
+    case 13:
+    case 19:
+      var retryCache = finishedWork.stateNode;
+      null === retryCache &&
+        (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
+      return retryCache;
+    case 22:
+      return (
+        (finishedWork = finishedWork.stateNode),
+        (retryCache = finishedWork._retryCache),
+        null === retryCache &&
+          (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),
+        retryCache
+      );
+    default:
+      throw Error(
+        "Unexpected Suspense handler tag (" +
+          finishedWork.tag +
+          "). This is a bug in React."
+      );
   }
 }
-function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
-  deletedSubtreeRoot,
-  nearestMountedAncestor
-) {
-  for (; null !== nextEffect; ) {
-    var fiber = nextEffect;
-    switch (fiber.tag) {
-      case 0:
-      case 11:
-      case 15:
-        commitHookPassiveUnmountEffects(fiber, nearestMountedAncestor, 8);
+function attachSuspenseRetryListeners(finishedWork, wakeables) {
+  var retryCache = getRetryCache(finishedWork);
+  wakeables.forEach(function (wakeable) {
+    var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
+    if (!retryCache.has(wakeable)) {
+      retryCache.add(wakeable);
+      if (isDevToolsPresent)
+        if (null !== inProgressLanes && null !== inProgressRoot)
+          restorePendingUpdaters(inProgressRoot, inProgressLanes);
+        else
+          throw Error(
+            "Expected finished root and lanes to be set. This is a bug in React."
+          );
+      wakeable.then(retry, retry);
     }
-    var child = fiber.child;
-    if (null !== child) (child.return = fiber), (nextEffect = child);
-    else
-      a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
-        child = nextEffect;
-        var sibling = child.sibling,
-          returnFiber = child.return;
-        detachFiberAfterEffects(child);
-        if (child === fiber) {
-          nextEffect = null;
-          break a;
-        }
-        if (null !== sibling) {
-          sibling.return = returnFiber;
-          nextEffect = sibling;
-          break a;
-        }
-        nextEffect = returnFiber;
-      }
-  }
+  });
 }
-var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
-  ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher,
-  ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner,
-  ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig,
-  executionContext = 0,
-  workInProgressRoot = null,
-  workInProgress = null,
-  workInProgressRootRenderLanes = 0,
-  workInProgressSuspendedReason = 0,
-  workInProgressThrownValue = null,
-  workInProgressRootDidAttachPingListener = !1,
-  entangledRenderLanes = 0,
-  workInProgressRootExitStatus = 0,
-  workInProgressRootFatalError = null,
-  workInProgressRootSkippedLanes = 0,
-  workInProgressRootInterleavedUpdatedLanes = 0,
-  workInProgressRootPingedLanes = 0,
-  workInProgressDeferredLane = 0,
-  workInProgressRootConcurrentErrors = null,
-  workInProgressRootRecoverableErrors = null,
-  globalMostRecentFallbackTime = 0,
-  workInProgressRootRenderTargetTime = Infinity,
-  workInProgressTransitions = null,
-  hasUncaughtError = !1,
-  firstUncaughtError = null,
-  legacyErrorBoundariesThatAlreadyFailed = null,
-  rootDoesHavePassiveEffects = !1,
-  rootWithPendingPassiveEffects = null,
-  pendingPassiveEffectsLanes = 0,
-  pendingPassiveProfilerEffects = [],
-  nestedUpdateCount = 0,
-  rootWithNestedUpdates = null;
-function requestUpdateLane(fiber) {
-  if (0 === (fiber.mode & 1)) return 2;
-  if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)
-    return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
-  fiber = ReactCurrentBatchConfig$1.transition;
-  null !== fiber && fiber._callbacks.add(handleAsyncAction);
-  if (null !== fiber)
-    return (
-      0 === currentEventTransitionLane &&
-        (currentEventTransitionLane = claimNextTransitionLane()),
-      currentEventTransitionLane
-    );
-  fiber = currentUpdatePriority;
-  if (0 === fiber)
-    a: {
-      fiber = fabricGetCurrentEventPriority
-        ? fabricGetCurrentEventPriority()
-        : null;
-      if (null != fiber)
-        switch (fiber) {
-          case FabricDiscretePriority:
-            fiber = 2;
-            break a;
-        }
-      fiber = 32;
-    }
-  return fiber;
+function commitMutationEffects(root, finishedWork, committedLanes) {
+  inProgressLanes = committedLanes;
+  inProgressRoot = root;
+  commitMutationEffectsOnFiber(finishedWork, root);
+  inProgressRoot = inProgressLanes = null;
 }
-function scheduleUpdateOnFiber(root, fiber, lane) {
-  if (
-    (root === workInProgressRoot && 2 === workInProgressSuspendedReason) ||
-    null !== root.cancelPendingCommit
-  )
-    prepareFreshStack(root, 0),
-      markRootSuspended(
-        root,
-        workInProgressRootRenderLanes,
-        workInProgressDeferredLane
-      );
-  markRootUpdated(root, lane);
-  if (0 === (executionContext & 2) || root !== workInProgressRoot)
-    isDevToolsPresent && addFiberToLanesMap(root, fiber, lane),
-      root === workInProgressRoot &&
-        (0 === (executionContext & 2) &&
-          (workInProgressRootInterleavedUpdatedLanes |= lane),
-        4 === workInProgressRootExitStatus &&
-          markRootSuspended(
-            root,
-            workInProgressRootRenderLanes,
-            workInProgressDeferredLane
-          )),
-      ensureRootIsScheduled(root),
-      2 === lane &&
-        0 === executionContext &&
-        0 === (fiber.mode & 1) &&
-        ((workInProgressRootRenderTargetTime = now$1() + 500),
-        flushSyncWorkAcrossRoots_impl(!0));
+function recursivelyTraverseMutationEffects(root, parentFiber) {
+  var deletions = parentFiber.deletions;
+  if (null !== deletions)
+    for (var i = 0; i < deletions.length; i++) {
+      var childToDelete = deletions[i];
+      try {
+        commitDeletionEffectsOnFiber(root, parentFiber, childToDelete);
+        var alternate = childToDelete.alternate;
+        null !== alternate && (alternate.return = null);
+        childToDelete.return = null;
+      } catch (error) {
+        captureCommitPhaseError(childToDelete, parentFiber, error);
+      }
+    }
+  if (parentFiber.subtreeFlags & 12854)
+    for (parentFiber = parentFiber.child; null !== parentFiber; )
+      commitMutationEffectsOnFiber(parentFiber, root),
+        (parentFiber = parentFiber.sibling);
 }
-function performConcurrentWorkOnRoot(root, didTimeout) {
-  nestedUpdateScheduled = currentUpdateIsNested = !1;
-  if (0 !== (executionContext & 6))
-    throw Error("Should not already be working.");
-  var originalCallbackNode = root.callbackNode;
-  if (flushPassiveEffects() && root.callbackNode !== originalCallbackNode)
-    return null;
-  var lanes = getNextLanes(
-    root,
-    root === workInProgressRoot ? workInProgressRootRenderLanes : 0
-  );
-  if (0 === lanes) return null;
-  var exitStatus = (didTimeout =
-    0 === (lanes & 60) && 0 === (lanes & root.expiredLanes) && !didTimeout)
-    ? renderRootConcurrent(root, lanes)
-    : renderRootSync(root, lanes);
-  if (0 !== exitStatus) {
-    var renderWasConcurrent = didTimeout;
-    do {
-      if (6 === exitStatus) markRootSuspended(root, lanes, 0);
-      else {
-        didTimeout = root.current.alternate;
-        if (
-          renderWasConcurrent &&
-          !isRenderConsistentWithExternalStores(didTimeout)
-        ) {
-          exitStatus = renderRootSync(root, lanes);
-          renderWasConcurrent = !1;
-          continue;
-        }
-        if (2 === exitStatus) {
-          renderWasConcurrent = lanes;
-          var errorRetryLanes = getLanesToRetrySynchronouslyOnError(
-            root,
-            renderWasConcurrent
-          );
-          0 !== errorRetryLanes &&
-            ((lanes = errorRetryLanes),
-            (exitStatus = recoverFromConcurrentError(
-              root,
-              renderWasConcurrent,
-              errorRetryLanes
-            )));
+function commitMutationEffectsOnFiber(finishedWork, root) {
+  var current = finishedWork.alternate,
+    flags = finishedWork.flags;
+  switch (finishedWork.tag) {
+    case 0:
+    case 11:
+    case 14:
+    case 15:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      if (flags & 4) {
+        try {
+          commitHookEffectListUnmount(3, finishedWork, finishedWork.return),
+            commitHookEffectListMount(3, finishedWork);
+        } catch (error) {
+          captureCommitPhaseError(finishedWork, finishedWork.return, error);
         }
-        if (1 === exitStatus)
-          throw (
-            ((originalCallbackNode = workInProgressRootFatalError),
-            prepareFreshStack(root, 0),
-            markRootSuspended(root, lanes, 0),
-            ensureRootIsScheduled(root),
-            originalCallbackNode)
-          );
-        root.finishedWork = didTimeout;
-        root.finishedLanes = lanes;
-        a: {
-          renderWasConcurrent = root;
-          switch (exitStatus) {
-            case 0:
-            case 1:
-              throw Error("Root did not complete. This is a bug in React.");
-            case 4:
-              if ((lanes & 4194176) === lanes) {
-                markRootSuspended(
-                  renderWasConcurrent,
-                  lanes,
-                  workInProgressDeferredLane
-                );
-                break a;
-              }
-              break;
-            case 2:
-            case 3:
-            case 5:
-              break;
-            default:
-              throw Error("Unknown root exit status.");
-          }
-          if (
-            (lanes & 62914560) === lanes &&
-            3 === exitStatus &&
-            ((exitStatus = globalMostRecentFallbackTime + 300 - now$1()),
-            10 < exitStatus)
-          ) {
-            markRootSuspended(
-              renderWasConcurrent,
-              lanes,
-              workInProgressDeferredLane
+        if (shouldProfile(finishedWork)) {
+          try {
+            startLayoutEffectTimer(),
+              commitHookEffectListUnmount(5, finishedWork, finishedWork.return);
+          } catch (error$93) {
+            captureCommitPhaseError(
+              finishedWork,
+              finishedWork.return,
+              error$93
             );
-            if (0 !== getNextLanes(renderWasConcurrent, 0)) break a;
-            renderWasConcurrent.timeoutHandle = scheduleTimeout(
-              commitRootWhenReady.bind(
-                null,
-                renderWasConcurrent,
-                didTimeout,
-                workInProgressRootRecoverableErrors,
-                workInProgressTransitions,
-                lanes,
-                workInProgressDeferredLane
-              ),
-              exitStatus
+          }
+          recordLayoutEffectDuration(finishedWork);
+        } else
+          try {
+            commitHookEffectListUnmount(5, finishedWork, finishedWork.return);
+          } catch (error$94) {
+            captureCommitPhaseError(
+              finishedWork,
+              finishedWork.return,
+              error$94
             );
-            break a;
           }
-          commitRootWhenReady(
-            renderWasConcurrent,
-            didTimeout,
-            workInProgressRootRecoverableErrors,
-            workInProgressTransitions,
-            lanes,
-            workInProgressDeferredLane
-          );
-        }
       }
       break;
-    } while (1);
-  }
-  ensureRootIsScheduled(root);
-  scheduleTaskForRootDuringMicrotask(root, now$1());
-  root =
-    root.callbackNode === originalCallbackNode
-      ? performConcurrentWorkOnRoot.bind(null, root)
-      : null;
-  return root;
-}
-function recoverFromConcurrentError(
-  root,
-  originallyAttemptedLanes,
-  errorRetryLanes
-) {
-  var errorsFromFirstAttempt = workInProgressRootConcurrentErrors,
-    JSCompiler_inline_result;
-  (JSCompiler_inline_result = root.current.memoizedState.isDehydrated) &&
-    (prepareFreshStack(root, errorRetryLanes).flags |= 256);
-  errorRetryLanes = renderRootSync(root, errorRetryLanes);
-  if (2 !== errorRetryLanes) {
-    if (workInProgressRootDidAttachPingListener && !JSCompiler_inline_result)
-      return (
-        (root.errorRecoveryDisabledLanes |= originallyAttemptedLanes),
-        (workInProgressRootInterleavedUpdatedLanes |= originallyAttemptedLanes),
-        4
-      );
-    root = workInProgressRootRecoverableErrors;
-    workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
-    null !== root && queueRecoverableErrors(root);
+    case 1:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      flags & 512 &&
+        null !== current &&
+        safelyDetachRef(current, current.return);
+      flags & 64 &&
+        offscreenSubtreeIsHidden &&
+        ((finishedWork = finishedWork.updateQueue),
+        null !== finishedWork &&
+          ((flags = finishedWork.callbacks),
+          null !== flags &&
+            ((current = finishedWork.shared.hiddenCallbacks),
+            (finishedWork.shared.hiddenCallbacks =
+              null === current ? flags : current.concat(flags)))));
+      break;
+    case 26:
+    case 27:
+    case 5:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      flags & 512 &&
+        null !== current &&
+        safelyDetachRef(current, current.return);
+      break;
+    case 6:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      break;
+    case 3:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      break;
+    case 4:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      break;
+    case 13:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      finishedWork.child.flags & 8192 &&
+        ((current = null !== current && null !== current.memoizedState),
+        null === finishedWork.memoizedState ||
+          current ||
+          (globalMostRecentFallbackTime = now$1()));
+      flags & 4 &&
+        ((flags = finishedWork.updateQueue),
+        null !== flags &&
+          ((finishedWork.updateQueue = null),
+          attachSuspenseRetryListeners(finishedWork, flags)));
+      break;
+    case 22:
+      flags & 512 &&
+        null !== current &&
+        safelyDetachRef(current, current.return);
+      var isHidden = null !== finishedWork.memoizedState,
+        wasHidden = null !== current && null !== current.memoizedState;
+      if (finishedWork.mode & 1) {
+        var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
+          prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
+        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || isHidden;
+        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
+        recursivelyTraverseMutationEffects(root, finishedWork);
+        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
+        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
+      } else recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      root = finishedWork.stateNode;
+      root._current = finishedWork;
+      root._visibility &= -3;
+      root._visibility |= root._pendingVisibility & 2;
+      flags & 8192 &&
+        ((root._visibility = isHidden
+          ? root._visibility & -2
+          : root._visibility | 1),
+        isHidden &&
+          ((isHidden = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden),
+          null === current ||
+            wasHidden ||
+            isHidden ||
+            (0 !== (finishedWork.mode & 1) &&
+              recursivelyTraverseDisappearLayoutEffects(finishedWork))));
+      flags & 4 &&
+        ((flags = finishedWork.updateQueue),
+        null !== flags &&
+          ((current = flags.retryQueue),
+          null !== current &&
+            ((flags.retryQueue = null),
+            attachSuspenseRetryListeners(finishedWork, current))));
+      break;
+    case 19:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      flags & 4 &&
+        ((flags = finishedWork.updateQueue),
+        null !== flags &&
+          ((finishedWork.updateQueue = null),
+          attachSuspenseRetryListeners(finishedWork, flags)));
+      break;
+    case 21:
+      break;
+    default:
+      recursivelyTraverseMutationEffects(root, finishedWork),
+        commitReconciliationEffects(finishedWork);
   }
-  return errorRetryLanes;
 }
-function queueRecoverableErrors(errors) {
-  null === workInProgressRootRecoverableErrors
-    ? (workInProgressRootRecoverableErrors = errors)
-    : workInProgressRootRecoverableErrors.push.apply(
-        workInProgressRootRecoverableErrors,
-        errors
-      );
+function commitReconciliationEffects(finishedWork) {
+  var flags = finishedWork.flags;
+  flags & 2 && (finishedWork.flags &= -3);
+  flags & 4096 && (finishedWork.flags &= -4097);
 }
-function commitRootWhenReady(
-  root,
-  finishedWork,
-  recoverableErrors,
-  transitions,
-  lanes,
-  spawnedLane
-) {
-  0 === (lanes & 42) && accumulateSuspenseyCommitOnFiber(finishedWork);
-  commitRoot(root, recoverableErrors, transitions, spawnedLane);
+function commitLayoutEffects(finishedWork, root, committedLanes) {
+  inProgressLanes = committedLanes;
+  inProgressRoot = root;
+  commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);
+  inProgressRoot = inProgressLanes = null;
 }
-function isRenderConsistentWithExternalStores(finishedWork) {
-  for (var node = finishedWork; ; ) {
-    if (node.flags & 16384) {
-      var updateQueue = node.updateQueue;
-      if (
-        null !== updateQueue &&
-        ((updateQueue = updateQueue.stores), null !== updateQueue)
-      )
-        for (var i = 0; i < updateQueue.length; i++) {
-          var check = updateQueue[i],
-            getSnapshot = check.getSnapshot;
-          check = check.value;
+function recursivelyTraverseLayoutEffects(root, parentFiber) {
+  if (parentFiber.subtreeFlags & 8772)
+    for (parentFiber = parentFiber.child; null !== parentFiber; )
+      commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),
+        (parentFiber = parentFiber.sibling);
+}
+function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
+  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+    var finishedWork = parentFiber;
+    switch (finishedWork.tag) {
+      case 0:
+      case 11:
+      case 14:
+      case 15:
+        if (shouldProfile(finishedWork))
           try {
-            if (!objectIs(getSnapshot(), check)) return !1;
+            startLayoutEffectTimer(),
+              commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
+          } finally {
+            recordLayoutEffectDuration(finishedWork);
+          }
+        else commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
+        recursivelyTraverseDisappearLayoutEffects(finishedWork);
+        break;
+      case 1:
+        safelyDetachRef(finishedWork, finishedWork.return);
+        var instance = finishedWork.stateNode;
+        if ("function" === typeof instance.componentWillUnmount) {
+          var current = finishedWork,
+            nearestMountedAncestor = finishedWork.return;
+          try {
+            callComponentWillUnmountWithTimer(current, instance);
           } catch (error) {
-            return !1;
+            captureCommitPhaseError(current, nearestMountedAncestor, error);
           }
         }
+        recursivelyTraverseDisappearLayoutEffects(finishedWork);
+        break;
+      case 26:
+      case 27:
+      case 5:
+        safelyDetachRef(finishedWork, finishedWork.return);
+        recursivelyTraverseDisappearLayoutEffects(finishedWork);
+        break;
+      case 22:
+        safelyDetachRef(finishedWork, finishedWork.return);
+        null === finishedWork.memoizedState &&
+          recursivelyTraverseDisappearLayoutEffects(finishedWork);
+        break;
+      default:
+        recursivelyTraverseDisappearLayoutEffects(finishedWork);
     }
-    updateQueue = node.child;
-    if (node.subtreeFlags & 16384 && null !== updateQueue)
-      (updateQueue.return = node), (node = updateQueue);
-    else {
-      if (node === finishedWork) break;
-      for (; null === node.sibling; ) {
-        if (null === node.return || node.return === finishedWork) return !0;
-        node = node.return;
-      }
-      node.sibling.return = node.return;
-      node = node.sibling;
-    }
-  }
-  return !0;
-}
-function markRootSuspended(root, suspendedLanes, spawnedLane) {
-  suspendedLanes &= ~workInProgressRootPingedLanes;
-  suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
-  root.suspendedLanes |= suspendedLanes;
-  root.pingedLanes &= ~suspendedLanes;
-  for (
-    var expirationTimes = root.expirationTimes, lanes = suspendedLanes;
-    0 < lanes;
-
-  ) {
-    var index$4 = 31 - clz32(lanes),
-      lane = 1 << index$4;
-    expirationTimes[index$4] = -1;
-    lanes &= ~lane;
-  }
-  0 !== spawnedLane &&
-    markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
-}
-function resetWorkInProgressStack() {
-  if (null !== workInProgress) {
-    if (0 === workInProgressSuspendedReason)
-      var interruptedWork = workInProgress.return;
-    else
-      (interruptedWork = workInProgress),
-        resetContextDependencies(),
-        resetHooksOnUnwind(interruptedWork),
-        (thenableState$1 = null),
-        (thenableIndexCounter$1 = 0),
-        (interruptedWork = workInProgress);
-    for (; null !== interruptedWork; )
-      unwindInterruptedWork(interruptedWork.alternate, interruptedWork),
-        (interruptedWork = interruptedWork.return);
-    workInProgress = null;
+    parentFiber = parentFiber.sibling;
   }
 }
-function prepareFreshStack(root, lanes) {
-  root.finishedWork = null;
-  root.finishedLanes = 0;
-  var timeoutHandle = root.timeoutHandle;
-  -1 !== timeoutHandle &&
-    ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle));
-  timeoutHandle = root.cancelPendingCommit;
-  null !== timeoutHandle &&
-    ((root.cancelPendingCommit = null), timeoutHandle());
-  resetWorkInProgressStack();
-  workInProgressRoot = root;
-  workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
-  workInProgressRootRenderLanes = lanes;
-  workInProgressSuspendedReason = 0;
-  workInProgressThrownValue = null;
-  workInProgressRootDidAttachPingListener = !1;
-  workInProgressRootExitStatus = 0;
-  workInProgressRootFatalError = null;
-  workInProgressDeferredLane =
-    workInProgressRootPingedLanes =
-    workInProgressRootInterleavedUpdatedLanes =
-    workInProgressRootSkippedLanes =
-      0;
-  workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors =
-    null;
-  0 !== (lanes & 8) && (lanes |= lanes & 32);
-  var allEntangledLanes = root.entangledLanes;
-  if (0 !== allEntangledLanes)
-    for (
-      root = root.entanglements, allEntangledLanes &= lanes;
-      0 < allEntangledLanes;
-
-    ) {
-      var index$2 = 31 - clz32(allEntangledLanes),
-        lane = 1 << index$2;
-      lanes |= root[index$2];
-      allEntangledLanes &= ~lane;
+function recursivelyTraverseReappearLayoutEffects(
+  finishedRoot$jscomp$0,
+  parentFiber,
+  includeWorkInProgressEffects
+) {
+  includeWorkInProgressEffects =
+    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
+  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+    var current = parentFiber.alternate,
+      finishedRoot = finishedRoot$jscomp$0,
+      finishedWork = parentFiber,
+      flags = finishedWork.flags;
+    switch (finishedWork.tag) {
+      case 0:
+      case 11:
+      case 15:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+        commitHookLayoutEffects(finishedWork, 4);
+        break;
+      case 1:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+        finishedRoot = finishedWork.stateNode;
+        if ("function" === typeof finishedRoot.componentDidMount)
+          try {
+            finishedRoot.componentDidMount();
+          } catch (error) {
+            captureCommitPhaseError(finishedWork, finishedWork.return, error);
+          }
+        current = finishedWork.updateQueue;
+        if (null !== current) {
+          var hiddenCallbacks = current.shared.hiddenCallbacks;
+          if (null !== hiddenCallbacks)
+            for (
+              current.shared.hiddenCallbacks = null, current = 0;
+              current < hiddenCallbacks.length;
+              current++
+            )
+              callCallback(hiddenCallbacks[current], finishedRoot);
+        }
+        includeWorkInProgressEffects &&
+          flags & 64 &&
+          commitClassCallbacks(finishedWork);
+        safelyAttachRef(finishedWork, finishedWork.return);
+        break;
+      case 26:
+      case 27:
+      case 5:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+        includeWorkInProgressEffects &&
+          null === current &&
+          flags & 4 &&
+          commitHostComponentMount(finishedWork);
+        safelyAttachRef(finishedWork, finishedWork.return);
+        break;
+      case 12:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+        includeWorkInProgressEffects &&
+          flags & 4 &&
+          commitProfilerUpdate(finishedWork, current);
+        break;
+      case 13:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+        break;
+      case 22:
+        null === finishedWork.memoizedState &&
+          recursivelyTraverseReappearLayoutEffects(
+            finishedRoot,
+            finishedWork,
+            includeWorkInProgressEffects
+          );
+        safelyAttachRef(finishedWork, finishedWork.return);
+        break;
+      default:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
     }
-  entangledRenderLanes = lanes;
-  finishQueueingConcurrentUpdates();
-  return timeoutHandle;
-}
-function handleThrow(root, thrownValue) {
-  currentlyRenderingFiber$1 = null;
-  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
-  ReactCurrentOwner.current = null;
-  thrownValue === SuspenseException
-    ? ((thrownValue = getSuspendedThenable()),
-      (root = suspenseHandlerStackCursor.current),
-      (workInProgressSuspendedReason =
-        (null !== root &&
-          ((workInProgressRootRenderLanes & 4194176) ===
-          workInProgressRootRenderLanes
-            ? null !== shellBoundary
-            : ((workInProgressRootRenderLanes & 62914560) !==
-                workInProgressRootRenderLanes &&
-                0 === (workInProgressRootRenderLanes & 536870912)) ||
-              root !== shellBoundary)) ||
-        0 !== (workInProgressRootSkippedLanes & 134217727) ||
-        0 !== (workInProgressRootInterleavedUpdatedLanes & 134217727)
-          ? 3
-          : 2))
-    : thrownValue === SuspenseyCommitException
-    ? ((thrownValue = getSuspendedThenable()),
-      (workInProgressSuspendedReason = 4))
-    : (workInProgressSuspendedReason =
-        thrownValue === SelectiveHydrationException
-          ? 8
-          : null !== thrownValue &&
-            "object" === typeof thrownValue &&
-            "function" === typeof thrownValue.then
-          ? 6
-          : 1);
-  workInProgressThrownValue = thrownValue;
-  root = workInProgress;
-  null === root
-    ? ((workInProgressRootExitStatus = 1),
-      (workInProgressRootFatalError = thrownValue))
-    : root.mode & 2 && stopProfilerTimerIfRunningAndRecordDelta(root, !0);
-}
-function pushDispatcher() {
-  var prevDispatcher = ReactCurrentDispatcher.current;
-  ReactCurrentDispatcher.current = ContextOnlyDispatcher;
-  return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
-}
-function renderDidSuspendDelayIfPossible() {
-  workInProgressRootExitStatus = 4;
-  (0 === (workInProgressRootSkippedLanes & 134217727) &&
-    0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||
-    null === workInProgressRoot ||
-    markRootSuspended(
-      workInProgressRoot,
-      workInProgressRootRenderLanes,
-      workInProgressDeferredLane
-    );
+    parentFiber = parentFiber.sibling;
+  }
 }
-function renderRootSync(root, lanes) {
-  var prevExecutionContext = executionContext;
-  executionContext |= 2;
-  var prevDispatcher = pushDispatcher();
-  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
-    if (isDevToolsPresent) {
-      var memoizedUpdaters = root.memoizedUpdaters;
-      0 < memoizedUpdaters.size &&
-        (restorePendingUpdaters(root, workInProgressRootRenderLanes),
-        memoizedUpdaters.clear());
-      movePendingFibersToMemoized(root, lanes);
+function commitHookPassiveMountEffects(finishedWork, hookFlags) {
+  if (shouldProfile(finishedWork)) {
+    passiveEffectStartTime = now();
+    try {
+      commitHookEffectListMount(hookFlags, finishedWork);
+    } catch (error) {
+      captureCommitPhaseError(finishedWork, finishedWork.return, error);
     }
-    workInProgressTransitions = null;
-    prepareFreshStack(root, lanes);
-  }
-  lanes = !1;
-  a: do
+    recordPassiveEffectDuration(finishedWork);
+  } else
     try {
-      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
-        memoizedUpdaters = workInProgress;
-        var thrownValue = workInProgressThrownValue;
-        switch (workInProgressSuspendedReason) {
-          case 8:
-            resetWorkInProgressStack();
-            workInProgressRootExitStatus = 6;
-            break a;
-          case 3:
-          case 2:
-            lanes ||
-              null !== suspenseHandlerStackCursor.current ||
-              (lanes = !0);
-          default:
-            (workInProgressSuspendedReason = 0),
-              (workInProgressThrownValue = null),
-              throwAndUnwindWorkLoop(root, memoizedUpdaters, thrownValue);
-        }
-      }
-      workLoopSync();
-      break;
-    } catch (thrownValue$104) {
-      handleThrow(root, thrownValue$104);
+      commitHookEffectListMount(hookFlags, finishedWork);
+    } catch (error$102) {
+      captureCommitPhaseError(finishedWork, finishedWork.return, error$102);
     }
-  while (1);
-  lanes && root.shellSuspendCounter++;
-  resetContextDependencies();
-  executionContext = prevExecutionContext;
-  ReactCurrentDispatcher.current = prevDispatcher;
-  if (null !== workInProgress)
-    throw Error(
-      "Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue."
-    );
-  workInProgressRoot = null;
-  workInProgressRootRenderLanes = 0;
-  finishQueueingConcurrentUpdates();
-  return workInProgressRootExitStatus;
 }
-function workLoopSync() {
-  for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
+function recursivelyTraversePassiveMountEffects(root, parentFiber) {
+  if (parentFiber.subtreeFlags & 10256)
+    for (parentFiber = parentFiber.child; null !== parentFiber; )
+      commitPassiveMountOnFiber(root, parentFiber),
+        (parentFiber = parentFiber.sibling);
 }
-function renderRootConcurrent(root, lanes) {
-  var prevExecutionContext = executionContext;
-  executionContext |= 2;
-  var prevDispatcher = pushDispatcher();
-  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
-    if (isDevToolsPresent) {
-      var memoizedUpdaters = root.memoizedUpdaters;
-      0 < memoizedUpdaters.size &&
-        (restorePendingUpdaters(root, workInProgressRootRenderLanes),
-        memoizedUpdaters.clear());
-      movePendingFibersToMemoized(root, lanes);
-    }
-    workInProgressTransitions = null;
-    workInProgressRootRenderTargetTime = now$1() + 500;
-    prepareFreshStack(root, lanes);
-  }
-  a: do
-    try {
-      if (0 !== workInProgressSuspendedReason && null !== workInProgress)
-        b: switch (
-          ((lanes = workInProgress),
-          (memoizedUpdaters = workInProgressThrownValue),
-          workInProgressSuspendedReason)
-        ) {
-          case 1:
-            workInProgressSuspendedReason = 0;
-            workInProgressThrownValue = null;
-            throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters);
-            break;
-          case 2:
-            if (isThenableResolved(memoizedUpdaters)) {
-              workInProgressSuspendedReason = 0;
-              workInProgressThrownValue = null;
-              replaySuspendedUnitOfWork(lanes);
-              break;
-            }
-            lanes = function () {
-              2 === workInProgressSuspendedReason &&
-                workInProgressRoot === root &&
-                (workInProgressSuspendedReason = 7);
-              ensureRootIsScheduled(root);
-            };
-            memoizedUpdaters.then(lanes, lanes);
-            break a;
-          case 3:
-            workInProgressSuspendedReason = 7;
-            break a;
-          case 4:
-            workInProgressSuspendedReason = 5;
-            break a;
-          case 7:
-            isThenableResolved(memoizedUpdaters)
-              ? ((workInProgressSuspendedReason = 0),
-                (workInProgressThrownValue = null),
-                replaySuspendedUnitOfWork(lanes))
-              : ((workInProgressSuspendedReason = 0),
-                (workInProgressThrownValue = null),
-                throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters));
-            break;
-          case 5:
-            switch (workInProgress.tag) {
-              case 5:
-              case 26:
-              case 27:
-                lanes = workInProgress;
-                workInProgressSuspendedReason = 0;
-                workInProgressThrownValue = null;
-                var sibling = lanes.sibling;
-                if (null !== sibling) workInProgress = sibling;
-                else {
-                  var returnFiber = lanes.return;
-                  null !== returnFiber
-                    ? ((workInProgress = returnFiber),
-                      completeUnitOfWork(returnFiber))
-                    : (workInProgress = null);
-                }
-                break b;
-            }
-            workInProgressSuspendedReason = 0;
-            workInProgressThrownValue = null;
-            throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters);
-            break;
-          case 6:
-            workInProgressSuspendedReason = 0;
-            workInProgressThrownValue = null;
-            throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters);
-            break;
-          case 8:
-            resetWorkInProgressStack();
-            workInProgressRootExitStatus = 6;
-            break a;
-          default:
-            throw Error("Unexpected SuspendedReason. This is a bug in React.");
-        }
-      workLoopConcurrent();
-      break;
-    } catch (thrownValue$106) {
-      handleThrow(root, thrownValue$106);
-    }
-  while (1);
-  resetContextDependencies();
-  ReactCurrentDispatcher.current = prevDispatcher;
-  executionContext = prevExecutionContext;
-  if (null !== workInProgress) return 0;
-  workInProgressRoot = null;
-  workInProgressRootRenderLanes = 0;
-  finishQueueingConcurrentUpdates();
-  return workInProgressRootExitStatus;
-}
-function workLoopConcurrent() {
-  for (; null !== workInProgress && !shouldYield(); )
-    performUnitOfWork(workInProgress);
-}
-function performUnitOfWork(unitOfWork) {
-  var current = unitOfWork.alternate;
-  0 !== (unitOfWork.mode & 2)
-    ? (startProfilerTimer(unitOfWork),
-      (current = beginWork(current, unitOfWork, entangledRenderLanes)),
-      stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, !0))
-    : (current = beginWork(current, unitOfWork, entangledRenderLanes));
-  unitOfWork.memoizedProps = unitOfWork.pendingProps;
-  null === current
-    ? completeUnitOfWork(unitOfWork)
-    : (workInProgress = current);
-  ReactCurrentOwner.current = null;
-}
-function replaySuspendedUnitOfWork(unitOfWork) {
-  var current = unitOfWork.alternate,
-    isProfilingMode = 0 !== (unitOfWork.mode & 2);
-  isProfilingMode && startProfilerTimer(unitOfWork);
-  switch (unitOfWork.tag) {
-    case 2:
-      unitOfWork.tag = 0;
-    case 15:
+function commitPassiveMountOnFiber(finishedRoot, finishedWork) {
+  var flags = finishedWork.flags;
+  switch (finishedWork.tag) {
     case 0:
-      var Component = unitOfWork.type,
-        unresolvedProps = unitOfWork.pendingProps;
-      unresolvedProps =
-        unitOfWork.elementType === Component
-          ? unresolvedProps
-          : resolveDefaultProps(Component, unresolvedProps);
-      var context = isContextProvider(Component)
-        ? previousContext
-        : contextStackCursor$1.current;
-      context = getMaskedContext(unitOfWork, context);
-      current = replayFunctionComponent(
-        current,
-        unitOfWork,
-        unresolvedProps,
-        Component,
-        context,
-        workInProgressRootRenderLanes
-      );
-      break;
     case 11:
-      Component = unitOfWork.type.render;
-      unresolvedProps = unitOfWork.pendingProps;
-      unresolvedProps =
-        unitOfWork.elementType === Component
-          ? unresolvedProps
-          : resolveDefaultProps(Component, unresolvedProps);
-      current = replayFunctionComponent(
-        current,
-        unitOfWork,
-        unresolvedProps,
-        Component,
-        unitOfWork.ref,
-        workInProgressRootRenderLanes
-      );
+    case 15:
+      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
+      flags & 2048 && commitHookPassiveMountEffects(finishedWork, 9);
+      break;
+    case 3:
+      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
+      break;
+    case 23:
+      break;
+    case 22:
+      flags = finishedWork.stateNode;
+      null !== finishedWork.memoizedState
+        ? flags._visibility & 4
+          ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork)
+          : finishedWork.mode & 1 ||
+            ((flags._visibility |= 4),
+            recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork))
+        : flags._visibility & 4
+        ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork)
+        : ((flags._visibility |= 4),
+          recursivelyTraverseReconnectPassiveEffects(
+            finishedRoot,
+            finishedWork
+          ));
+      break;
+    case 24:
+      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
       break;
-    case 5:
-      resetHooksOnUnwind(unitOfWork);
     default:
-      unwindInterruptedWork(current, unitOfWork),
-        (unitOfWork = workInProgress =
-          resetWorkInProgress(unitOfWork, entangledRenderLanes)),
-        (current = beginWork(current, unitOfWork, entangledRenderLanes));
+      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
   }
-  isProfilingMode && stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, !0);
-  unitOfWork.memoizedProps = unitOfWork.pendingProps;
-  null === current
-    ? completeUnitOfWork(unitOfWork)
-    : (workInProgress = current);
-  ReactCurrentOwner.current = null;
 }
-function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue) {
-  resetContextDependencies();
-  resetHooksOnUnwind(unitOfWork);
-  thenableState$1 = null;
-  thenableIndexCounter$1 = 0;
-  var returnFiber = unitOfWork.return;
-  try {
-    if (
-      throwException(
-        root,
-        returnFiber,
-        unitOfWork,
-        thrownValue,
-        workInProgressRootRenderLanes
-      )
-    ) {
-      workInProgressRootExitStatus = 1;
-      workInProgressRootFatalError = thrownValue;
-      workInProgress = null;
-      return;
-    }
-  } catch (error) {
-    if (null !== returnFiber) throw ((workInProgress = returnFiber), error);
-    workInProgressRootExitStatus = 1;
-    workInProgressRootFatalError = thrownValue;
-    workInProgress = null;
-    return;
-  }
-  if (unitOfWork.flags & 32768)
-    a: {
-      root = unitOfWork;
-      do {
-        unitOfWork = unwindWork(root.alternate, root);
-        if (null !== unitOfWork) {
-          unitOfWork.flags &= 32767;
-          workInProgress = unitOfWork;
-          break a;
-        }
-        if (0 !== (root.mode & 2)) {
-          stopProfilerTimerIfRunningAndRecordDelta(root, !1);
-          unitOfWork = root.actualDuration;
-          for (thrownValue = root.child; null !== thrownValue; )
-            (unitOfWork += thrownValue.actualDuration),
-              (thrownValue = thrownValue.sibling);
-          root.actualDuration = unitOfWork;
-        }
-        root = root.return;
-        null !== root &&
-          ((root.flags |= 32768),
-          (root.subtreeFlags = 0),
-          (root.deletions = null));
-        workInProgress = root;
-      } while (null !== root);
-      workInProgressRootExitStatus = 6;
-      workInProgress = null;
+function recursivelyTraverseReconnectPassiveEffects(
+  finishedRoot$jscomp$0,
+  parentFiber
+) {
+  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+    var finishedRoot = finishedRoot$jscomp$0,
+      finishedWork = parentFiber;
+    switch (finishedWork.tag) {
+      case 0:
+      case 11:
+      case 15:
+        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork);
+        commitHookPassiveMountEffects(finishedWork, 8);
+        break;
+      case 23:
+        break;
+      case 22:
+        var instance = finishedWork.stateNode;
+        null !== finishedWork.memoizedState
+          ? instance._visibility & 4
+            ? recursivelyTraverseReconnectPassiveEffects(
+                finishedRoot,
+                finishedWork
+              )
+            : finishedWork.mode & 1 ||
+              ((instance._visibility |= 4),
+              recursivelyTraverseReconnectPassiveEffects(
+                finishedRoot,
+                finishedWork
+              ))
+          : ((instance._visibility |= 4),
+            recursivelyTraverseReconnectPassiveEffects(
+              finishedRoot,
+              finishedWork
+            ));
+        break;
+      case 24:
+        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork);
+        break;
+      default:
+        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork);
     }
-  else completeUnitOfWork(unitOfWork);
+    parentFiber = parentFiber.sibling;
+  }
 }
-function completeUnitOfWork(unitOfWork) {
-  var completedWork = unitOfWork;
-  do {
-    var current = completedWork.alternate;
-    unitOfWork = completedWork.return;
-    0 === (completedWork.mode & 2)
-      ? (current = completeWork(current, completedWork, entangledRenderLanes))
-      : (startProfilerTimer(completedWork),
-        (current = completeWork(current, completedWork, entangledRenderLanes)),
-        stopProfilerTimerIfRunningAndRecordDelta(completedWork, !1));
-    if (null !== current) {
-      workInProgress = current;
-      return;
-    }
-    completedWork = completedWork.sibling;
-    if (null !== completedWork) {
-      workInProgress = completedWork;
-      return;
-    }
-    workInProgress = completedWork = unitOfWork;
-  } while (null !== completedWork);
-  0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
+var suspenseyCommitFlag = 8192;
+function recursivelyAccumulateSuspenseyCommit(parentFiber) {
+  if (parentFiber.subtreeFlags & suspenseyCommitFlag)
+    for (parentFiber = parentFiber.child; null !== parentFiber; )
+      accumulateSuspenseyCommitOnFiber(parentFiber),
+        (parentFiber = parentFiber.sibling);
 }
-function commitRoot(root, recoverableErrors, transitions, spawnedLane) {
-  var previousUpdateLanePriority = currentUpdatePriority,
-    prevTransition = ReactCurrentBatchConfig.transition;
-  try {
-    (ReactCurrentBatchConfig.transition = null),
-      (currentUpdatePriority = 2),
-      commitRootImpl(
-        root,
-        recoverableErrors,
-        transitions,
-        previousUpdateLanePriority,
-        spawnedLane
-      );
-  } finally {
-    (ReactCurrentBatchConfig.transition = prevTransition),
-      (currentUpdatePriority = previousUpdateLanePriority);
+function accumulateSuspenseyCommitOnFiber(fiber) {
+  switch (fiber.tag) {
+    case 26:
+      recursivelyAccumulateSuspenseyCommit(fiber);
+      if (fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState)
+        throw Error(
+          "The current renderer does not support Resources. This error is likely caused by a bug in React. Please file an issue."
+        );
+      break;
+    case 5:
+      recursivelyAccumulateSuspenseyCommit(fiber);
+      break;
+    case 3:
+    case 4:
+      recursivelyAccumulateSuspenseyCommit(fiber);
+      break;
+    case 22:
+      if (null === fiber.memoizedState) {
+        var current = fiber.alternate;
+        null !== current && null !== current.memoizedState
+          ? ((current = suspenseyCommitFlag),
+            (suspenseyCommitFlag = 16777216),
+            recursivelyAccumulateSuspenseyCommit(fiber),
+            (suspenseyCommitFlag = current))
+          : recursivelyAccumulateSuspenseyCommit(fiber);
+      }
+      break;
+    default:
+      recursivelyAccumulateSuspenseyCommit(fiber);
   }
-  return null;
 }
-function commitRootImpl(
-  root,
-  recoverableErrors,
-  transitions,
-  renderPriorityLevel,
-  spawnedLane
+function detachAlternateSiblings(parentFiber) {
+  var previousFiber = parentFiber.alternate;
+  if (
+    null !== previousFiber &&
+    ((parentFiber = previousFiber.child), null !== parentFiber)
+  ) {
+    previousFiber.child = null;
+    do
+      (previousFiber = parentFiber.sibling),
+        (parentFiber.sibling = null),
+        (parentFiber = previousFiber);
+    while (null !== parentFiber);
+  }
+}
+function commitHookPassiveUnmountEffects(
+  finishedWork,
+  nearestMountedAncestor,
+  hookFlags
 ) {
-  do flushPassiveEffects();
-  while (null !== rootWithPendingPassiveEffects);
-  if (0 !== (executionContext & 6))
-    throw Error("Should not already be working.");
-  var finishedWork = root.finishedWork;
-  transitions = root.finishedLanes;
-  if (null === finishedWork) return null;
-  root.finishedWork = null;
-  root.finishedLanes = 0;
-  if (finishedWork === root.current)
-    throw Error(
-      "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
-    );
-  root.callbackNode = null;
-  root.callbackPriority = 0;
-  root.cancelPendingCommit = null;
-  var remainingLanes = finishedWork.lanes | finishedWork.childLanes;
-  remainingLanes |= concurrentlyUpdatedLanes;
-  markRootFinished(root, remainingLanes, spawnedLane);
-  root === workInProgressRoot &&
-    ((workInProgress = workInProgressRoot = null),
-    (workInProgressRootRenderLanes = 0));
-  (0 === (finishedWork.subtreeFlags & 10256) &&
-    0 === (finishedWork.flags & 10256)) ||
-    rootDoesHavePassiveEffects ||
-    ((rootDoesHavePassiveEffects = !0),
-    scheduleCallback(NormalPriority, function () {
-      flushPassiveEffects();
-      return null;
-    }));
-  spawnedLane = 0 !== (finishedWork.flags & 15990);
-  if (0 !== (finishedWork.subtreeFlags & 15990) || spawnedLane) {
-    spawnedLane = ReactCurrentBatchConfig.transition;
-    ReactCurrentBatchConfig.transition = null;
-    remainingLanes = currentUpdatePriority;
-    currentUpdatePriority = 2;
-    var prevExecutionContext = executionContext;
-    executionContext |= 4;
-    ReactCurrentOwner.current = null;
-    commitBeforeMutationEffects(root, finishedWork);
-    commitTime = now();
-    commitMutationEffects(root, finishedWork, transitions);
-    root.current = finishedWork;
-    commitLayoutEffects(finishedWork, root, transitions);
-    requestPaint();
-    executionContext = prevExecutionContext;
-    currentUpdatePriority = remainingLanes;
-    ReactCurrentBatchConfig.transition = spawnedLane;
-  } else (root.current = finishedWork), (commitTime = now());
-  rootDoesHavePassiveEffects &&
-    ((rootDoesHavePassiveEffects = !1),
-    (rootWithPendingPassiveEffects = root),
-    (pendingPassiveEffectsLanes = transitions));
-  remainingLanes = root.pendingLanes;
-  0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
-  onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
-  isDevToolsPresent && root.memoizedUpdaters.clear();
-  ensureRootIsScheduled(root);
-  if (null !== recoverableErrors)
-    for (
-      renderPriorityLevel = root.onRecoverableError, finishedWork = 0;
-      finishedWork < recoverableErrors.length;
-      finishedWork++
-    )
-      (spawnedLane = recoverableErrors[finishedWork]),
-        (remainingLanes = {
-          digest: spawnedLane.digest,
-          componentStack: spawnedLane.stack
-        }),
-        renderPriorityLevel(spawnedLane.value, remainingLanes);
-  if (hasUncaughtError)
-    throw (
-      ((hasUncaughtError = !1),
-      (root = firstUncaughtError),
-      (firstUncaughtError = null),
-      root)
-    );
-  0 !== (pendingPassiveEffectsLanes & 3) &&
-    0 !== root.tag &&
-    flushPassiveEffects();
-  remainingLanes = root.pendingLanes;
-  0 !== (transitions & 4194218) && 0 !== (remainingLanes & 42)
-    ? ((nestedUpdateScheduled = !0),
-      root === rootWithNestedUpdates
-        ? nestedUpdateCount++
-        : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root)))
-    : (nestedUpdateCount = 0);
-  flushSyncWorkAcrossRoots_impl(!1);
-  return null;
+  shouldProfile(finishedWork)
+    ? ((passiveEffectStartTime = now()),
+      commitHookEffectListUnmount(
+        hookFlags,
+        finishedWork,
+        nearestMountedAncestor
+      ),
+      recordPassiveEffectDuration(finishedWork))
+    : commitHookEffectListUnmount(
+        hookFlags,
+        finishedWork,
+        nearestMountedAncestor
+      );
 }
-function flushPassiveEffects() {
-  if (null !== rootWithPendingPassiveEffects) {
-    var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes),
-      prevTransition = ReactCurrentBatchConfig.transition,
-      previousPriority = currentUpdatePriority;
-    try {
-      ReactCurrentBatchConfig.transition = null;
-      currentUpdatePriority = 32 > renderPriority ? 32 : renderPriority;
-      if (null === rootWithPendingPassiveEffects)
-        var JSCompiler_inline_result = !1;
-      else {
-        renderPriority = rootWithPendingPassiveEffects;
-        rootWithPendingPassiveEffects = null;
-        pendingPassiveEffectsLanes = 0;
-        if (0 !== (executionContext & 6))
-          throw Error("Cannot flush passive effects while already rendering.");
-        var prevExecutionContext = executionContext;
-        executionContext |= 4;
-        commitPassiveUnmountOnFiber(renderPriority.current);
-        commitPassiveMountOnFiber(renderPriority, renderPriority.current);
-        var profilerEffects = pendingPassiveProfilerEffects;
-        pendingPassiveProfilerEffects = [];
-        for (var i = 0; i < profilerEffects.length; i++) {
-          var finishedWork = profilerEffects[i];
-          if (executionContext & 4 && 0 !== (finishedWork.flags & 4))
-            switch (finishedWork.tag) {
-              case 12:
-                var passiveEffectDuration =
-                    finishedWork.stateNode.passiveEffectDuration,
-                  _finishedWork$memoize = finishedWork.memoizedProps,
-                  id = _finishedWork$memoize.id,
-                  onPostCommit = _finishedWork$memoize.onPostCommit,
-                  commitTime$87 = commitTime,
-                  phase = null === finishedWork.alternate ? "mount" : "update";
-                currentUpdateIsNested && (phase = "nested-update");
-                "function" === typeof onPostCommit &&
-                  onPostCommit(id, phase, passiveEffectDuration, commitTime$87);
-                var parentFiber = finishedWork.return;
-                b: for (; null !== parentFiber; ) {
-                  switch (parentFiber.tag) {
-                    case 3:
-                      parentFiber.stateNode.passiveEffectDuration +=
-                        passiveEffectDuration;
-                      break b;
-                    case 12:
-                      parentFiber.stateNode.passiveEffectDuration +=
-                        passiveEffectDuration;
-                      break b;
-                  }
-                  parentFiber = parentFiber.return;
-                }
-            }
-        }
-        executionContext = prevExecutionContext;
-        flushSyncWorkAcrossRoots_impl(!1);
-        if (
-          injectedHook &&
-          "function" === typeof injectedHook.onPostCommitFiberRoot
-        )
-          try {
-            injectedHook.onPostCommitFiberRoot(rendererID, renderPriority);
-          } catch (err) {}
-        var stateNode = renderPriority.current.stateNode;
-        stateNode.effectDuration = 0;
-        stateNode.passiveEffectDuration = 0;
-        JSCompiler_inline_result = !0;
-      }
-      return JSCompiler_inline_result;
-    } finally {
-      (currentUpdatePriority = previousPriority),
-        (ReactCurrentBatchConfig.transition = prevTransition);
-    }
-  }
-  return !1;
-}
-function enqueuePendingPassiveProfilerEffect(fiber) {
-  pendingPassiveProfilerEffects.push(fiber);
-  rootDoesHavePassiveEffects ||
-    ((rootDoesHavePassiveEffects = !0),
-    scheduleCallback(NormalPriority, function () {
-      flushPassiveEffects();
-      return null;
-    }));
-}
-function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
-  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
-  sourceFiber = createRootErrorUpdate(rootFiber, sourceFiber, 2);
-  rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
-  null !== rootFiber &&
-    (markRootUpdated(rootFiber, 2), ensureRootIsScheduled(rootFiber));
-}
-function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
-  if (3 === sourceFiber.tag)
-    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
-  else
-    for (; null !== nearestMountedAncestor; ) {
-      if (3 === nearestMountedAncestor.tag) {
-        captureCommitPhaseErrorOnRoot(
-          nearestMountedAncestor,
-          sourceFiber,
-          error
+function recursivelyTraversePassiveUnmountEffects(parentFiber) {
+  var deletions = parentFiber.deletions;
+  if (0 !== (parentFiber.flags & 16)) {
+    if (null !== deletions)
+      for (var i = 0; i < deletions.length; i++) {
+        var childToDelete = deletions[i];
+        nextEffect = childToDelete;
+        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
+          childToDelete,
+          parentFiber
         );
-        break;
-      } else if (1 === nearestMountedAncestor.tag) {
-        var instance = nearestMountedAncestor.stateNode;
-        if (
-          "function" ===
-            typeof nearestMountedAncestor.type.getDerivedStateFromError ||
-          ("function" === typeof instance.componentDidCatch &&
-            (null === legacyErrorBoundariesThatAlreadyFailed ||
-              !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
-        ) {
-          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
-          sourceFiber = createClassErrorUpdate(
-            nearestMountedAncestor,
-            sourceFiber,
-            2
-          );
-          nearestMountedAncestor = enqueueUpdate(
-            nearestMountedAncestor,
-            sourceFiber,
-            2
-          );
-          null !== nearestMountedAncestor &&
-            (markRootUpdated(nearestMountedAncestor, 2),
-            ensureRootIsScheduled(nearestMountedAncestor));
-          break;
-        }
       }
-      nearestMountedAncestor = nearestMountedAncestor.return;
-    }
-}
-function attachPingListener(root, wakeable, lanes) {
-  var pingCache = root.pingCache;
-  if (null === pingCache) {
-    pingCache = root.pingCache = new PossiblyWeakMap();
-    var threadIDs = new Set();
-    pingCache.set(wakeable, threadIDs);
-  } else
-    (threadIDs = pingCache.get(wakeable)),
-      void 0 === threadIDs &&
-        ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs));
-  threadIDs.has(lanes) ||
-    ((workInProgressRootDidAttachPingListener = !0),
-    threadIDs.add(lanes),
-    (pingCache = pingSuspendedRoot.bind(null, root, wakeable, lanes)),
-    isDevToolsPresent && restorePendingUpdaters(root, lanes),
-    wakeable.then(pingCache, pingCache));
-}
-function pingSuspendedRoot(root, wakeable, pingedLanes) {
-  var pingCache = root.pingCache;
-  null !== pingCache && pingCache.delete(wakeable);
-  root.pingedLanes |= root.suspendedLanes & pingedLanes;
-  workInProgressRoot === root &&
-    (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&
-    (4 === workInProgressRootExitStatus ||
-    (3 === workInProgressRootExitStatus &&
-      (workInProgressRootRenderLanes & 62914560) ===
-        workInProgressRootRenderLanes &&
-      300 > now$1() - globalMostRecentFallbackTime)
-      ? 0 === (executionContext & 2) && prepareFreshStack(root, 0)
-      : (workInProgressRootPingedLanes |= pingedLanes));
-  ensureRootIsScheduled(root);
-}
-function retryTimedOutBoundary(boundaryFiber, retryLane) {
-  0 === retryLane &&
-    (retryLane = 0 === (boundaryFiber.mode & 1) ? 2 : claimNextRetryLane());
-  boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
-  null !== boundaryFiber &&
-    (markRootUpdated(boundaryFiber, retryLane),
-    ensureRootIsScheduled(boundaryFiber));
-}
-function retryDehydratedSuspenseBoundary(boundaryFiber) {
-  var suspenseState = boundaryFiber.memoizedState,
-    retryLane = 0;
-  null !== suspenseState && (retryLane = suspenseState.retryLane);
-  retryTimedOutBoundary(boundaryFiber, retryLane);
+    detachAlternateSiblings(parentFiber);
+  }
+  if (parentFiber.subtreeFlags & 10256)
+    for (parentFiber = parentFiber.child; null !== parentFiber; )
+      commitPassiveUnmountOnFiber(parentFiber),
+        (parentFiber = parentFiber.sibling);
 }
-function resolveRetryWakeable(boundaryFiber, wakeable) {
-  var retryLane = 0;
-  switch (boundaryFiber.tag) {
-    case 13:
-      var retryCache = boundaryFiber.stateNode;
-      var suspenseState = boundaryFiber.memoizedState;
-      null !== suspenseState && (retryLane = suspenseState.retryLane);
-      break;
-    case 19:
-      retryCache = boundaryFiber.stateNode;
+function commitPassiveUnmountOnFiber(finishedWork) {
+  switch (finishedWork.tag) {
+    case 0:
+    case 11:
+    case 15:
+      recursivelyTraversePassiveUnmountEffects(finishedWork);
+      finishedWork.flags & 2048 &&
+        commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, 9);
       break;
     case 22:
-      retryCache = boundaryFiber.stateNode._retryCache;
+      var instance = finishedWork.stateNode;
+      null !== finishedWork.memoizedState &&
+      instance._visibility & 4 &&
+      (null === finishedWork.return || 13 !== finishedWork.return.tag)
+        ? ((instance._visibility &= -5),
+          recursivelyTraverseDisconnectPassiveEffects(finishedWork))
+        : recursivelyTraversePassiveUnmountEffects(finishedWork);
       break;
     default:
-      throw Error(
-        "Pinged unknown suspense boundary type. This is probably a bug in React."
-      );
+      recursivelyTraversePassiveUnmountEffects(finishedWork);
   }
-  null !== retryCache && retryCache.delete(wakeable);
-  retryTimedOutBoundary(boundaryFiber, retryLane);
 }
-var beginWork;
-beginWork = function (current, workInProgress, renderLanes) {
-  if (null !== current)
-    if (
-      current.memoizedProps !== workInProgress.pendingProps ||
-      didPerformWorkStackCursor.current
-    )
-      didReceiveUpdate = !0;
-    else {
-      if (
-        0 === (current.lanes & renderLanes) &&
-        0 === (workInProgress.flags & 128)
-      )
-        return (
-          (didReceiveUpdate = !1),
-          attemptEarlyBailoutIfNoScheduledUpdate(
-            current,
-            workInProgress,
-            renderLanes
-          )
+function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
+  var deletions = parentFiber.deletions;
+  if (0 !== (parentFiber.flags & 16)) {
+    if (null !== deletions)
+      for (var i = 0; i < deletions.length; i++) {
+        var childToDelete = deletions[i];
+        nextEffect = childToDelete;
+        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
+          childToDelete,
+          parentFiber
         );
-      didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;
+      }
+    detachAlternateSiblings(parentFiber);
+  }
+  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+    deletions = parentFiber;
+    switch (deletions.tag) {
+      case 0:
+      case 11:
+      case 15:
+        commitHookPassiveUnmountEffects(deletions, deletions.return, 8);
+        recursivelyTraverseDisconnectPassiveEffects(deletions);
+        break;
+      case 22:
+        i = deletions.stateNode;
+        i._visibility & 4 &&
+          ((i._visibility &= -5),
+          recursivelyTraverseDisconnectPassiveEffects(deletions));
+        break;
+      default:
+        recursivelyTraverseDisconnectPassiveEffects(deletions);
     }
-  else didReceiveUpdate = !1;
-  workInProgress.lanes = 0;
-  switch (workInProgress.tag) {
-    case 2:
-      var Component = workInProgress.type;
-      resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress);
-      current = workInProgress.pendingProps;
-      var context = getMaskedContext(
-        workInProgress,
-        contextStackCursor$1.current
-      );
-      prepareToReadContext(workInProgress, renderLanes);
-      context = renderWithHooks(
-        null,
-        workInProgress,
-        Component,
-        current,
-        context,
-        renderLanes
-      );
-      workInProgress.flags |= 1;
-      if (
-        "object" === typeof context &&
-        null !== context &&
-        "function" === typeof context.render &&
-        void 0 === context.$$typeof
-      ) {
-        workInProgress.tag = 1;
-        workInProgress.memoizedState = null;
-        workInProgress.updateQueue = null;
-        if (isContextProvider(Component)) {
-          var hasContext = !0;
-          pushContextProvider(workInProgress);
-        } else hasContext = !1;
-        workInProgress.memoizedState =
-          null !== context.state && void 0 !== context.state
-            ? context.state
-            : null;
-        initializeUpdateQueue(workInProgress);
-        context.updater = classComponentUpdater;
-        workInProgress.stateNode = context;
-        context._reactInternals = workInProgress;
-        mountClassInstance(workInProgress, Component, current, renderLanes);
-        workInProgress = finishClassComponent(
-          null,
-          workInProgress,
-          Component,
-          !0,
-          hasContext,
-          renderLanes
-        );
-      } else
-        (workInProgress.tag = 0),
-          reconcileChildren(null, workInProgress, context, renderLanes),
-          (workInProgress = workInProgress.child);
-      return workInProgress;
-    case 16:
-      Component = workInProgress.elementType;
-      a: {
-        resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress);
-        current = workInProgress.pendingProps;
-        context = Component._init;
-        Component = context(Component._payload);
-        workInProgress.type = Component;
-        context = workInProgress.tag = resolveLazyComponentTag(Component);
-        current = resolveDefaultProps(Component, current);
-        switch (context) {
-          case 0:
-            workInProgress = updateFunctionComponent(
-              null,
-              workInProgress,
-              Component,
-              current,
-              renderLanes
-            );
-            break a;
-          case 1:
-            workInProgress = updateClassComponent(
-              null,
-              workInProgress,
-              Component,
-              current,
-              renderLanes
-            );
-            break a;
-          case 11:
-            workInProgress = updateForwardRef(
-              null,
-              workInProgress,
-              Component,
-              current,
-              renderLanes
-            );
-            break a;
-          case 14:
-            workInProgress = updateMemoComponent(
-              null,
-              workInProgress,
-              Component,
-              resolveDefaultProps(Component.type, current),
-              renderLanes
-            );
-            break a;
+    parentFiber = parentFiber.sibling;
+  }
+}
+function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
+  deletedSubtreeRoot,
+  nearestMountedAncestor
+) {
+  for (; null !== nextEffect; ) {
+    var fiber = nextEffect;
+    switch (fiber.tag) {
+      case 0:
+      case 11:
+      case 15:
+        commitHookPassiveUnmountEffects(fiber, nearestMountedAncestor, 8);
+    }
+    var child = fiber.child;
+    if (null !== child) (child.return = fiber), (nextEffect = child);
+    else
+      a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
+        child = nextEffect;
+        var sibling = child.sibling,
+          returnFiber = child.return;
+        detachFiberAfterEffects(child);
+        if (child === fiber) {
+          nextEffect = null;
+          break a;
         }
-        throw Error(
-          "Element type is invalid. Received a promise that resolves to: " +
-            Component +
-            ". Lazy element type must resolve to a class or function."
-        );
+        if (null !== sibling) {
+          sibling.return = returnFiber;
+          nextEffect = sibling;
+          break a;
+        }
+        nextEffect = returnFiber;
       }
-      return workInProgress;
-    case 0:
-      return (
-        (Component = workInProgress.type),
-        (context = workInProgress.pendingProps),
-        (context =
-          workInProgress.elementType === Component
-            ? context
-            : resolveDefaultProps(Component, context)),
-        updateFunctionComponent(
-          current,
-          workInProgress,
-          Component,
-          context,
-          renderLanes
-        )
-      );
-    case 1:
-      return (
-        (Component = workInProgress.type),
-        (context = workInProgress.pendingProps),
-        (context =
-          workInProgress.elementType === Component
-            ? context
-            : resolveDefaultProps(Component, context)),
-        updateClassComponent(
-          current,
-          workInProgress,
-          Component,
-          context,
-          renderLanes
-        )
-      );
-    case 3:
-      pushHostRootContext(workInProgress);
-      if (null === current)
-        throw Error("Should have a current fiber. This is a bug in React.");
-      context = workInProgress.pendingProps;
-      Component = workInProgress.memoizedState.element;
-      cloneUpdateQueue(current, workInProgress);
-      processUpdateQueue(workInProgress, context, null, renderLanes);
-      context = workInProgress.memoizedState.element;
-      context === Component
-        ? (workInProgress = bailoutOnAlreadyFinishedWork(
-            current,
-            workInProgress,
-            renderLanes
-          ))
-        : (reconcileChildren(current, workInProgress, context, renderLanes),
-          (workInProgress = workInProgress.child));
-      return workInProgress;
-    case 26:
-    case 27:
-    case 5:
-      return (
-        pushHostContext(workInProgress),
-        (Component = workInProgress.pendingProps.children),
-        markRef$1(current, workInProgress),
-        reconcileChildren(current, workInProgress, Component, renderLanes),
-        workInProgress.child
-      );
-    case 6:
-      return null;
-    case 13:
-      return updateSuspenseComponent(current, workInProgress, renderLanes);
-    case 4:
-      return (
-        pushHostContainer(
-          workInProgress,
-          workInProgress.stateNode.containerInfo
-        ),
-        (Component = workInProgress.pendingProps),
-        null === current
-          ? (workInProgress.child = reconcileChildFibers(
-              workInProgress,
-              null,
-              Component,
-              renderLanes
-            ))
-          : reconcileChildren(current, workInProgress, Component, renderLanes),
-        workInProgress.child
-      );
-    case 11:
-      return (
-        (Component = workInProgress.type),
-        (context = workInProgress.pendingProps),
-        (context =
-          workInProgress.elementType === Component
-            ? context
-            : resolveDefaultProps(Component, context)),
-        updateForwardRef(
-          current,
-          workInProgress,
-          Component,
-          context,
-          renderLanes
-        )
-      );
-    case 7:
-      return (
-        reconcileChildren(
-          current,
-          workInProgress,
-          workInProgress.pendingProps,
-          renderLanes
-        ),
-        workInProgress.child
-      );
-    case 8:
-      return (
-        reconcileChildren(
-          current,
-          workInProgress,
-          workInProgress.pendingProps.children,
-          renderLanes
-        ),
-        workInProgress.child
+  }
+}
+var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
+  ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher,
+  ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner,
+  ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig,
+  executionContext = 0,
+  workInProgressRoot = null,
+  workInProgress = null,
+  workInProgressRootRenderLanes = 0,
+  workInProgressSuspendedReason = 0,
+  workInProgressThrownValue = null,
+  workInProgressRootDidAttachPingListener = !1,
+  entangledRenderLanes = 0,
+  workInProgressRootExitStatus = 0,
+  workInProgressRootFatalError = null,
+  workInProgressRootSkippedLanes = 0,
+  workInProgressRootInterleavedUpdatedLanes = 0,
+  workInProgressRootPingedLanes = 0,
+  workInProgressDeferredLane = 0,
+  workInProgressRootConcurrentErrors = null,
+  workInProgressRootRecoverableErrors = null,
+  workInProgressRootDidIncludeRecursiveRenderUpdate = !1,
+  globalMostRecentFallbackTime = 0,
+  workInProgressRootRenderTargetTime = Infinity,
+  workInProgressTransitions = null,
+  hasUncaughtError = !1,
+  firstUncaughtError = null,
+  legacyErrorBoundariesThatAlreadyFailed = null,
+  rootDoesHavePassiveEffects = !1,
+  rootWithPendingPassiveEffects = null,
+  pendingPassiveEffectsLanes = 0,
+  pendingPassiveProfilerEffects = [],
+  nestedUpdateCount = 0,
+  rootWithNestedUpdates = null;
+function requestUpdateLane(fiber) {
+  if (0 === (fiber.mode & 1)) return 2;
+  if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)
+    return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
+  fiber = ReactCurrentBatchConfig$1.transition;
+  if (null !== fiber)
+    if (!fiber._callbacks) {
+      fiber._callbacks = new Set();
+    }
+    fiber._callbacks.add(handleAsyncAction);
+  }
+  if (null !== fiber)
+    return (
+      0 === currentEventTransitionLane &&
+        (currentEventTransitionLane = claimNextTransitionLane()),
+      currentEventTransitionLane
+    );
+  fiber = currentUpdatePriority;
+  if (0 === fiber)
+    a: {
+      fiber = fabricGetCurrentEventPriority
+        ? fabricGetCurrentEventPriority()
+        : null;
+      if (null != fiber)
+        switch (fiber) {
+          case FabricDiscretePriority:
+            fiber = 2;
+            break a;
+        }
+      fiber = 32;
+    }
+  return fiber;
+}
+function scheduleUpdateOnFiber(root, fiber, lane) {
+  if (
+    (root === workInProgressRoot && 2 === workInProgressSuspendedReason) ||
+    null !== root.cancelPendingCommit
+  )
+    prepareFreshStack(root, 0),
+      markRootSuspended(
+        root,
+        workInProgressRootRenderLanes,
+        workInProgressDeferredLane
       );
-    case 12:
+  markRootUpdated$1(root, lane);
+  if (0 === (executionContext & 2) || root !== workInProgressRoot)
+    isDevToolsPresent && addFiberToLanesMap(root, fiber, lane),
+      root === workInProgressRoot &&
+        (0 === (executionContext & 2) &&
+          (workInProgressRootInterleavedUpdatedLanes |= lane),
+        4 === workInProgressRootExitStatus &&
+          markRootSuspended(
+            root,
+            workInProgressRootRenderLanes,
+            workInProgressDeferredLane
+          )),
+      ensureRootIsScheduled(root),
+      2 === lane &&
+        0 === executionContext &&
+        0 === (fiber.mode & 1) &&
+        ((workInProgressRootRenderTargetTime = now$1() + 500),
+        flushSyncWorkAcrossRoots_impl(!0));
+}
+function performConcurrentWorkOnRoot(root, didTimeout) {
+  nestedUpdateScheduled = currentUpdateIsNested = !1;
+  if (0 !== (executionContext & 6))
+    throw Error("Should not already be working.");
+  var originalCallbackNode = root.callbackNode;
+  if (flushPassiveEffects() && root.callbackNode !== originalCallbackNode)
+    return null;
+  var lanes = getNextLanes(
+    root,
+    root === workInProgressRoot ? workInProgressRootRenderLanes : 0
+  );
+  if (0 === lanes) return null;
+  var exitStatus = (didTimeout =
+    0 === (lanes & 60) && 0 === (lanes & root.expiredLanes) && !didTimeout)
+    ? renderRootConcurrent(root, lanes)
+    : renderRootSync(root, lanes);
+  if (0 !== exitStatus) {
+    var renderWasConcurrent = didTimeout;
+    do {
+      if (6 === exitStatus) markRootSuspended(root, lanes, 0);
+      else {
+        didTimeout = root.current.alternate;
+        if (
+          renderWasConcurrent &&
+          !isRenderConsistentWithExternalStores(didTimeout)
+        ) {
+          exitStatus = renderRootSync(root, lanes);
+          renderWasConcurrent = !1;
+          continue;
+        }
+        if (2 === exitStatus) {
+          renderWasConcurrent = lanes;
+          var errorRetryLanes = getLanesToRetrySynchronouslyOnError(
+            root,
+            renderWasConcurrent
+          );
+          0 !== errorRetryLanes &&
+            ((lanes = errorRetryLanes),
+            (exitStatus = recoverFromConcurrentError(
+              root,
+              renderWasConcurrent,
+              errorRetryLanes
+            )));
+        }
+        if (1 === exitStatus)
+          throw (
+            ((originalCallbackNode = workInProgressRootFatalError),
+            prepareFreshStack(root, 0),
+            markRootSuspended(root, lanes, 0),
+            ensureRootIsScheduled(root),
+            originalCallbackNode)
+          );
+        root.finishedWork = didTimeout;
+        root.finishedLanes = lanes;
+        a: {
+          renderWasConcurrent = root;
+          switch (exitStatus) {
+            case 0:
+            case 1:
+              throw Error("Root did not complete. This is a bug in React.");
+            case 4:
+              if ((lanes & 4194176) === lanes) {
+                markRootSuspended(
+                  renderWasConcurrent,
+                  lanes,
+                  workInProgressDeferredLane
+                );
+                break a;
+              }
+              break;
+            case 2:
+            case 3:
+            case 5:
+              break;
+            default:
+              throw Error("Unknown root exit status.");
+          }
+          if (
+            (lanes & 62914560) === lanes &&
+            3 === exitStatus &&
+            ((exitStatus = globalMostRecentFallbackTime + 300 - now$1()),
+            10 < exitStatus)
+          ) {
+            markRootSuspended(
+              renderWasConcurrent,
+              lanes,
+              workInProgressDeferredLane
+            );
+            if (0 !== getNextLanes(renderWasConcurrent, 0)) break a;
+            renderWasConcurrent.timeoutHandle = scheduleTimeout(
+              commitRootWhenReady.bind(
+                null,
+                renderWasConcurrent,
+                didTimeout,
+                workInProgressRootRecoverableErrors,
+                workInProgressTransitions,
+                workInProgressRootDidIncludeRecursiveRenderUpdate,
+                lanes,
+                workInProgressDeferredLane
+              ),
+              exitStatus
+            );
+            break a;
+          }
+          commitRootWhenReady(
+            renderWasConcurrent,
+            didTimeout,
+            workInProgressRootRecoverableErrors,
+            workInProgressTransitions,
+            workInProgressRootDidIncludeRecursiveRenderUpdate,
+            lanes,
+            workInProgressDeferredLane
+          );
+        }
+      }
+      break;
+    } while (1);
+  }
+  ensureRootIsScheduled(root);
+  scheduleTaskForRootDuringMicrotask(root, now$1());
+  root =
+    root.callbackNode === originalCallbackNode
+      ? performConcurrentWorkOnRoot.bind(null, root)
+      : null;
+  return root;
+}
+function recoverFromConcurrentError(
+  root,
+  originallyAttemptedLanes,
+  errorRetryLanes
+) {
+  var errorsFromFirstAttempt = workInProgressRootConcurrentErrors,
+    JSCompiler_inline_result;
+  (JSCompiler_inline_result = root.current.memoizedState.isDehydrated) &&
+    (prepareFreshStack(root, errorRetryLanes).flags |= 256);
+  errorRetryLanes = renderRootSync(root, errorRetryLanes);
+  if (2 !== errorRetryLanes) {
+    if (workInProgressRootDidAttachPingListener && !JSCompiler_inline_result)
       return (
-        (workInProgress.flags |= 4),
-        (Component = workInProgress.stateNode),
-        (Component.effectDuration = 0),
-        (Component.passiveEffectDuration = 0),
-        reconcileChildren(
-          current,
-          workInProgress,
-          workInProgress.pendingProps.children,
-          renderLanes
-        ),
-        workInProgress.child
+        (root.errorRecoveryDisabledLanes |= originallyAttemptedLanes),
+        (workInProgressRootInterleavedUpdatedLanes |= originallyAttemptedLanes),
+        4
       );
-    case 10:
-      a: {
-        Component = workInProgress.type._context;
-        context = workInProgress.pendingProps;
-        hasContext = workInProgress.memoizedProps;
-        var newValue = context.value;
-        push(valueCursor, Component._currentValue2);
-        Component._currentValue2 = newValue;
-        if (null !== hasContext)
-          if (objectIs(hasContext.value, newValue)) {
-            if (
-              hasContext.children === context.children &&
-              !didPerformWorkStackCursor.current
-            ) {
-              workInProgress = bailoutOnAlreadyFinishedWork(
-                current,
-                workInProgress,
-                renderLanes
-              );
-              break a;
-            }
-          } else
-            for (
-              hasContext = workInProgress.child,
-                null !== hasContext && (hasContext.return = workInProgress);
-              null !== hasContext;
+    root = workInProgressRootRecoverableErrors;
+    workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
+    null !== root && queueRecoverableErrors(root);
+  }
+  return errorRetryLanes;
+}
+function queueRecoverableErrors(errors) {
+  null === workInProgressRootRecoverableErrors
+    ? (workInProgressRootRecoverableErrors = errors)
+    : workInProgressRootRecoverableErrors.push.apply(
+        workInProgressRootRecoverableErrors,
+        errors
+      );
+}
+function commitRootWhenReady(
+  root,
+  finishedWork,
+  recoverableErrors,
+  transitions,
+  didIncludeRenderPhaseUpdate,
+  lanes,
+  spawnedLane
+) {
+  0 === (lanes & 42) && accumulateSuspenseyCommitOnFiber(finishedWork);
+  commitRoot(
+    root,
+    recoverableErrors,
+    transitions,
+    didIncludeRenderPhaseUpdate,
+    spawnedLane
+  );
+}
+function isRenderConsistentWithExternalStores(finishedWork) {
+  for (var node = finishedWork; ; ) {
+    if (node.flags & 16384) {
+      var updateQueue = node.updateQueue;
+      if (
+        null !== updateQueue &&
+        ((updateQueue = updateQueue.stores), null !== updateQueue)
+      )
+        for (var i = 0; i < updateQueue.length; i++) {
+          var check = updateQueue[i],
+            getSnapshot = check.getSnapshot;
+          check = check.value;
+          try {
+            if (!objectIs(getSnapshot(), check)) return !1;
+          } catch (error) {
+            return !1;
+          }
+        }
+    }
+    updateQueue = node.child;
+    if (node.subtreeFlags & 16384 && null !== updateQueue)
+      (updateQueue.return = node), (node = updateQueue);
+    else {
+      if (node === finishedWork) break;
+      for (; null === node.sibling; ) {
+        if (null === node.return || node.return === finishedWork) return !0;
+        node = node.return;
+      }
+      node.sibling.return = node.return;
+      node = node.sibling;
+    }
+  }
+  return !0;
+}
+function markRootSuspended(root, suspendedLanes, spawnedLane) {
+  suspendedLanes &= ~workInProgressRootPingedLanes;
+  suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
+  root.suspendedLanes |= suspendedLanes;
+  root.pingedLanes &= ~suspendedLanes;
+  for (
+    var expirationTimes = root.expirationTimes, lanes = suspendedLanes;
+    0 < lanes;
 
-            ) {
-              var list = hasContext.dependencies;
-              if (null !== list) {
-                newValue = hasContext.child;
-                for (
-                  var dependency = list.firstContext;
-                  null !== dependency;
+  ) {
+    var index$4 = 31 - clz32(lanes),
+      lane = 1 << index$4;
+    expirationTimes[index$4] = -1;
+    lanes &= ~lane;
+  }
+  0 !== spawnedLane &&
+    markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
+}
+function resetWorkInProgressStack() {
+  if (null !== workInProgress) {
+    if (0 === workInProgressSuspendedReason)
+      var interruptedWork = workInProgress.return;
+    else
+      (interruptedWork = workInProgress),
+        resetContextDependencies(),
+        resetHooksOnUnwind(interruptedWork),
+        (thenableState$1 = null),
+        (thenableIndexCounter$1 = 0),
+        (interruptedWork = workInProgress);
+    for (; null !== interruptedWork; )
+      unwindInterruptedWork(interruptedWork.alternate, interruptedWork),
+        (interruptedWork = interruptedWork.return);
+    workInProgress = null;
+  }
+}
+function prepareFreshStack(root, lanes) {
+  root.finishedWork = null;
+  root.finishedLanes = 0;
+  var timeoutHandle = root.timeoutHandle;
+  -1 !== timeoutHandle &&
+    ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle));
+  timeoutHandle = root.cancelPendingCommit;
+  null !== timeoutHandle &&
+    ((root.cancelPendingCommit = null), timeoutHandle());
+  resetWorkInProgressStack();
+  workInProgressRoot = root;
+  workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
+  workInProgressRootRenderLanes = lanes;
+  workInProgressSuspendedReason = 0;
+  workInProgressThrownValue = null;
+  workInProgressRootDidAttachPingListener = !1;
+  workInProgressRootExitStatus = 0;
+  workInProgressRootFatalError = null;
+  workInProgressDeferredLane =
+    workInProgressRootPingedLanes =
+    workInProgressRootInterleavedUpdatedLanes =
+    workInProgressRootSkippedLanes =
+      0;
+  workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors =
+    null;
+  workInProgressRootDidIncludeRecursiveRenderUpdate = !1;
+  0 !== (lanes & 8) && (lanes |= lanes & 32);
+  var allEntangledLanes = root.entangledLanes;
+  if (0 !== allEntangledLanes)
+    for (
+      root = root.entanglements, allEntangledLanes &= lanes;
+      0 < allEntangledLanes;
 
-                ) {
-                  if (dependency.context === Component) {
-                    if (1 === hasContext.tag) {
-                      dependency = createUpdate(renderLanes & -renderLanes);
-                      dependency.tag = 2;
-                      var updateQueue = hasContext.updateQueue;
-                      if (null !== updateQueue) {
-                        updateQueue = updateQueue.shared;
-                        var pending = updateQueue.pending;
-                        null === pending
-                          ? (dependency.next = dependency)
-                          : ((dependency.next = pending.next),
-                            (pending.next = dependency));
-                        updateQueue.pending = dependency;
-                      }
-                    }
-                    hasContext.lanes |= renderLanes;
-                    dependency = hasContext.alternate;
-                    null !== dependency && (dependency.lanes |= renderLanes);
-                    scheduleContextWorkOnParentPath(
-                      hasContext.return,
-                      renderLanes,
-                      workInProgress
-                    );
-                    list.lanes |= renderLanes;
-                    break;
-                  }
-                  dependency = dependency.next;
-                }
-              } else if (10 === hasContext.tag)
-                newValue =
-                  hasContext.type === workInProgress.type
-                    ? null
-                    : hasContext.child;
-              else if (18 === hasContext.tag) {
-                newValue = hasContext.return;
-                if (null === newValue)
-                  throw Error(
-                    "We just came from a parent so we must have had a parent. This is a bug in React."
-                  );
-                newValue.lanes |= renderLanes;
-                list = newValue.alternate;
-                null !== list && (list.lanes |= renderLanes);
-                scheduleContextWorkOnParentPath(
-                  newValue,
-                  renderLanes,
-                  workInProgress
-                );
-                newValue = hasContext.sibling;
-              } else newValue = hasContext.child;
-              if (null !== newValue) newValue.return = hasContext;
-              else
-                for (newValue = hasContext; null !== newValue; ) {
-                  if (newValue === workInProgress) {
-                    newValue = null;
-                    break;
-                  }
-                  hasContext = newValue.sibling;
-                  if (null !== hasContext) {
-                    hasContext.return = newValue.return;
-                    newValue = hasContext;
-                    break;
+    ) {
+      var index$2 = 31 - clz32(allEntangledLanes),
+        lane = 1 << index$2;
+      lanes |= root[index$2];
+      allEntangledLanes &= ~lane;
+    }
+  entangledRenderLanes = lanes;
+  finishQueueingConcurrentUpdates();
+  return timeoutHandle;
+}
+function handleThrow(root, thrownValue) {
+  currentlyRenderingFiber$1 = null;
+  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
+  ReactCurrentOwner.current = null;
+  thrownValue === SuspenseException
+    ? ((thrownValue = getSuspendedThenable()),
+      (root = suspenseHandlerStackCursor.current),
+      (workInProgressSuspendedReason =
+        (null !== root &&
+          ((workInProgressRootRenderLanes & 4194176) ===
+          workInProgressRootRenderLanes
+            ? null !== shellBoundary
+            : ((workInProgressRootRenderLanes & 62914560) !==
+                workInProgressRootRenderLanes &&
+                0 === (workInProgressRootRenderLanes & 536870912)) ||
+              root !== shellBoundary)) ||
+        0 !== (workInProgressRootSkippedLanes & 134217727) ||
+        0 !== (workInProgressRootInterleavedUpdatedLanes & 134217727)
+          ? 3
+          : 2))
+    : thrownValue === SuspenseyCommitException
+    ? ((thrownValue = getSuspendedThenable()),
+      (workInProgressSuspendedReason = 4))
+    : (workInProgressSuspendedReason =
+        thrownValue === SelectiveHydrationException
+          ? 8
+          : null !== thrownValue &&
+            "object" === typeof thrownValue &&
+            "function" === typeof thrownValue.then
+          ? 6
+          : 1);
+  workInProgressThrownValue = thrownValue;
+  root = workInProgress;
+  null === root
+    ? ((workInProgressRootExitStatus = 1),
+      (workInProgressRootFatalError = thrownValue))
+    : root.mode & 2 && stopProfilerTimerIfRunningAndRecordDelta(root, !0);
+}
+function pushDispatcher() {
+  var prevDispatcher = ReactCurrentDispatcher.current;
+  ReactCurrentDispatcher.current = ContextOnlyDispatcher;
+  return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
+}
+function renderDidSuspendDelayIfPossible() {
+  workInProgressRootExitStatus = 4;
+  (0 === (workInProgressRootSkippedLanes & 134217727) &&
+    0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||
+    null === workInProgressRoot ||
+    markRootSuspended(
+      workInProgressRoot,
+      workInProgressRootRenderLanes,
+      workInProgressDeferredLane
+    );
+}
+function renderRootSync(root, lanes) {
+  var prevExecutionContext = executionContext;
+  executionContext |= 2;
+  var prevDispatcher = pushDispatcher();
+  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
+    if (isDevToolsPresent) {
+      var memoizedUpdaters = root.memoizedUpdaters;
+      0 < memoizedUpdaters.size &&
+        (restorePendingUpdaters(root, workInProgressRootRenderLanes),
+        memoizedUpdaters.clear());
+      movePendingFibersToMemoized(root, lanes);
+    }
+    workInProgressTransitions = null;
+    prepareFreshStack(root, lanes);
+  }
+  lanes = !1;
+  a: do
+    try {
+      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
+        memoizedUpdaters = workInProgress;
+        var thrownValue = workInProgressThrownValue;
+        switch (workInProgressSuspendedReason) {
+          case 8:
+            resetWorkInProgressStack();
+            workInProgressRootExitStatus = 6;
+            break a;
+          case 3:
+          case 2:
+            lanes ||
+              null !== suspenseHandlerStackCursor.current ||
+              (lanes = !0);
+          default:
+            (workInProgressSuspendedReason = 0),
+              (workInProgressThrownValue = null),
+              throwAndUnwindWorkLoop(root, memoizedUpdaters, thrownValue);
+        }
+      }
+      workLoopSync();
+      break;
+    } catch (thrownValue$103) {
+      handleThrow(root, thrownValue$103);
+    }
+  while (1);
+  lanes && root.shellSuspendCounter++;
+  resetContextDependencies();
+  executionContext = prevExecutionContext;
+  ReactCurrentDispatcher.current = prevDispatcher;
+  if (null !== workInProgress)
+    throw Error(
+      "Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue."
+    );
+  workInProgressRoot = null;
+  workInProgressRootRenderLanes = 0;
+  finishQueueingConcurrentUpdates();
+  return workInProgressRootExitStatus;
+}
+function workLoopSync() {
+  for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
+}
+function renderRootConcurrent(root, lanes) {
+  var prevExecutionContext = executionContext;
+  executionContext |= 2;
+  var prevDispatcher = pushDispatcher();
+  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
+    if (isDevToolsPresent) {
+      var memoizedUpdaters = root.memoizedUpdaters;
+      0 < memoizedUpdaters.size &&
+        (restorePendingUpdaters(root, workInProgressRootRenderLanes),
+        memoizedUpdaters.clear());
+      movePendingFibersToMemoized(root, lanes);
+    }
+    workInProgressTransitions = null;
+    workInProgressRootRenderTargetTime = now$1() + 500;
+    prepareFreshStack(root, lanes);
+  }
+  a: do
+    try {
+      if (0 !== workInProgressSuspendedReason && null !== workInProgress)
+        b: switch (
+          ((lanes = workInProgress),
+          (memoizedUpdaters = workInProgressThrownValue),
+          workInProgressSuspendedReason)
+        ) {
+          case 1:
+            workInProgressSuspendedReason = 0;
+            workInProgressThrownValue = null;
+            throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters);
+            break;
+          case 2:
+            if (isThenableResolved(memoizedUpdaters)) {
+              workInProgressSuspendedReason = 0;
+              workInProgressThrownValue = null;
+              replaySuspendedUnitOfWork(lanes);
+              break;
+            }
+            lanes = function () {
+              2 === workInProgressSuspendedReason &&
+                workInProgressRoot === root &&
+                (workInProgressSuspendedReason = 7);
+              ensureRootIsScheduled(root);
+            };
+            memoizedUpdaters.then(lanes, lanes);
+            break a;
+          case 3:
+            workInProgressSuspendedReason = 7;
+            break a;
+          case 4:
+            workInProgressSuspendedReason = 5;
+            break a;
+          case 7:
+            isThenableResolved(memoizedUpdaters)
+              ? ((workInProgressSuspendedReason = 0),
+                (workInProgressThrownValue = null),
+                replaySuspendedUnitOfWork(lanes))
+              : ((workInProgressSuspendedReason = 0),
+                (workInProgressThrownValue = null),
+                throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters));
+            break;
+          case 5:
+            switch (workInProgress.tag) {
+              case 5:
+              case 26:
+              case 27:
+                lanes = workInProgress;
+                workInProgressSuspendedReason = 0;
+                workInProgressThrownValue = null;
+                var sibling = lanes.sibling;
+                if (null !== sibling) workInProgress = sibling;
+                else {
+                  var returnFiber = lanes.return;
+                  null !== returnFiber
+                    ? ((workInProgress = returnFiber),
+                      completeUnitOfWork(returnFiber))
+                    : (workInProgress = null);
+                }
+                break b;
+            }
+            workInProgressSuspendedReason = 0;
+            workInProgressThrownValue = null;
+            throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters);
+            break;
+          case 6:
+            workInProgressSuspendedReason = 0;
+            workInProgressThrownValue = null;
+            throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters);
+            break;
+          case 8:
+            resetWorkInProgressStack();
+            workInProgressRootExitStatus = 6;
+            break a;
+          default:
+            throw Error("Unexpected SuspendedReason. This is a bug in React.");
+        }
+      workLoopConcurrent();
+      break;
+    } catch (thrownValue$105) {
+      handleThrow(root, thrownValue$105);
+    }
+  while (1);
+  resetContextDependencies();
+  ReactCurrentDispatcher.current = prevDispatcher;
+  executionContext = prevExecutionContext;
+  if (null !== workInProgress) return 0;
+  workInProgressRoot = null;
+  workInProgressRootRenderLanes = 0;
+  finishQueueingConcurrentUpdates();
+  return workInProgressRootExitStatus;
+}
+function workLoopConcurrent() {
+  for (; null !== workInProgress && !shouldYield(); )
+    performUnitOfWork(workInProgress);
+}
+function performUnitOfWork(unitOfWork) {
+  var current = unitOfWork.alternate;
+  0 !== (unitOfWork.mode & 2)
+    ? (startProfilerTimer(unitOfWork),
+      (current = beginWork(current, unitOfWork, entangledRenderLanes)),
+      stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, !0))
+    : (current = beginWork(current, unitOfWork, entangledRenderLanes));
+  unitOfWork.memoizedProps = unitOfWork.pendingProps;
+  null === current
+    ? completeUnitOfWork(unitOfWork)
+    : (workInProgress = current);
+  ReactCurrentOwner.current = null;
+}
+function replaySuspendedUnitOfWork(unitOfWork) {
+  var current = unitOfWork.alternate,
+    isProfilingMode = 0 !== (unitOfWork.mode & 2);
+  isProfilingMode && startProfilerTimer(unitOfWork);
+  switch (unitOfWork.tag) {
+    case 2:
+      unitOfWork.tag = 0;
+    case 15:
+    case 0:
+      var Component = unitOfWork.type,
+        unresolvedProps = unitOfWork.pendingProps;
+      unresolvedProps =
+        unitOfWork.elementType === Component
+          ? unresolvedProps
+          : resolveDefaultProps(Component, unresolvedProps);
+      current = replayFunctionComponent(
+        current,
+        unitOfWork,
+        unresolvedProps,
+        Component,
+        void 0,
+        workInProgressRootRenderLanes
+      );
+      break;
+    case 11:
+      Component = unitOfWork.type.render;
+      unresolvedProps = unitOfWork.pendingProps;
+      unresolvedProps =
+        unitOfWork.elementType === Component
+          ? unresolvedProps
+          : resolveDefaultProps(Component, unresolvedProps);
+      current = replayFunctionComponent(
+        current,
+        unitOfWork,
+        unresolvedProps,
+        Component,
+        unitOfWork.ref,
+        workInProgressRootRenderLanes
+      );
+      break;
+    case 5:
+      resetHooksOnUnwind(unitOfWork);
+    default:
+      unwindInterruptedWork(current, unitOfWork),
+        (unitOfWork = workInProgress =
+          resetWorkInProgress(unitOfWork, entangledRenderLanes)),
+        (current = beginWork(current, unitOfWork, entangledRenderLanes));
+  }
+  isProfilingMode && stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, !0);
+  unitOfWork.memoizedProps = unitOfWork.pendingProps;
+  null === current
+    ? completeUnitOfWork(unitOfWork)
+    : (workInProgress = current);
+  ReactCurrentOwner.current = null;
+}
+function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue) {
+  resetContextDependencies();
+  resetHooksOnUnwind(unitOfWork);
+  thenableState$1 = null;
+  thenableIndexCounter$1 = 0;
+  var returnFiber = unitOfWork.return;
+  try {
+    if (
+      throwException(
+        root,
+        returnFiber,
+        unitOfWork,
+        thrownValue,
+        workInProgressRootRenderLanes
+      )
+    ) {
+      workInProgressRootExitStatus = 1;
+      workInProgressRootFatalError = thrownValue;
+      workInProgress = null;
+      return;
+    }
+  } catch (error) {
+    if (null !== returnFiber) throw ((workInProgress = returnFiber), error);
+    workInProgressRootExitStatus = 1;
+    workInProgressRootFatalError = thrownValue;
+    workInProgress = null;
+    return;
+  }
+  if (unitOfWork.flags & 32768)
+    a: {
+      root = unitOfWork;
+      do {
+        unitOfWork = unwindWork(root.alternate, root);
+        if (null !== unitOfWork) {
+          unitOfWork.flags &= 32767;
+          workInProgress = unitOfWork;
+          break a;
+        }
+        if (0 !== (root.mode & 2)) {
+          stopProfilerTimerIfRunningAndRecordDelta(root, !1);
+          unitOfWork = root.actualDuration;
+          for (thrownValue = root.child; null !== thrownValue; )
+            (unitOfWork += thrownValue.actualDuration),
+              (thrownValue = thrownValue.sibling);
+          root.actualDuration = unitOfWork;
+        }
+        root = root.return;
+        null !== root &&
+          ((root.flags |= 32768),
+          (root.subtreeFlags = 0),
+          (root.deletions = null));
+        workInProgress = root;
+      } while (null !== root);
+      workInProgressRootExitStatus = 6;
+      workInProgress = null;
+    }
+  else completeUnitOfWork(unitOfWork);
+}
+function completeUnitOfWork(unitOfWork) {
+  var completedWork = unitOfWork;
+  do {
+    var current = completedWork.alternate;
+    unitOfWork = completedWork.return;
+    0 === (completedWork.mode & 2)
+      ? (current = completeWork(current, completedWork, entangledRenderLanes))
+      : (startProfilerTimer(completedWork),
+        (current = completeWork(current, completedWork, entangledRenderLanes)),
+        stopProfilerTimerIfRunningAndRecordDelta(completedWork, !1));
+    if (null !== current) {
+      workInProgress = current;
+      return;
+    }
+    completedWork = completedWork.sibling;
+    if (null !== completedWork) {
+      workInProgress = completedWork;
+      return;
+    }
+    workInProgress = completedWork = unitOfWork;
+  } while (null !== completedWork);
+  0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
+}
+function commitRoot(
+  root,
+  recoverableErrors,
+  transitions,
+  didIncludeRenderPhaseUpdate,
+  spawnedLane
+) {
+  var previousUpdateLanePriority = currentUpdatePriority,
+    prevTransition = ReactCurrentBatchConfig.transition;
+  try {
+    (ReactCurrentBatchConfig.transition = null),
+      (currentUpdatePriority = 2),
+      commitRootImpl(
+        root,
+        recoverableErrors,
+        transitions,
+        didIncludeRenderPhaseUpdate,
+        previousUpdateLanePriority,
+        spawnedLane
+      );
+  } finally {
+    (ReactCurrentBatchConfig.transition = prevTransition),
+      (currentUpdatePriority = previousUpdateLanePriority);
+  }
+  return null;
+}
+function commitRootImpl(
+  root,
+  recoverableErrors,
+  transitions,
+  didIncludeRenderPhaseUpdate,
+  renderPriorityLevel,
+  spawnedLane
+) {
+  do flushPassiveEffects();
+  while (null !== rootWithPendingPassiveEffects);
+  if (0 !== (executionContext & 6))
+    throw Error("Should not already be working.");
+  didIncludeRenderPhaseUpdate = root.finishedWork;
+  transitions = root.finishedLanes;
+  if (null === didIncludeRenderPhaseUpdate) return null;
+  root.finishedWork = null;
+  root.finishedLanes = 0;
+  if (didIncludeRenderPhaseUpdate === root.current)
+    throw Error(
+      "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
+    );
+  root.callbackNode = null;
+  root.callbackPriority = 0;
+  root.cancelPendingCommit = null;
+  var remainingLanes =
+    didIncludeRenderPhaseUpdate.lanes | didIncludeRenderPhaseUpdate.childLanes;
+  remainingLanes |= concurrentlyUpdatedLanes;
+  markRootFinished(root, remainingLanes, spawnedLane);
+  root === workInProgressRoot &&
+    ((workInProgress = workInProgressRoot = null),
+    (workInProgressRootRenderLanes = 0));
+  (0 === (didIncludeRenderPhaseUpdate.subtreeFlags & 10256) &&
+    0 === (didIncludeRenderPhaseUpdate.flags & 10256)) ||
+    rootDoesHavePassiveEffects ||
+    ((rootDoesHavePassiveEffects = !0),
+    scheduleCallback(NormalPriority, function () {
+      flushPassiveEffects();
+      return null;
+    }));
+  spawnedLane = 0 !== (didIncludeRenderPhaseUpdate.flags & 15990);
+  if (0 !== (didIncludeRenderPhaseUpdate.subtreeFlags & 15990) || spawnedLane) {
+    spawnedLane = ReactCurrentBatchConfig.transition;
+    ReactCurrentBatchConfig.transition = null;
+    remainingLanes = currentUpdatePriority;
+    currentUpdatePriority = 2;
+    var prevExecutionContext = executionContext;
+    executionContext |= 4;
+    ReactCurrentOwner.current = null;
+    commitBeforeMutationEffects(root, didIncludeRenderPhaseUpdate);
+    commitTime = now();
+    commitMutationEffects(root, didIncludeRenderPhaseUpdate, transitions);
+    root.current = didIncludeRenderPhaseUpdate;
+    commitLayoutEffects(didIncludeRenderPhaseUpdate, root, transitions);
+    requestPaint();
+    executionContext = prevExecutionContext;
+    currentUpdatePriority = remainingLanes;
+    ReactCurrentBatchConfig.transition = spawnedLane;
+  } else (root.current = didIncludeRenderPhaseUpdate), (commitTime = now());
+  rootDoesHavePassiveEffects &&
+    ((rootDoesHavePassiveEffects = !1),
+    (rootWithPendingPassiveEffects = root),
+    (pendingPassiveEffectsLanes = transitions));
+  remainingLanes = root.pendingLanes;
+  0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
+  onCommitRoot(didIncludeRenderPhaseUpdate.stateNode, renderPriorityLevel);
+  isDevToolsPresent && root.memoizedUpdaters.clear();
+  ensureRootIsScheduled(root);
+  if (null !== recoverableErrors)
+    for (
+      renderPriorityLevel = root.onRecoverableError,
+        didIncludeRenderPhaseUpdate = 0;
+      didIncludeRenderPhaseUpdate < recoverableErrors.length;
+      didIncludeRenderPhaseUpdate++
+    )
+      (spawnedLane = recoverableErrors[didIncludeRenderPhaseUpdate]),
+        (remainingLanes = {
+          digest: spawnedLane.digest,
+          componentStack: spawnedLane.stack
+        }),
+        renderPriorityLevel(spawnedLane.value, remainingLanes);
+  if (hasUncaughtError)
+    throw (
+      ((hasUncaughtError = !1),
+      (root = firstUncaughtError),
+      (firstUncaughtError = null),
+      root)
+    );
+  0 !== (pendingPassiveEffectsLanes & 3) &&
+    0 !== root.tag &&
+    flushPassiveEffects();
+  remainingLanes = root.pendingLanes;
+  0 !== (transitions & 4194218) && 0 !== (remainingLanes & 42)
+    ? ((nestedUpdateScheduled = !0),
+      root === rootWithNestedUpdates
+        ? nestedUpdateCount++
+        : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root)))
+    : (nestedUpdateCount = 0);
+  flushSyncWorkAcrossRoots_impl(!1);
+  return null;
+}
+function flushPassiveEffects() {
+  if (null !== rootWithPendingPassiveEffects) {
+    var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes),
+      prevTransition = ReactCurrentBatchConfig.transition,
+      previousPriority = currentUpdatePriority;
+    try {
+      ReactCurrentBatchConfig.transition = null;
+      currentUpdatePriority = 32 > renderPriority ? 32 : renderPriority;
+      if (null === rootWithPendingPassiveEffects)
+        var JSCompiler_inline_result = !1;
+      else {
+        renderPriority = rootWithPendingPassiveEffects;
+        rootWithPendingPassiveEffects = null;
+        pendingPassiveEffectsLanes = 0;
+        if (0 !== (executionContext & 6))
+          throw Error("Cannot flush passive effects while already rendering.");
+        var prevExecutionContext = executionContext;
+        executionContext |= 4;
+        commitPassiveUnmountOnFiber(renderPriority.current);
+        commitPassiveMountOnFiber(renderPriority, renderPriority.current);
+        var profilerEffects = pendingPassiveProfilerEffects;
+        pendingPassiveProfilerEffects = [];
+        for (var i = 0; i < profilerEffects.length; i++) {
+          var finishedWork = profilerEffects[i];
+          if (executionContext & 4 && 0 !== (finishedWork.flags & 4))
+            switch (finishedWork.tag) {
+              case 12:
+                var passiveEffectDuration =
+                    finishedWork.stateNode.passiveEffectDuration,
+                  _finishedWork$memoize = finishedWork.memoizedProps,
+                  id = _finishedWork$memoize.id,
+                  onPostCommit = _finishedWork$memoize.onPostCommit,
+                  commitTime$86 = commitTime,
+                  phase = null === finishedWork.alternate ? "mount" : "update";
+                currentUpdateIsNested && (phase = "nested-update");
+                "function" === typeof onPostCommit &&
+                  onPostCommit(id, phase, passiveEffectDuration, commitTime$86);
+                var parentFiber = finishedWork.return;
+                b: for (; null !== parentFiber; ) {
+                  switch (parentFiber.tag) {
+                    case 3:
+                      parentFiber.stateNode.passiveEffectDuration +=
+                        passiveEffectDuration;
+                      break b;
+                    case 12:
+                      parentFiber.stateNode.passiveEffectDuration +=
+                        passiveEffectDuration;
+                      break b;
                   }
-                  newValue = newValue.return;
+                  parentFiber = parentFiber.return;
                 }
-              hasContext = newValue;
             }
-        reconcileChildren(
-          current,
-          workInProgress,
-          context.children,
-          renderLanes
+        }
+        executionContext = prevExecutionContext;
+        flushSyncWorkAcrossRoots_impl(!1);
+        if (
+          injectedHook &&
+          "function" === typeof injectedHook.onPostCommitFiberRoot
+        )
+          try {
+            injectedHook.onPostCommitFiberRoot(rendererID, renderPriority);
+          } catch (err) {}
+        var stateNode = renderPriority.current.stateNode;
+        stateNode.effectDuration = 0;
+        stateNode.passiveEffectDuration = 0;
+        JSCompiler_inline_result = !0;
+      }
+      return JSCompiler_inline_result;
+    } finally {
+      (currentUpdatePriority = previousPriority),
+        (ReactCurrentBatchConfig.transition = prevTransition);
+    }
+  }
+  return !1;
+}
+function enqueuePendingPassiveProfilerEffect(fiber) {
+  pendingPassiveProfilerEffects.push(fiber);
+  rootDoesHavePassiveEffects ||
+    ((rootDoesHavePassiveEffects = !0),
+    scheduleCallback(NormalPriority, function () {
+      flushPassiveEffects();
+      return null;
+    }));
+}
+function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
+  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
+  sourceFiber = createRootErrorUpdate(rootFiber, sourceFiber, 2);
+  rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
+  null !== rootFiber &&
+    (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
+}
+function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
+  if (3 === sourceFiber.tag)
+    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
+  else
+    for (; null !== nearestMountedAncestor; ) {
+      if (3 === nearestMountedAncestor.tag) {
+        captureCommitPhaseErrorOnRoot(
+          nearestMountedAncestor,
+          sourceFiber,
+          error
         );
-        workInProgress = workInProgress.child;
+        break;
+      } else if (1 === nearestMountedAncestor.tag) {
+        var instance = nearestMountedAncestor.stateNode;
+        if (
+          "function" ===
+            typeof nearestMountedAncestor.type.getDerivedStateFromError ||
+          ("function" === typeof instance.componentDidCatch &&
+            (null === legacyErrorBoundariesThatAlreadyFailed ||
+              !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
+        ) {
+          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
+          sourceFiber = createClassErrorUpdate(
+            nearestMountedAncestor,
+            sourceFiber,
+            2
+          );
+          nearestMountedAncestor = enqueueUpdate(
+            nearestMountedAncestor,
+            sourceFiber,
+            2
+          );
+          null !== nearestMountedAncestor &&
+            (markRootUpdated$1(nearestMountedAncestor, 2),
+            ensureRootIsScheduled(nearestMountedAncestor));
+          break;
+        }
       }
-      return workInProgress;
-    case 9:
-      return (
-        (context = workInProgress.type),
-        (Component = workInProgress.pendingProps.children),
-        prepareToReadContext(workInProgress, renderLanes),
-        (context = readContext(context)),
-        (Component = Component(context)),
-        (workInProgress.flags |= 1),
-        reconcileChildren(current, workInProgress, Component, renderLanes),
-        workInProgress.child
-      );
-    case 14:
-      return (
-        (Component = workInProgress.type),
-        (context = resolveDefaultProps(Component, workInProgress.pendingProps)),
-        (context = resolveDefaultProps(Component.type, context)),
-        updateMemoComponent(
-          current,
-          workInProgress,
-          Component,
-          context,
-          renderLanes
-        )
-      );
-    case 15:
-      return updateSimpleMemoComponent(
-        current,
-        workInProgress,
-        workInProgress.type,
-        workInProgress.pendingProps,
-        renderLanes
-      );
-    case 17:
-      return (
-        (Component = workInProgress.type),
-        (context = workInProgress.pendingProps),
-        (context =
-          workInProgress.elementType === Component
-            ? context
-            : resolveDefaultProps(Component, context)),
-        resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress),
-        (workInProgress.tag = 1),
-        isContextProvider(Component)
-          ? ((current = !0), pushContextProvider(workInProgress))
-          : (current = !1),
-        prepareToReadContext(workInProgress, renderLanes),
-        constructClassInstance(workInProgress, Component, context),
-        mountClassInstance(workInProgress, Component, context, renderLanes),
-        finishClassComponent(
-          null,
-          workInProgress,
-          Component,
-          !0,
-          current,
-          renderLanes
-        )
-      );
+      nearestMountedAncestor = nearestMountedAncestor.return;
+    }
+}
+function attachPingListener(root, wakeable, lanes) {
+  var pingCache = root.pingCache;
+  if (null === pingCache) {
+    pingCache = root.pingCache = new PossiblyWeakMap();
+    var threadIDs = new Set();
+    pingCache.set(wakeable, threadIDs);
+  } else
+    (threadIDs = pingCache.get(wakeable)),
+      void 0 === threadIDs &&
+        ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs));
+  threadIDs.has(lanes) ||
+    ((workInProgressRootDidAttachPingListener = !0),
+    threadIDs.add(lanes),
+    (pingCache = pingSuspendedRoot.bind(null, root, wakeable, lanes)),
+    isDevToolsPresent && restorePendingUpdaters(root, lanes),
+    wakeable.then(pingCache, pingCache));
+}
+function pingSuspendedRoot(root, wakeable, pingedLanes) {
+  var pingCache = root.pingCache;
+  null !== pingCache && pingCache.delete(wakeable);
+  root.pingedLanes |= root.suspendedLanes & pingedLanes;
+  workInProgressRoot === root &&
+    (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&
+    (4 === workInProgressRootExitStatus ||
+    (3 === workInProgressRootExitStatus &&
+      (workInProgressRootRenderLanes & 62914560) ===
+        workInProgressRootRenderLanes &&
+      300 > now$1() - globalMostRecentFallbackTime)
+      ? 0 === (executionContext & 2) && prepareFreshStack(root, 0)
+      : (workInProgressRootPingedLanes |= pingedLanes));
+  ensureRootIsScheduled(root);
+}
+function retryTimedOutBoundary(boundaryFiber, retryLane) {
+  0 === retryLane &&
+    (retryLane = 0 === (boundaryFiber.mode & 1) ? 2 : claimNextRetryLane());
+  boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
+  null !== boundaryFiber &&
+    (markRootUpdated$1(boundaryFiber, retryLane),
+    ensureRootIsScheduled(boundaryFiber));
+}
+function retryDehydratedSuspenseBoundary(boundaryFiber) {
+  var suspenseState = boundaryFiber.memoizedState,
+    retryLane = 0;
+  null !== suspenseState && (retryLane = suspenseState.retryLane);
+  retryTimedOutBoundary(boundaryFiber, retryLane);
+}
+function resolveRetryWakeable(boundaryFiber, wakeable) {
+  var retryLane = 0;
+  switch (boundaryFiber.tag) {
+    case 13:
+      var retryCache = boundaryFiber.stateNode;
+      var suspenseState = boundaryFiber.memoizedState;
+      null !== suspenseState && (retryLane = suspenseState.retryLane);
+      break;
     case 19:
-      return updateSuspenseListComponent(current, workInProgress, renderLanes);
+      retryCache = boundaryFiber.stateNode;
+      break;
     case 22:
-      return updateOffscreenComponent(current, workInProgress, renderLanes);
+      retryCache = boundaryFiber.stateNode._retryCache;
+      break;
+    default:
+      throw Error(
+        "Pinged unknown suspense boundary type. This is probably a bug in React."
+      );
   }
-  throw Error(
-    "Unknown unit of work tag (" +
-      workInProgress.tag +
-      "). This error is likely caused by a bug in React. Please file an issue."
-  );
-};
+  null !== retryCache && retryCache.delete(wakeable);
+  retryTimedOutBoundary(boundaryFiber, retryLane);
+}
 function restorePendingUpdaters(root, lanes) {
   isDevToolsPresent &&
     root.memoizedUpdaters.forEach(function (schedulingFiber) {
@@ -9551,6 +9245,7 @@ function createFiberFromTypeAndProps(
             case REACT_CONTEXT_TYPE:
               fiberTag = 9;
               break a;
+            case REACT_CONSUMER_TYPE:
             case REACT_FORWARD_REF_TYPE:
               fiberTag = 11;
               break a;
@@ -9708,63 +9403,19 @@ function findHostInstance(component) {
   return null === component ? null : getPublicInstance(component.stateNode);
 }
 function updateContainer(element, container, parentComponent, callback) {
-  var current = container.current,
-    lane = requestUpdateLane(current);
-  a: if (parentComponent) {
-    parentComponent = parentComponent._reactInternals;
-    b: {
-      if (
-        getNearestMountedFiber(parentComponent) !== parentComponent ||
-        1 !== parentComponent.tag
-      )
-        throw Error(
-          "Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue."
-        );
-      var JSCompiler_inline_result = parentComponent;
-      do {
-        switch (JSCompiler_inline_result.tag) {
-          case 3:
-            JSCompiler_inline_result =
-              JSCompiler_inline_result.stateNode.context;
-            break b;
-          case 1:
-            if (isContextProvider(JSCompiler_inline_result.type)) {
-              JSCompiler_inline_result =
-                JSCompiler_inline_result.stateNode
-                  .__reactInternalMemoizedMergedChildContext;
-              break b;
-            }
-        }
-        JSCompiler_inline_result = JSCompiler_inline_result.return;
-      } while (null !== JSCompiler_inline_result);
-      throw Error(
-        "Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue."
-      );
-    }
-    if (1 === parentComponent.tag) {
-      var Component = parentComponent.type;
-      if (isContextProvider(Component)) {
-        parentComponent = processChildContext(
-          parentComponent,
-          Component,
-          JSCompiler_inline_result
-        );
-        break a;
-      }
-    }
-    parentComponent = JSCompiler_inline_result;
-  } else parentComponent = emptyContextObject;
+  parentComponent = container.current;
+  var lane = requestUpdateLane(parentComponent);
   null === container.context
-    ? (container.context = parentComponent)
-    : (container.pendingContext = parentComponent);
+    ? (container.context = emptyContextObject)
+    : (container.pendingContext = emptyContextObject);
   container = createUpdate(lane);
   container.payload = { element: element };
   callback = void 0 === callback ? null : callback;
   null !== callback && (container.callback = callback);
-  element = enqueueUpdate(current, container, lane);
+  element = enqueueUpdate(parentComponent, container, lane);
   null !== element &&
-    (scheduleUpdateOnFiber(element, current, lane),
-    entangleTransitions(element, current, lane));
+    (scheduleUpdateOnFiber(element, parentComponent, lane),
+    entangleTransitions(element, parentComponent, lane));
   return lane;
 }
 function emptyFindFiberByHostInstance() {
@@ -9812,10 +9463,10 @@ batchedUpdatesImpl = function (fn, a) {
   }
 };
 var roots = new Map(),
-  devToolsConfig$jscomp$inline_1114 = {
+  devToolsConfig$jscomp$inline_1090 = {
     findFiberByHostInstance: getInstanceFromNode,
     bundleType: 0,
-    version: "18.3.0-canary-c1b45781",
+    version: "18.3.0-canary-f2de0db5",
     rendererPackageName: "react-native-renderer",
     rendererConfig: {
       getInspectorDataForInstance: getInspectorDataForInstance,
@@ -9831,11 +9482,11 @@ var roots = new Map(),
       }.bind(null, findNodeHandle)
     }
   };
-var internals$jscomp$inline_1333 = {
-  bundleType: devToolsConfig$jscomp$inline_1114.bundleType,
-  version: devToolsConfig$jscomp$inline_1114.version,
-  rendererPackageName: devToolsConfig$jscomp$inline_1114.rendererPackageName,
-  rendererConfig: devToolsConfig$jscomp$inline_1114.rendererConfig,
+var internals$jscomp$inline_1312 = {
+  bundleType: devToolsConfig$jscomp$inline_1090.bundleType,
+  version: devToolsConfig$jscomp$inline_1090.version,
+  rendererPackageName: devToolsConfig$jscomp$inline_1090.rendererPackageName,
+  rendererConfig: devToolsConfig$jscomp$inline_1090.rendererConfig,
   overrideHookState: null,
   overrideHookStateDeletePath: null,
   overrideHookStateRenamePath: null,
@@ -9851,26 +9502,26 @@ var internals$jscomp$inline_1333 = {
     return null === fiber ? null : fiber.stateNode;
   },
   findFiberByHostInstance:
-    devToolsConfig$jscomp$inline_1114.findFiberByHostInstance ||
+    devToolsConfig$jscomp$inline_1090.findFiberByHostInstance ||
     emptyFindFiberByHostInstance,
   findHostInstancesForRefresh: null,
   scheduleRefresh: null,
   scheduleRoot: null,
   setRefreshHandler: null,
   getCurrentFiber: null,
-  reconcilerVersion: "18.3.0-canary-c1b45781"
+  reconcilerVersion: "18.3.0-canary-f2de0db5"
 };
 if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
-  var hook$jscomp$inline_1334 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
+  var hook$jscomp$inline_1313 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
   if (
-    !hook$jscomp$inline_1334.isDisabled &&
-    hook$jscomp$inline_1334.supportsFiber
+    !hook$jscomp$inline_1313.isDisabled &&
+    hook$jscomp$inline_1313.supportsFiber
   )
     try {
-      (rendererID = hook$jscomp$inline_1334.inject(
-        internals$jscomp$inline_1333
+      (rendererID = hook$jscomp$inline_1313.inject(
+        internals$jscomp$inline_1312
       )),
-        (injectedHook = hook$jscomp$inline_1334);
+        (injectedHook = hook$jscomp$inline_1313);
     } catch (err) {}
 }
 exports.createPortal = function (children, containerTag) {
diff --git a/node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-dev.js b/node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-dev.js
index d993f42..b755b91 100644
--- a/node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-dev.js
+++ b/node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-dev.js
@@ -8,7 +8,7 @@
  * @nolint
  * @providesModule ReactNativeRenderer-dev
  * @preventMunge
- * @generated SignedSource<<434937dbc3b1c3592d8ef8196d0c1a52>>
+ * @generated SignedSource<<4fbb60a6e6520f92ffc104738fdd5ce8>>
  */
 
 "use strict";
@@ -98,292 +98,14 @@ if (__DEV__) {
       }
     }
 
-    var fakeNode = null;
-
-    {
-      if (
-        typeof window !== "undefined" &&
-        typeof window.dispatchEvent === "function" &&
-        typeof document !== "undefined" && // $FlowFixMe[method-unbinding]
-        typeof document.createEvent === "function"
-      ) {
-        fakeNode = document.createElement("react");
-      }
-    }
-
-    function invokeGuardedCallbackImpl(name, func, context) {
-      {
-        // In DEV mode, we use a special version
-        // that plays more nicely with the browser's DevTools. The idea is to preserve
-        // "Pause on exceptions" behavior. Because React wraps all user-provided
-        // functions in invokeGuardedCallback, and the production version of
-        // invokeGuardedCallback uses a try-catch, all user exceptions are treated
-        // like caught exceptions, and the DevTools won't pause unless the developer
-        // takes the extra step of enabling pause on caught exceptions. This is
-        // unintuitive, though, because even though React has caught the error, from
-        // the developer's perspective, the error is uncaught.
-        //
-        // To preserve the expected "Pause on exceptions" behavior, we don't use a
-        // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
-        // DOM node, and call the user-provided callback from inside an event handler
-        // for that fake event. If the callback throws, the error is "captured" using
-        // event loop context, it does not interrupt the normal program flow.
-        // Effectively, this gives us try-catch behavior without actually using
-        // try-catch. Neat!
-        // fakeNode signifies we are in an environment with a document and window object
-        if (fakeNode) {
-          var evt = document.createEvent("Event");
-          var didCall = false; // Keeps track of whether the user-provided callback threw an error. We
-          // set this to true at the beginning, then set it to false right after
-          // calling the function. If the function errors, `didError` will never be
-          // set to false. This strategy works even if the browser is flaky and
-          // fails to call our global error handler, because it doesn't rely on
-          // the error event at all.
-
-          var didError = true; // Keeps track of the value of window.event so that we can reset it
-          // during the callback to let user code access window.event in the
-          // browsers that support it.
-
-          var windowEvent = window.event; // Keeps track of the descriptor of window.event to restore it after event
-          // dispatching: https://github.com/facebook/react/issues/13688
-
-          var windowEventDescriptor = Object.getOwnPropertyDescriptor(
-            window,
-            "event"
-          );
-
-          var restoreAfterDispatch = function () {
-            // We immediately remove the callback from event listeners so that
-            // nested `invokeGuardedCallback` calls do not clash. Otherwise, a
-            // nested call would trigger the fake event handlers of any call higher
-            // in the stack.
-            fakeNode.removeEventListener(evtType, callCallback, false); // We check for window.hasOwnProperty('event') to prevent the
-            // window.event assignment in both IE <= 10 as they throw an error
-            // "Member not found" in strict mode, and in Firefox which does not
-            // support window.event.
-
-            if (
-              typeof window.event !== "undefined" &&
-              window.hasOwnProperty("event")
-            ) {
-              window.event = windowEvent;
-            }
-          }; // Create an event handler for our fake event. We will synchronously
-          // dispatch our fake event using `dispatchEvent`. Inside the handler, we
-          // call the user-provided callback.
-          // $FlowFixMe[method-unbinding]
-
-          var _funcArgs = Array.prototype.slice.call(arguments, 3);
-
-          var callCallback = function () {
-            didCall = true;
-            restoreAfterDispatch(); // $FlowFixMe[incompatible-call] Flow doesn't understand the arguments splicing.
-
-            func.apply(context, _funcArgs);
-            didError = false;
-          }; // Create a global error event handler. We use this to capture the value
-          // that was thrown. It's possible that this error handler will fire more
-          // than once; for example, if non-React code also calls `dispatchEvent`
-          // and a handler for that event throws. We should be resilient to most of
-          // those cases. Even if our error event handler fires more than once, the
-          // last error event is always used. If the callback actually does error,
-          // we know that the last error event is the correct one, because it's not
-          // possible for anything else to have happened in between our callback
-          // erroring and the code that follows the `dispatchEvent` call below. If
-          // the callback doesn't error, but the error event was fired, we know to
-          // ignore it because `didError` will be false, as described above.
-
-          var error; // Use this to track whether the error event is ever called.
-
-          var didSetError = false;
-          var isCrossOriginError = false;
-
-          var handleWindowError = function (event) {
-            error = event.error;
-            didSetError = true;
-
-            if (error === null && event.colno === 0 && event.lineno === 0) {
-              isCrossOriginError = true;
-            }
-
-            if (event.defaultPrevented) {
-              // Some other error handler has prevented default.
-              // Browsers silence the error report if this happens.
-              // We'll remember this to later decide whether to log it or not.
-              if (error != null && typeof error === "object") {
-                try {
-                  error._suppressLogging = true;
-                } catch (inner) {
-                  // Ignore.
-                }
-              }
-            }
-          }; // Create a fake event type.
-
-          var evtType = "react-" + (name ? name : "invokeguardedcallback"); // Attach our event handlers
-
-          window.addEventListener("error", handleWindowError);
-          fakeNode.addEventListener(evtType, callCallback, false); // Synchronously dispatch our fake event. If the user-provided function
-          // errors, it will trigger our global error handler.
-
-          evt.initEvent(evtType, false, false);
-          fakeNode.dispatchEvent(evt);
-
-          if (windowEventDescriptor) {
-            Object.defineProperty(window, "event", windowEventDescriptor);
-          }
-
-          if (didCall && didError) {
-            if (!didSetError) {
-              // The callback errored, but the error event never fired.
-              // eslint-disable-next-line react-internal/prod-error-codes
-              error = new Error(
-                "An error was thrown inside one of your components, but React " +
-                  "doesn't know what it was. This is likely due to browser " +
-                  'flakiness. React does its best to preserve the "Pause on ' +
-                  'exceptions" behavior of the DevTools, which requires some ' +
-                  "DEV-mode only tricks. It's possible that these don't work in " +
-                  "your browser. Try triggering the error in production mode, " +
-                  "or switching to a modern browser. If you suspect that this is " +
-                  "actually an issue with React, please file an issue."
-              );
-            } else if (isCrossOriginError) {
-              // eslint-disable-next-line react-internal/prod-error-codes
-              error = new Error(
-                "A cross-origin error was thrown. React doesn't have access to " +
-                  "the actual error object in development. " +
-                  "See https://reactjs.org/link/crossorigin-error for more information."
-              );
-            }
-
-            this.onError(error);
-          } // Remove our event listeners
-
-          window.removeEventListener("error", handleWindowError);
-
-          if (didCall) {
-            return;
-          } else {
-            // Something went really wrong, and our event was not dispatched.
-            // https://github.com/facebook/react/issues/16734
-            // https://github.com/facebook/react/issues/16585
-            // Fall back to the production implementation.
-            restoreAfterDispatch(); // we fall through and call the prod version instead
-          }
-        } // We only get here if we are in an environment that either does not support the browser
-        // variant or we had trouble getting the browser to emit the error.
-        // $FlowFixMe[method-unbinding]
-
-        var funcArgs = Array.prototype.slice.call(arguments, 3);
-
-        try {
-          // $FlowFixMe[incompatible-call] Flow doesn't understand the arguments splicing.
-          func.apply(context, funcArgs);
-        } catch (error) {
-          this.onError(error);
-        }
-      }
-    }
-
-    var hasError = false;
-    var caughtError = null; // Used by event system to capture/rethrow the first error.
-
-    var hasRethrowError = false;
-    var rethrowError = null;
-    var reporter = {
-      onError: function (error) {
-        hasError = true;
-        caughtError = error;
-      }
-    };
-    /**
-     * Call a function while guarding against errors that happens within it.
-     * Returns an error if it throws, otherwise null.
-     *
-     * In production, this is implemented using a try-catch. The reason we don't
-     * use a try-catch directly is so that we can swap out a different
-     * implementation in DEV mode.
-     *
-     * @param {String} name of the guard to use for logging or debugging
-     * @param {Function} func The function to invoke
-     * @param {*} context The context to use when calling the function
-     * @param {...*} args Arguments for function
-     */
-
-    function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
-      hasError = false;
-      caughtError = null;
-      invokeGuardedCallbackImpl.apply(reporter, arguments);
-    }
-    /**
-     * Same as invokeGuardedCallback, but instead of returning an error, it stores
-     * it in a global so it can be rethrown by `rethrowCaughtError` later.
-     * TODO: See if caughtError and rethrowError can be unified.
-     *
-     * @param {String} name of the guard to use for logging or debugging
-     * @param {Function} func The function to invoke
-     * @param {*} context The context to use when calling the function
-     * @param {...*} args Arguments for function
-     */
-
-    function invokeGuardedCallbackAndCatchFirstError(
-      name,
-      func,
-      context,
-      a,
-      b,
-      c,
-      d,
-      e,
-      f
-    ) {
-      invokeGuardedCallback.apply(this, arguments);
-
-      if (hasError) {
-        var error = clearCaughtError();
-
-        if (!hasRethrowError) {
-          hasRethrowError = true;
-          rethrowError = error;
-        }
-      }
-    }
-    /**
-     * During execution of guarded functions we will capture the first error which
-     * we will rethrow to be handled by the top level error handler.
-     */
-
-    function rethrowCaughtError() {
-      if (hasRethrowError) {
-        var error = rethrowError;
-        hasRethrowError = false;
-        rethrowError = null;
-        throw error;
-      }
-    }
-    function hasCaughtError() {
-      return hasError;
-    }
-    function clearCaughtError() {
-      if (hasError) {
-        var error = caughtError;
-        hasError = false;
-        caughtError = null;
-        return error;
-      } else {
-        throw new Error(
-          "clearCaughtError was called but no error was captured. This error " +
-            "is likely caused by a bug in React. Please file an issue."
-        );
-      }
-    }
-
     var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare
 
     function isArray(a) {
       return isArrayImpl(a);
     }
 
+    var hasError = false;
+    var caughtError = null;
     var getFiberCurrentPropsFromNode$1 = null;
     var getInstanceFromNode = null;
     var getNodeFromInstance = null;
@@ -399,7 +121,7 @@ if (__DEV__) {
       {
         if (!getNodeFromInstance || !getInstanceFromNode) {
           error(
-            "EventPluginUtils.setComponentTree(...): Injected " +
+            "Injected " +
               "module is missing getNodeFromInstance or getInstanceFromNode."
           );
         }
@@ -439,9 +161,17 @@ if (__DEV__) {
      */
 
     function executeDispatch(event, listener, inst) {
-      var type = event.type || "unknown-event";
       event.currentTarget = getNodeFromInstance(inst);
-      invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
+
+      try {
+        listener(event);
+      } catch (error) {
+        if (!hasError) {
+          hasError = true;
+          caughtError = error;
+        }
+      }
+
       event.currentTarget = null;
     }
     /**
@@ -534,7 +264,7 @@ if (__DEV__) {
       var dispatchInstance = event._dispatchInstances;
 
       if (isArray(dispatchListener)) {
-        throw new Error("executeDirectDispatch(...): Invalid `event`.");
+        throw new Error("Invalid `event`.");
       }
 
       event.currentTarget = dispatchListener
@@ -554,6 +284,14 @@ if (__DEV__) {
     function hasDispatches(event) {
       return !!event._dispatchListeners;
     }
+    function rethrowCaughtError() {
+      if (hasError) {
+        var error = caughtError;
+        hasError = false;
+        caughtError = null;
+        throw error;
+      }
+    }
 
     var assign = Object.assign;
 
@@ -840,7 +578,7 @@ if (__DEV__) {
             "This synthetic event is reused for performance reasons. If you're seeing this, " +
               "you're %s `%s` on a released/nullified synthetic event. %s. " +
               "If you must keep the original synthetic event around, use event.persist(). " +
-              "See https://reactjs.org/link/event-pooling for more information.",
+              "See https://react.dev/link/event-pooling for more information.",
             action,
             propName,
             result
@@ -1160,9 +898,7 @@ if (__DEV__) {
 
     function accumulate(current, next) {
       if (next == null) {
-        throw new Error(
-          "accumulate(...): Accumulated items must not be null or undefined."
-        );
+        throw new Error("Accumulated items must not be null or undefined.");
       }
 
       if (current == null) {
@@ -1200,9 +936,7 @@ if (__DEV__) {
 
     function accumulateInto(current, next) {
       if (next == null) {
-        throw new Error(
-          "accumulateInto(...): Accumulated items must not be null or undefined."
-        );
+        throw new Error("Accumulated items must not be null or undefined.");
       }
 
       if (current == null) {
@@ -2940,6 +2674,7 @@ to return true:wantsResponderID|                            |
       key._reactInternals = value;
     }
 
+    // -----------------------------------------------------------------------------
     var enableSchedulingProfiler = false;
     var enableProfilerTimer = true;
     var enableProfilerCommitHooks = true;
@@ -2949,6 +2684,7 @@ to return true:wantsResponderID|                            |
     var enableLazyContextPropagation = false;
     var enableLegacyHidden = false;
     var enableAsyncActions = false;
+    var enableBigIntSupport = false;
 
     // ATTENTION
     // When adding new symbols to this file,
@@ -2959,7 +2695,9 @@ to return true:wantsResponderID|                            |
     var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
     var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
     var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
-    var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
+    var REACT_PROVIDER_TYPE = Symbol.for("react.provider"); // TODO: Delete with enableRenderableContext
+
+    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
     var REACT_CONTEXT_TYPE = Symbol.for("react.context");
     var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
     var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
@@ -3059,13 +2797,21 @@ to return true:wantsResponderID|                            |
         }
 
         switch (type.$$typeof) {
+          case REACT_PROVIDER_TYPE: {
+            var provider = type;
+            return getContextName$1(provider._context) + ".Provider";
+          }
+
           case REACT_CONTEXT_TYPE:
             var context = type;
-            return getContextName$1(context) + ".Consumer";
 
-          case REACT_PROVIDER_TYPE:
-            var provider = type;
-            return getContextName$1(provider._context) + ".Provider";
+            {
+              return getContextName$1(context) + ".Consumer";
+            }
+
+          case REACT_CONSUMER_TYPE: {
+            return null;
+          }
 
           case REACT_FORWARD_REF_TYPE:
             return getWrappedName$1(type, type.render, "ForwardRef");
@@ -3118,13 +2864,15 @@ to return true:wantsResponderID|                            |
         case CacheComponent:
           return "Cache";
 
-        case ContextConsumer:
+        case ContextConsumer: {
           var context = type;
           return getContextName(context) + ".Consumer";
+        }
 
-        case ContextProvider:
+        case ContextProvider: {
           var provider = type;
           return getContextName(provider._context) + ".Provider";
+        }
 
         case DehydratedFragment:
           return "DehydratedFragment";
@@ -3364,9 +3112,6 @@ to return true:wantsResponderID|                            |
 
       return null;
     }
-    function isFiberMounted(fiber) {
-      return getNearestMountedFiber(fiber) === fiber;
-    }
     function isMounted(component) {
       {
         var owner = ReactCurrentOwner$3.current;
@@ -4379,7 +4124,7 @@ to return true:wantsResponderID|                            |
           error(
             "The installed version of React DevTools is too old and will not work " +
               "with the current version of React. Please update React DevTools. " +
-              "https://reactjs.org/link/react-devtools"
+              "https://react.dev/link/react-devtools"
           );
         } // DevTools exists, even though it doesn't support Fiber.
 
@@ -5126,7 +4871,7 @@ to return true:wantsResponderID|                            |
 
       return laneMap;
     }
-    function markRootUpdated(root, updateLane) {
+    function markRootUpdated$1(root, updateLane) {
       root.pendingLanes |= updateLane; // If there are any suspended transitions, it's possible this new update
       // could unblock them. Clear the suspended lanes so that we can try rendering
       // them again.
@@ -5163,7 +4908,7 @@ to return true:wantsResponderID|                            |
         markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
       }
     }
-    function markRootPinged(root, pingedLanes) {
+    function markRootPinged$1(root, pingedLanes) {
       root.pingedLanes |= root.suspendedLanes & pingedLanes;
     }
     function markRootFinished(root, remainingLanes, spawnedLane) {
@@ -5817,214 +5562,6 @@ to return true:wantsResponderID|                            |
       return null;
     }
 
-    function describeBuiltInComponentFrame(name, ownerFn) {
-      {
-        var ownerName = null;
-
-        if (ownerFn) {
-          ownerName = ownerFn.displayName || ownerFn.name || null;
-        }
-
-        return describeComponentFrame(name, ownerName);
-      }
-    }
-
-    {
-      var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
-      new PossiblyWeakMap$1();
-    }
-
-    function describeComponentFrame(name, ownerName) {
-      var sourceInfo = "";
-
-      if (ownerName) {
-        sourceInfo = " (created by " + ownerName + ")";
-      }
-
-      return "\n    in " + (name || "Unknown") + sourceInfo;
-    }
-
-    function describeClassComponentFrame(ctor, ownerFn) {
-      {
-        return describeFunctionComponentFrame(ctor, ownerFn);
-      }
-    }
-    function describeFunctionComponentFrame(fn, ownerFn) {
-      {
-        if (!fn) {
-          return "";
-        }
-
-        var name = fn.displayName || fn.name || null;
-        var ownerName = null;
-
-        if (ownerFn) {
-          ownerName = ownerFn.displayName || ownerFn.name || null;
-        }
-
-        return describeComponentFrame(name, ownerName);
-      }
-    }
-
-    function describeUnknownElementTypeFrameInDEV(type, ownerFn) {
-      if (type == null) {
-        return "";
-      }
-
-      if (typeof type === "function") {
-        {
-          return describeFunctionComponentFrame(type, ownerFn);
-        }
-      }
-
-      if (typeof type === "string") {
-        return describeBuiltInComponentFrame(type, ownerFn);
-      }
-
-      switch (type) {
-        case REACT_SUSPENSE_TYPE:
-          return describeBuiltInComponentFrame("Suspense", ownerFn);
-
-        case REACT_SUSPENSE_LIST_TYPE:
-          return describeBuiltInComponentFrame("SuspenseList", ownerFn);
-      }
-
-      if (typeof type === "object") {
-        switch (type.$$typeof) {
-          case REACT_FORWARD_REF_TYPE:
-            return describeFunctionComponentFrame(type.render, ownerFn);
-
-          case REACT_MEMO_TYPE:
-            // Memo may contain any component type so we recursively resolve it.
-            return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);
-
-          case REACT_LAZY_TYPE: {
-            var lazyComponent = type;
-            var payload = lazyComponent._payload;
-            var init = lazyComponent._init;
-
-            try {
-              // Lazy may contain any component type so we recursively resolve it.
-              return describeUnknownElementTypeFrameInDEV(
-                init(payload),
-                ownerFn
-              );
-            } catch (x) {}
-          }
-        }
-      }
-
-      return "";
-    }
-
-    // $FlowFixMe[method-unbinding]
-    var hasOwnProperty = Object.prototype.hasOwnProperty;
-
-    var loggedTypeFailures = {};
-    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
-
-    function setCurrentlyValidatingElement(element) {
-      {
-        if (element) {
-          var owner = element._owner;
-          var stack = describeUnknownElementTypeFrameInDEV(
-            element.type,
-            owner ? owner.type : null
-          );
-          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
-        } else {
-          ReactDebugCurrentFrame$1.setExtraStackFrame(null);
-        }
-      }
-    }
-
-    function checkPropTypes(
-      typeSpecs,
-      values,
-      location,
-      componentName,
-      element
-    ) {
-      {
-        // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.
-        var has = Function.call.bind(hasOwnProperty);
-
-        for (var typeSpecName in typeSpecs) {
-          if (has(typeSpecs, typeSpecName)) {
-            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
-            // fail the render phase where it didn't fail before. So we log it.
-            // After these have been cleaned up, we'll let them throw.
-
-            try {
-              // This is intentionally an invariant that gets caught. It's the same
-              // behavior as without this statement except with a better message.
-              if (typeof typeSpecs[typeSpecName] !== "function") {
-                // eslint-disable-next-line react-internal/prod-error-codes
-                var err = Error(
-                  (componentName || "React class") +
-                    ": " +
-                    location +
-                    " type `" +
-                    typeSpecName +
-                    "` is invalid; " +
-                    "it must be a function, usually from the `prop-types` package, but received `" +
-                    typeof typeSpecs[typeSpecName] +
-                    "`." +
-                    "This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
-                );
-                err.name = "Invariant Violation";
-                throw err;
-              }
-
-              error$1 = typeSpecs[typeSpecName](
-                values,
-                typeSpecName,
-                componentName,
-                location,
-                null,
-                "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
-              );
-            } catch (ex) {
-              error$1 = ex;
-            }
-
-            if (error$1 && !(error$1 instanceof Error)) {
-              setCurrentlyValidatingElement(element);
-
-              error(
-                "%s: type specification of %s" +
-                  " `%s` is invalid; the type checker " +
-                  "function must return `null` or an `Error` but returned a %s. " +
-                  "You may have forgotten to pass an argument to the type checker " +
-                  "creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and " +
-                  "shape all require an argument).",
-                componentName || "React class",
-                location,
-                typeSpecName,
-                typeof error$1
-              );
-
-              setCurrentlyValidatingElement(null);
-            }
-
-            if (
-              error$1 instanceof Error &&
-              !(error$1.message in loggedTypeFailures)
-            ) {
-              // Only monitor this failure once because there tends to be a lot of the
-              // same error.
-              loggedTypeFailures[error$1.message] = true;
-              setCurrentlyValidatingElement(element);
-
-              error("Failed %s type: %s", location, error$1.message);
-
-              setCurrentlyValidatingElement(null);
-            }
-          }
-        }
-      }
-    }
-
     var valueStack = [];
     var fiberStack;
 
@@ -6076,280 +5613,33 @@ to return true:wantsResponderID|                            |
       cursor.current = value;
     }
 
-    var warnedAboutMissingGetChildContext;
-
-    {
-      warnedAboutMissingGetChildContext = {};
-    }
-
-    var emptyContextObject = {};
+    var emptyContextObject = {};
 
     {
       Object.freeze(emptyContextObject);
     } // A cursor to the current merged context object on the stack.
 
-    var contextStackCursor$1 = createCursor(emptyContextObject); // A cursor to a boolean indicating whether the context has changed.
-
-    var didPerformWorkStackCursor = createCursor(false); // Keep track of the previous context object that was on the stack.
-    // We use this to get access to the parent context after we have already
-    // pushed the next context provider, and now need to merge their contexts.
-
-    var previousContext = emptyContextObject;
-
-    function getUnmaskedContext(
-      workInProgress,
-      Component,
-      didPushOwnContextIfProvider
-    ) {
-      {
-        if (didPushOwnContextIfProvider && isContextProvider(Component)) {
-          // If the fiber is a context provider itself, when we read its context
-          // we may have already pushed its own child context on the stack. A context
-          // provider should not "see" its own child context. Therefore we read the
-          // previous (parent) context instead for a context provider.
-          return previousContext;
-        }
-
-        return contextStackCursor$1.current;
-      }
-    }
-
-    function cacheContext(workInProgress, unmaskedContext, maskedContext) {
-      {
-        var instance = workInProgress.stateNode;
-        instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
-        instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
-      }
-    }
-
-    function getMaskedContext(workInProgress, unmaskedContext) {
-      {
-        var type = workInProgress.type;
-        var contextTypes = type.contextTypes;
-
-        if (!contextTypes) {
-          return emptyContextObject;
-        } // Avoid recreating masked context unless unmasked context has changed.
-        // Failing to do this will result in unnecessary calls to componentWillReceiveProps.
-        // This may trigger infinite loops if componentWillReceiveProps calls setState.
-
-        var instance = workInProgress.stateNode;
-
-        if (
-          instance &&
-          instance.__reactInternalMemoizedUnmaskedChildContext ===
-            unmaskedContext
-        ) {
-          return instance.__reactInternalMemoizedMaskedChildContext;
-        }
-
-        var context = {};
-
-        for (var key in contextTypes) {
-          context[key] = unmaskedContext[key];
-        }
-
-        {
-          var name = getComponentNameFromFiber(workInProgress) || "Unknown";
-          checkPropTypes(contextTypes, context, "context", name);
-        } // Cache unmasked context so we can avoid recreating masked context unless necessary.
-        // Context is created before the class component is instantiated so check for instance.
-
-        if (instance) {
-          cacheContext(workInProgress, unmaskedContext, context);
-        }
-
-        return context;
-      }
-    }
-
     function hasContextChanged() {
       {
-        return didPerformWorkStackCursor.current;
+        return false;
       }
     }
 
     function isContextProvider(type) {
       {
-        var childContextTypes = type.childContextTypes;
-        return childContextTypes !== null && childContextTypes !== undefined;
-      }
-    }
-
-    function popContext(fiber) {
-      {
-        pop(didPerformWorkStackCursor, fiber);
-        pop(contextStackCursor$1, fiber);
-      }
-    }
-
-    function popTopLevelContextObject(fiber) {
-      {
-        pop(didPerformWorkStackCursor, fiber);
-        pop(contextStackCursor$1, fiber);
-      }
-    }
-
-    function pushTopLevelContextObject(fiber, context, didChange) {
-      {
-        if (contextStackCursor$1.current !== emptyContextObject) {
-          throw new Error(
-            "Unexpected context found on stack. " +
-              "This error is likely caused by a bug in React. Please file an issue."
-          );
-        }
-
-        push(contextStackCursor$1, context, fiber);
-        push(didPerformWorkStackCursor, didChange, fiber);
+        return false;
       }
     }
 
     function processChildContext(fiber, type, parentContext) {
       {
-        var instance = fiber.stateNode;
-        var childContextTypes = type.childContextTypes; // TODO (bvaughn) Replace this behavior with an invariant() in the future.
-        // It has only been added in Fiber to match the (unintentional) behavior in Stack.
-
-        if (typeof instance.getChildContext !== "function") {
-          {
-            var componentName = getComponentNameFromFiber(fiber) || "Unknown";
-
-            if (!warnedAboutMissingGetChildContext[componentName]) {
-              warnedAboutMissingGetChildContext[componentName] = true;
-
-              error(
-                "%s.childContextTypes is specified but there is no getChildContext() method " +
-                  "on the instance. You can either define getChildContext() on %s or remove " +
-                  "childContextTypes from it.",
-                componentName,
-                componentName
-              );
-            }
-          }
-
-          return parentContext;
-        }
-
-        var childContext = instance.getChildContext();
-
-        for (var contextKey in childContext) {
-          if (!(contextKey in childContextTypes)) {
-            throw new Error(
-              (getComponentNameFromFiber(fiber) || "Unknown") +
-                '.getChildContext(): key "' +
-                contextKey +
-                '" is not defined in childContextTypes.'
-            );
-          }
-        }
-
-        {
-          var name = getComponentNameFromFiber(fiber) || "Unknown";
-          checkPropTypes(
-            childContextTypes,
-            childContext,
-            "child context",
-            name
-          );
-        }
-
-        return assign({}, parentContext, childContext);
-      }
-    }
-
-    function pushContextProvider(workInProgress) {
-      {
-        var instance = workInProgress.stateNode; // We push the context as early as possible to ensure stack integrity.
-        // If the instance does not exist yet, we will push null at first,
-        // and replace it on the stack later when invalidating the context.
-
-        var memoizedMergedChildContext =
-          (instance && instance.__reactInternalMemoizedMergedChildContext) ||
-          emptyContextObject; // Remember the parent context so we can merge with it later.
-        // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
-
-        previousContext = contextStackCursor$1.current;
-        push(contextStackCursor$1, memoizedMergedChildContext, workInProgress);
-        push(
-          didPerformWorkStackCursor,
-          didPerformWorkStackCursor.current,
-          workInProgress
-        );
-        return true;
-      }
-    }
-
-    function invalidateContextProvider(workInProgress, type, didChange) {
-      {
-        var instance = workInProgress.stateNode;
-
-        if (!instance) {
-          throw new Error(
-            "Expected to have an instance by this point. " +
-              "This error is likely caused by a bug in React. Please file an issue."
-          );
-        }
-
-        if (didChange) {
-          // Merge parent and own context.
-          // Skip this if we're not updating due to sCU.
-          // This avoids unnecessarily recomputing memoized values.
-          var mergedContext = processChildContext(
-            workInProgress,
-            type,
-            previousContext
-          );
-          instance.__reactInternalMemoizedMergedChildContext = mergedContext; // Replace the old (or empty) context with the new one.
-          // It is important to unwind the context in the reverse order.
-
-          pop(didPerformWorkStackCursor, workInProgress);
-          pop(contextStackCursor$1, workInProgress); // Now push the new context and mark that it has changed.
-
-          push(contextStackCursor$1, mergedContext, workInProgress);
-          push(didPerformWorkStackCursor, didChange, workInProgress);
-        } else {
-          pop(didPerformWorkStackCursor, workInProgress);
-          push(didPerformWorkStackCursor, didChange, workInProgress);
-        }
+        return parentContext;
       }
     }
 
     function findCurrentUnmaskedContext(fiber) {
       {
-        // Currently this is only used with renderSubtreeIntoContainer; not sure if it
-        // makes sense elsewhere
-        if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {
-          throw new Error(
-            "Expected subtree parent to be a mounted class component. " +
-              "This error is likely caused by a bug in React. Please file an issue."
-          );
-        }
-
-        var node = fiber;
-
-        do {
-          switch (node.tag) {
-            case HostRoot:
-              return node.stateNode.context;
-
-            case ClassComponent: {
-              var Component = node.type;
-
-              if (isContextProvider(Component)) {
-                return node.stateNode.__reactInternalMemoizedMergedChildContext;
-              }
-
-              break;
-            }
-          } // $FlowFixMe[incompatible-type] we bail out when we get a null
-
-          node = node.return;
-        } while (node !== null);
-
-        throw new Error(
-          "Found unexpected detached subtree parent. " +
-            "This error is likely caused by a bug in React. Please file an issue."
-        );
+        return emptyContextObject;
       }
     }
 
@@ -6468,16 +5758,8 @@ to return true:wantsResponderID|                            |
     }
 
     var isHydrating = false; // This flag allows for warning supression when we expect there to be mismatches
-    // due to earlier mismatches or a suspended fiber.
-
-    var didSuspendOrErrorDEV = false; // Hydration errors that were thrown inside this boundary
 
     var hydrationErrors = null;
-    function didSuspendOrErrorWhileHydratingDEV() {
-      {
-        return didSuspendOrErrorDEV;
-      }
-    }
 
     function prepareToHydrateHostInstance(fiber, hostContext) {
       {
@@ -7819,6 +7101,9 @@ to return true:wantsResponderID|                            |
       }
     }
 
+    // $FlowFixMe[method-unbinding]
+    var hasOwnProperty = Object.prototype.hasOwnProperty;
+
     /**
      * Performs equality by iterating through keys on an object and returning false
      * when any key has values which are not strictly equal between the arguments.
@@ -7860,6 +7145,61 @@ to return true:wantsResponderID|                            |
       return true;
     }
 
+    function describeBuiltInComponentFrame(name, ownerFn) {
+      {
+        var ownerName = null;
+
+        if (ownerFn) {
+          ownerName = ownerFn.displayName || ownerFn.name || null;
+        }
+
+        return describeComponentFrame(name, ownerName);
+      }
+    }
+    function describeDebugInfoFrame(name, env) {
+      return describeBuiltInComponentFrame(
+        name + (env ? " (" + env + ")" : ""),
+        null
+      );
+    }
+
+    {
+      var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
+      new PossiblyWeakMap$1();
+    }
+
+    function describeComponentFrame(name, ownerName) {
+      var sourceInfo = "";
+
+      if (ownerName) {
+        sourceInfo = " (created by " + ownerName + ")";
+      }
+
+      return "\n    in " + (name || "Unknown") + sourceInfo;
+    }
+
+    function describeClassComponentFrame(ctor, ownerFn) {
+      {
+        return describeFunctionComponentFrame(ctor, ownerFn);
+      }
+    }
+    function describeFunctionComponentFrame(fn, ownerFn) {
+      {
+        if (!fn) {
+          return "";
+        }
+
+        var name = fn.displayName || fn.name || null;
+        var ownerName = null;
+
+        if (ownerFn) {
+          ownerName = ownerFn.displayName || ownerFn.name || null;
+        }
+
+        return describeComponentFrame(name, ownerName);
+      }
+    }
+
     function describeFiber(fiber) {
       var owner = fiber._debugOwner ? fiber._debugOwner.type : null;
 
@@ -7900,7 +7240,22 @@ to return true:wantsResponderID|                            |
         var node = workInProgress;
 
         do {
-          info += describeFiber(node); // $FlowFixMe[incompatible-type] we bail out when we get a null
+          info += describeFiber(node);
+
+          if (true) {
+            // Add any Server Component stack frames in reverse order.
+            var debugInfo = node._debugInfo;
+
+            if (debugInfo) {
+              for (var i = debugInfo.length - 1; i >= 0; i--) {
+                var entry = debugInfo[i];
+
+                if (typeof entry.name === "string") {
+                  info += describeDebugInfoFrame(entry.name, entry.env);
+                }
+              }
+            }
+          } // $FlowFixMe[incompatible-type] we bail out when we get a null
 
           node = node.return;
         } while (node);
@@ -8146,7 +7501,7 @@ to return true:wantsResponderID|                            |
 
             error(
               "Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. " +
-                "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n" +
+                "See https://react.dev/link/unsafe-component-lifecycles for details.\n\n" +
                 "* Move code with side effects to componentDidMount, and set initial state in the constructor.\n" +
                 "\nPlease update the following components: %s",
               sortedNames
@@ -8161,11 +7516,11 @@ to return true:wantsResponderID|                            |
             error(
               "Using UNSAFE_componentWillReceiveProps in strict mode is not recommended " +
                 "and may indicate bugs in your code. " +
-                "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n" +
+                "See https://react.dev/link/unsafe-component-lifecycles for details.\n\n" +
                 "* Move data fetching code or side effects to componentDidUpdate.\n" +
                 "* If you're updating state whenever props change, " +
                 "refactor your code to use memoization techniques or move it to " +
-                "static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n" +
+                "static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n" +
                 "\nPlease update the following components: %s",
               _sortedNames
             );
@@ -8179,7 +7534,7 @@ to return true:wantsResponderID|                            |
             error(
               "Using UNSAFE_componentWillUpdate in strict mode is not recommended " +
                 "and may indicate bugs in your code. " +
-                "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n" +
+                "See https://react.dev/link/unsafe-component-lifecycles for details.\n\n" +
                 "* Move data fetching code or side effects to componentDidUpdate.\n" +
                 "\nPlease update the following components: %s",
               _sortedNames2
@@ -8193,7 +7548,7 @@ to return true:wantsResponderID|                            |
 
             warn(
               "componentWillMount has been renamed, and is not recommended for use. " +
-                "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n" +
+                "See https://react.dev/link/unsafe-component-lifecycles for details.\n\n" +
                 "* Move code with side effects to componentDidMount, and set initial state in the constructor.\n" +
                 "* Rename componentWillMount to UNSAFE_componentWillMount to suppress " +
                 "this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. " +
@@ -8211,11 +7566,11 @@ to return true:wantsResponderID|                            |
 
             warn(
               "componentWillReceiveProps has been renamed, and is not recommended for use. " +
-                "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n" +
+                "See https://react.dev/link/unsafe-component-lifecycles for details.\n\n" +
                 "* Move data fetching code or side effects to componentDidUpdate.\n" +
                 "* If you're updating state whenever props change, refactor your " +
                 "code to use memoization techniques or move it to " +
-                "static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n" +
+                "static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n" +
                 "* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress " +
                 "this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. " +
                 "To rename all deprecated lifecycles to their new names, you can run " +
@@ -8232,7 +7587,7 @@ to return true:wantsResponderID|                            |
 
             warn(
               "componentWillUpdate has been renamed, and is not recommended for use. " +
-                "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n" +
+                "See https://react.dev/link/unsafe-component-lifecycles for details.\n\n" +
                 "* Move data fetching code or side effects to componentDidUpdate.\n" +
                 "* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress " +
                 "this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. " +
@@ -8305,7 +7660,7 @@ to return true:wantsResponderID|                            |
                 "\n\nThe old API will be supported in all 16.x releases, but applications " +
                 "using it should migrate to the new version." +
                 "\n\nPlease update the following components: %s" +
-                "\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context",
+                "\n\nLearn more about this warning here: https://react.dev/link/legacy-context",
               sortedNames
             );
           } finally {
@@ -8585,20 +7940,20 @@ to return true:wantsResponderID|                            |
                   rejectedThenable.reason = error;
                 }
               }
-            ); // Check one more time in case the thenable resolved synchronously.
+            );
+          } // Check one more time in case the thenable resolved synchronously.
 
-            switch (thenable.status) {
-              case "fulfilled": {
-                var fulfilledThenable = thenable;
-                return fulfilledThenable.value;
-              }
+          switch (thenable.status) {
+            case "fulfilled": {
+              var fulfilledThenable = thenable;
+              return fulfilledThenable.value;
+            }
 
-              case "rejected": {
-                var rejectedThenable = thenable;
-                var _rejectedError = rejectedThenable.reason;
-                checkIfUseWrappedInAsyncCatch(_rejectedError);
-                throw _rejectedError;
-              }
+            case "rejected": {
+              var rejectedThenable = thenable;
+              var _rejectedError = rejectedThenable.reason;
+              checkIfUseWrappedInAsyncCatch(_rejectedError);
+              throw _rejectedError;
             }
           } // Suspend.
           //
@@ -8676,11 +8031,26 @@ to return true:wantsResponderID|                            |
 
     var thenableState$1 = null;
     var thenableIndexCounter$1 = 0;
+
+    function mergeDebugInfo(outer, inner) {
+      if (inner == null) {
+        return outer;
+      } else if (outer === null) {
+        return inner;
+      } else {
+        // If we have two debugInfo, we need to create a new one. This makes the array no longer
+        // live so we'll miss any future updates if we received more so ideally we should always
+        // do this after both have fully resolved/unsuspended.
+        return outer.concat(inner);
+      }
+    }
+
     var didWarnAboutMaps;
     var didWarnAboutGenerators;
     var didWarnAboutStringRefs;
     var ownerHasKeyUseWarning;
     var ownerHasFunctionTypeWarning;
+    var ownerHasSymbolTypeWarning;
 
     var warnForMissingKey = function (child, returnFiber) {};
 
@@ -8696,6 +8066,7 @@ to return true:wantsResponderID|                            |
 
       ownerHasKeyUseWarning = {};
       ownerHasFunctionTypeWarning = {};
+      ownerHasSymbolTypeWarning = {};
 
       warnForMissingKey = function (child, returnFiber) {
         if (child === null || typeof child !== "object") {
@@ -8725,7 +8096,7 @@ to return true:wantsResponderID|                            |
 
         error(
           "Each child in a list should have a unique " +
-            '"key" prop. See https://reactjs.org/link/warning-keys for ' +
+            '"key" prop. See https://react.dev/link/warning-keys for ' +
             "more information."
         );
       };
@@ -8746,122 +8117,128 @@ to return true:wantsResponderID|                            |
       return trackUsedThenable(thenableState$1, thenable, index);
     }
 
-    function coerceRef(returnFiber, current, element) {
-      var mixedRef = element.ref;
-
-      if (
-        mixedRef !== null &&
-        typeof mixedRef !== "function" &&
-        typeof mixedRef !== "object"
-      ) {
-        {
-          if (
-            // Will already throw with "Function components cannot have string refs"
-            !(element._owner && element._owner.tag !== ClassComponent) && // Will already warn with "Function components cannot be given refs"
-            !(
-              typeof element.type === "function" && !isReactClass(element.type)
-            ) && // Will already throw with "Element ref was specified as a string (someStringRef) but no owner was set"
-            element._owner
-          ) {
-            var componentName =
-              getComponentNameFromFiber(returnFiber) || "Component";
-
-            if (!didWarnAboutStringRefs[componentName]) {
-              error(
-                'Component "%s" contains the string ref "%s". Support for string refs ' +
-                  "will be removed in a future major release. We recommend using " +
-                  "useRef() or createRef() instead. " +
-                  "Learn more about using refs safely here: " +
-                  "https://reactjs.org/link/strict-mode-string-ref",
-                componentName,
-                mixedRef
-              );
-
-              didWarnAboutStringRefs[componentName] = true;
-            }
-          }
-        }
+    function convertStringRefToCallbackRef(
+      returnFiber,
+      current,
+      element,
+      mixedRef
+    ) {
+      {
+        checkPropStringCoercion(mixedRef, "ref");
+      }
 
-        if (element._owner) {
-          var owner = element._owner;
-          var inst;
+      var stringRef = "" + mixedRef;
+      var owner = element._owner;
 
-          if (owner) {
-            var ownerFiber = owner;
+      if (!owner) {
+        throw new Error(
+          "Element ref was specified as a string (" +
+            stringRef +
+            ") but no owner was set. This could happen for one of" +
+            " the following reasons:\n" +
+            "1. You may be adding a ref to a function component\n" +
+            "2. You may be adding a ref to a component that was not created inside a component's render method\n" +
+            "3. You have multiple copies of React loaded\n" +
+            "See https://react.dev/link/refs-must-have-owner for more information."
+        );
+      }
 
-            if (ownerFiber.tag !== ClassComponent) {
-              throw new Error(
-                "Function components cannot have string refs. " +
-                  "We recommend using useRef() instead. " +
-                  "Learn more about using refs safely here: " +
-                  "https://reactjs.org/link/strict-mode-string-ref"
-              );
-            }
+      if (owner.tag !== ClassComponent) {
+        throw new Error(
+          "Function components cannot have string refs. " +
+            "We recommend using useRef() instead. " +
+            "Learn more about using refs safely here: " +
+            "https://react.dev/link/strict-mode-string-ref"
+        );
+      }
 
-            inst = ownerFiber.stateNode;
-          }
+      {
+        if (
+          // Will already warn with "Function components cannot be given refs"
+          !(typeof element.type === "function" && !isReactClass(element.type))
+        ) {
+          var componentName =
+            getComponentNameFromFiber(returnFiber) || "Component";
 
-          if (!inst) {
-            throw new Error(
-              "Missing owner for string ref " +
-                mixedRef +
-                ". This error is likely caused by a " +
-                "bug in React. Please file an issue."
+          if (!didWarnAboutStringRefs[componentName]) {
+            error(
+              'Component "%s" contains the string ref "%s". Support for string refs ' +
+                "will be removed in a future major release. We recommend using " +
+                "useRef() or createRef() instead. " +
+                "Learn more about using refs safely here: " +
+                "https://react.dev/link/strict-mode-string-ref",
+              componentName,
+              stringRef
             );
-          } // Assigning this to a const so Flow knows it won't change in the closure
-
-          var resolvedInst = inst;
 
-          {
-            checkPropStringCoercion(mixedRef, "ref");
+            didWarnAboutStringRefs[componentName] = true;
           }
+        }
+      }
 
-          var stringRef = "" + mixedRef; // Check if previous string ref matches new string ref
+      var inst = owner.stateNode;
 
-          if (
-            current !== null &&
-            current.ref !== null &&
-            typeof current.ref === "function" &&
-            current.ref._stringRef === stringRef
-          ) {
-            return current.ref;
-          }
+      if (!inst) {
+        throw new Error(
+          "Missing owner for string ref " +
+            stringRef +
+            ". This error is likely caused by a " +
+            "bug in React. Please file an issue."
+        );
+      } // Check if previous string ref matches new string ref
 
-          var ref = function (value) {
-            var refs = resolvedInst.refs;
+      if (
+        current !== null &&
+        current.ref !== null &&
+        typeof current.ref === "function" &&
+        current.ref._stringRef === stringRef
+      ) {
+        // Reuse the existing string ref
+        var currentRef = current.ref;
+        return currentRef;
+      } // Create a new string ref
 
-            if (value === null) {
-              delete refs[stringRef];
-            } else {
-              refs[stringRef] = value;
-            }
-          };
+      var ref = function (value) {
+        var refs = inst.refs;
 
-          ref._stringRef = stringRef;
-          return ref;
+        if (value === null) {
+          delete refs[stringRef];
         } else {
-          if (typeof mixedRef !== "string") {
-            throw new Error(
-              "Expected ref to be a function, a string, an object returned by React.createRef(), or null."
-            );
-          }
-
-          if (!element._owner) {
-            throw new Error(
-              "Element ref was specified as a string (" +
-                mixedRef +
-                ") but no owner was set. This could happen for one of" +
-                " the following reasons:\n" +
-                "1. You may be adding a ref to a function component\n" +
-                "2. You may be adding a ref to a component that was not created inside a component's render method\n" +
-                "3. You have multiple copies of React loaded\n" +
-                "See https://reactjs.org/link/refs-must-have-owner for more information."
-            );
-          }
+          refs[stringRef] = value;
         }
+      };
+
+      ref._stringRef = stringRef;
+      return ref;
+    }
+
+    function coerceRef(returnFiber, current, workInProgress, element) {
+      var mixedRef;
+
+      {
+        // Old behavior.
+        mixedRef = element.ref;
       }
 
-      return mixedRef;
+      var coercedRef;
+
+      if (
+        typeof mixedRef === "string" ||
+        typeof mixedRef === "number" ||
+        typeof mixedRef === "boolean"
+      ) {
+        coercedRef = convertStringRefToCallbackRef(
+          returnFiber,
+          current,
+          element,
+          mixedRef
+        );
+      } else {
+        coercedRef = mixedRef;
+      } // TODO: If enableRefAsProp is on, we shouldn't use the `ref` field. We
+      // should always read the ref from the prop.
+
+      workInProgress.ref = coercedRef;
     }
 
     function throwOnInvalidObjectType(returnFiber, newChild) {
@@ -8878,22 +8255,68 @@ to return true:wantsResponderID|                            |
       );
     }
 
-    function warnOnFunctionType(returnFiber) {
+    function warnOnFunctionType(returnFiber, invalidChild) {
       {
-        var componentName =
-          getComponentNameFromFiber(returnFiber) || "Component";
+        var parentName = getComponentNameFromFiber(returnFiber) || "Component";
 
-        if (ownerHasFunctionTypeWarning[componentName]) {
+        if (ownerHasFunctionTypeWarning[parentName]) {
           return;
         }
 
-        ownerHasFunctionTypeWarning[componentName] = true;
+        ownerHasFunctionTypeWarning[parentName] = true;
+        var name = invalidChild.displayName || invalidChild.name || "Component";
 
-        error(
-          "Functions are not valid as a React child. This may happen if " +
-            "you return a Component instead of <Component /> from render. " +
-            "Or maybe you meant to call this function rather than return it."
-        );
+        if (returnFiber.tag === HostRoot) {
+          error(
+            "Functions are not valid as a React child. This may happen if " +
+              "you return %s instead of <%s /> from render. " +
+              "Or maybe you meant to call this function rather than return it.\n" +
+              "  root.render(%s)",
+            name,
+            name,
+            name
+          );
+        } else {
+          error(
+            "Functions are not valid as a React child. This may happen if " +
+              "you return %s instead of <%s /> from render. " +
+              "Or maybe you meant to call this function rather than return it.\n" +
+              "  <%s>{%s}</%s>",
+            name,
+            name,
+            parentName,
+            name,
+            parentName
+          );
+        }
+      }
+    }
+
+    function warnOnSymbolType(returnFiber, invalidChild) {
+      {
+        var parentName = getComponentNameFromFiber(returnFiber) || "Component";
+
+        if (ownerHasSymbolTypeWarning[parentName]) {
+          return;
+        }
+
+        ownerHasSymbolTypeWarning[parentName] = true; // eslint-disable-next-line react-internal/safe-string-coercion
+
+        var name = String(invalidChild);
+
+        if (returnFiber.tag === HostRoot) {
+          error(
+            "Symbols are not valid as a React child.\n" + "  root.render(%s)",
+            name
+          );
+        } else {
+          error(
+            "Symbols are not valid as a React child.\n" + "  <%s>%s</%s>",
+            parentName,
+            name,
+            parentName
+          );
+        }
       }
     }
 
@@ -8940,7 +8363,7 @@ to return true:wantsResponderID|                            |
         return null;
       }
 
-      function mapRemainingChildren(returnFiber, currentFirstChild) {
+      function mapRemainingChildren(currentFirstChild) {
         // Add the remaining children to a temporary map so that we can find them by
         // keys quickly. Implicit (null) keys get added to this set with their index
         // instead.
@@ -9009,7 +8432,13 @@ to return true:wantsResponderID|                            |
         return newFiber;
       }
 
-      function updateTextNode(returnFiber, current, textContent, lanes) {
+      function updateTextNode(
+        returnFiber,
+        current,
+        textContent,
+        lanes,
+        debugInfo
+      ) {
         if (current === null || current.tag !== HostText) {
           // Insert
           var created = createFiberFromText(
@@ -9018,16 +8447,26 @@ to return true:wantsResponderID|                            |
             lanes
           );
           created.return = returnFiber;
+
+          {
+            created._debugInfo = debugInfo;
+          }
+
           return created;
         } else {
           // Update
           var existing = useFiber(current, textContent);
           existing.return = returnFiber;
+
+          {
+            existing._debugInfo = debugInfo;
+          }
+
           return existing;
         }
       }
 
-      function updateElement(returnFiber, current, element, lanes) {
+      function updateElement(returnFiber, current, element, lanes, debugInfo) {
         var elementType = element.type;
 
         if (elementType === REACT_FRAGMENT_TYPE) {
@@ -9036,7 +8475,8 @@ to return true:wantsResponderID|                            |
             current,
             element.props.children,
             lanes,
-            element.key
+            element.key,
+            debugInfo
           );
         }
 
@@ -9054,11 +8494,12 @@ to return true:wantsResponderID|                            |
           ) {
             // Move based on index
             var existing = useFiber(current, element.props);
-            existing.ref = coerceRef(returnFiber, current, element);
+            coerceRef(returnFiber, current, existing, element);
             existing.return = returnFiber;
 
             {
               existing._debugOwner = element._owner;
+              existing._debugInfo = debugInfo;
             }
 
             return existing;
@@ -9066,12 +8507,17 @@ to return true:wantsResponderID|                            |
         } // Insert
 
         var created = createFiberFromElement(element, returnFiber.mode, lanes);
-        created.ref = coerceRef(returnFiber, current, element);
+        coerceRef(returnFiber, current, created, element);
         created.return = returnFiber;
+
+        {
+          created._debugInfo = debugInfo;
+        }
+
         return created;
       }
 
-      function updatePortal(returnFiber, current, portal, lanes) {
+      function updatePortal(returnFiber, current, portal, lanes, debugInfo) {
         if (
           current === null ||
           current.tag !== HostPortal ||
@@ -9081,16 +8527,33 @@ to return true:wantsResponderID|                            |
           // Insert
           var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
           created.return = returnFiber;
+
+          {
+            created._debugInfo = debugInfo;
+          }
+
           return created;
         } else {
           // Update
           var existing = useFiber(current, portal.children || []);
           existing.return = returnFiber;
+
+          {
+            existing._debugInfo = debugInfo;
+          }
+
           return existing;
         }
       }
 
-      function updateFragment(returnFiber, current, fragment, lanes, key) {
+      function updateFragment(
+        returnFiber,
+        current,
+        fragment,
+        lanes,
+        key,
+        debugInfo
+      ) {
         if (current === null || current.tag !== Fragment) {
           // Insert
           var created = createFiberFromFragment(
@@ -9100,29 +8563,46 @@ to return true:wantsResponderID|                            |
             key
           );
           created.return = returnFiber;
+
+          {
+            created._debugInfo = debugInfo;
+          }
+
           return created;
         } else {
           // Update
           var existing = useFiber(current, fragment);
           existing.return = returnFiber;
+
+          {
+            existing._debugInfo = debugInfo;
+          }
+
           return existing;
         }
       }
 
-      function createChild(returnFiber, newChild, lanes) {
+      function createChild(returnFiber, newChild, lanes, debugInfo) {
         if (
           (typeof newChild === "string" && newChild !== "") ||
-          typeof newChild === "number"
+          typeof newChild === "number" ||
+          enableBigIntSupport
         ) {
           // Text nodes don't have keys. If the previous node is implicitly keyed
           // we can continue to replace it without aborting even if it is not a text
           // node.
           var created = createFiberFromText(
+            // $FlowFixMe[unsafe-addition] Flow doesn't want us to use `+` operator with string and bigint
             "" + newChild,
             returnFiber.mode,
             lanes
           );
           created.return = returnFiber;
+
+          {
+            created._debugInfo = debugInfo;
+          }
+
           return created;
         }
 
@@ -9135,8 +8615,16 @@ to return true:wantsResponderID|                            |
                 lanes
               );
 
-              _created.ref = coerceRef(returnFiber, null, newChild);
+              coerceRef(returnFiber, null, _created, newChild);
               _created.return = returnFiber;
+
+              {
+                _created._debugInfo = mergeDebugInfo(
+                  debugInfo,
+                  newChild._debugInfo
+                );
+              }
+
               return _created;
             }
 
@@ -9148,13 +8636,23 @@ to return true:wantsResponderID|                            |
               );
 
               _created2.return = returnFiber;
+
+              {
+                _created2._debugInfo = debugInfo;
+              }
+
               return _created2;
             }
 
             case REACT_LAZY_TYPE: {
               var payload = newChild._payload;
               var init = newChild._init;
-              return createChild(returnFiber, init(payload), lanes);
+              return createChild(
+                returnFiber,
+                init(payload),
+                lanes,
+                mergeDebugInfo(debugInfo, newChild._debugInfo) // call merge after init
+              );
             }
           }
 
@@ -9167,6 +8665,14 @@ to return true:wantsResponderID|                            |
             );
 
             _created3.return = returnFiber;
+
+            {
+              _created3._debugInfo = mergeDebugInfo(
+                debugInfo,
+                newChild._debugInfo
+              );
+            }
+
             return _created3;
           } // Usable node types
           //
@@ -9174,15 +8680,21 @@ to return true:wantsResponderID|                            |
 
           if (typeof newChild.then === "function") {
             var thenable = newChild;
-            return createChild(returnFiber, unwrapThenable(thenable), lanes);
+            return createChild(
+              returnFiber,
+              unwrapThenable(thenable),
+              lanes,
+              mergeDebugInfo(debugInfo, newChild._debugInfo)
+            );
           }
 
           if (newChild.$$typeof === REACT_CONTEXT_TYPE) {
             var context = newChild;
             return createChild(
               returnFiber,
-              readContextDuringReconcilation(returnFiber, context, lanes),
-              lanes
+              readContextDuringReconciliation(returnFiber, context, lanes),
+              lanes,
+              debugInfo
             );
           }
 
@@ -9191,20 +8703,25 @@ to return true:wantsResponderID|                            |
 
         {
           if (typeof newChild === "function") {
-            warnOnFunctionType(returnFiber);
+            warnOnFunctionType(returnFiber, newChild);
+          }
+
+          if (typeof newChild === "symbol") {
+            warnOnSymbolType(returnFiber, newChild);
           }
         }
 
         return null;
       }
 
-      function updateSlot(returnFiber, oldFiber, newChild, lanes) {
+      function updateSlot(returnFiber, oldFiber, newChild, lanes, debugInfo) {
         // Update the fiber if the keys match, otherwise return null.
         var key = oldFiber !== null ? oldFiber.key : null;
 
         if (
           (typeof newChild === "string" && newChild !== "") ||
-          typeof newChild === "number"
+          typeof newChild === "number" ||
+          enableBigIntSupport
         ) {
           // Text nodes don't have keys. If the previous node is implicitly keyed
           // we can continue to replace it without aborting even if it is not a text
@@ -9213,14 +8730,26 @@ to return true:wantsResponderID|                            |
             return null;
           }
 
-          return updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
+          return updateTextNode(
+            returnFiber,
+            oldFiber, // $FlowFixMe[unsafe-addition] Flow doesn't want us to use `+` operator with string and bigint
+            "" + newChild,
+            lanes,
+            debugInfo
+          );
         }
 
         if (typeof newChild === "object" && newChild !== null) {
           switch (newChild.$$typeof) {
             case REACT_ELEMENT_TYPE: {
               if (newChild.key === key) {
-                return updateElement(returnFiber, oldFiber, newChild, lanes);
+                return updateElement(
+                  returnFiber,
+                  oldFiber,
+                  newChild,
+                  lanes,
+                  mergeDebugInfo(debugInfo, newChild._debugInfo)
+                );
               } else {
                 return null;
               }
@@ -9228,7 +8757,13 @@ to return true:wantsResponderID|                            |
 
             case REACT_PORTAL_TYPE: {
               if (newChild.key === key) {
-                return updatePortal(returnFiber, oldFiber, newChild, lanes);
+                return updatePortal(
+                  returnFiber,
+                  oldFiber,
+                  newChild,
+                  lanes,
+                  debugInfo
+                );
               } else {
                 return null;
               }
@@ -9237,7 +8772,13 @@ to return true:wantsResponderID|                            |
             case REACT_LAZY_TYPE: {
               var payload = newChild._payload;
               var init = newChild._init;
-              return updateSlot(returnFiber, oldFiber, init(payload), lanes);
+              return updateSlot(
+                returnFiber,
+                oldFiber,
+                init(payload),
+                lanes,
+                mergeDebugInfo(debugInfo, newChild._debugInfo)
+              );
             }
           }
 
@@ -9246,7 +8787,14 @@ to return true:wantsResponderID|                            |
               return null;
             }
 
-            return updateFragment(returnFiber, oldFiber, newChild, lanes, null);
+            return updateFragment(
+              returnFiber,
+              oldFiber,
+              newChild,
+              lanes,
+              null,
+              mergeDebugInfo(debugInfo, newChild._debugInfo)
+            );
           } // Usable node types
           //
           // Unwrap the inner value and recursively call this function again.
@@ -9257,7 +8805,8 @@ to return true:wantsResponderID|                            |
               returnFiber,
               oldFiber,
               unwrapThenable(thenable),
-              lanes
+              lanes,
+              debugInfo
             );
           }
 
@@ -9266,8 +8815,9 @@ to return true:wantsResponderID|                            |
             return updateSlot(
               returnFiber,
               oldFiber,
-              readContextDuringReconcilation(returnFiber, context, lanes),
-              lanes
+              readContextDuringReconciliation(returnFiber, context, lanes),
+              lanes,
+              debugInfo
             );
           }
 
@@ -9276,7 +8826,11 @@ to return true:wantsResponderID|                            |
 
         {
           if (typeof newChild === "function") {
-            warnOnFunctionType(returnFiber);
+            warnOnFunctionType(returnFiber, newChild);
+          }
+
+          if (typeof newChild === "symbol") {
+            warnOnSymbolType(returnFiber, newChild);
           }
         }
 
@@ -9288,20 +8842,23 @@ to return true:wantsResponderID|                            |
         returnFiber,
         newIdx,
         newChild,
-        lanes
+        lanes,
+        debugInfo
       ) {
         if (
           (typeof newChild === "string" && newChild !== "") ||
-          typeof newChild === "number"
+          typeof newChild === "number" ||
+          enableBigIntSupport
         ) {
           // Text nodes don't have keys, so we neither have to check the old nor
           // new node for the key. If both are text nodes, they match.
           var matchedFiber = existingChildren.get(newIdx) || null;
           return updateTextNode(
             returnFiber,
-            matchedFiber,
+            matchedFiber, // $FlowFixMe[unsafe-addition] Flow doesn't want us to use `+` operator with string and bigint
             "" + newChild,
-            lanes
+            lanes,
+            debugInfo
           );
         }
 
@@ -9313,7 +8870,13 @@ to return true:wantsResponderID|                            |
                   newChild.key === null ? newIdx : newChild.key
                 ) || null;
 
-              return updateElement(returnFiber, _matchedFiber, newChild, lanes);
+              return updateElement(
+                returnFiber,
+                _matchedFiber,
+                newChild,
+                lanes,
+                mergeDebugInfo(debugInfo, newChild._debugInfo)
+              );
             }
 
             case REACT_PORTAL_TYPE: {
@@ -9322,7 +8885,13 @@ to return true:wantsResponderID|                            |
                   newChild.key === null ? newIdx : newChild.key
                 ) || null;
 
-              return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
+              return updatePortal(
+                returnFiber,
+                _matchedFiber2,
+                newChild,
+                lanes,
+                debugInfo
+              );
             }
 
             case REACT_LAZY_TYPE:
@@ -9333,7 +8902,8 @@ to return true:wantsResponderID|                            |
                 returnFiber,
                 newIdx,
                 init(payload),
-                lanes
+                lanes,
+                mergeDebugInfo(debugInfo, newChild._debugInfo)
               );
           }
 
@@ -9345,7 +8915,8 @@ to return true:wantsResponderID|                            |
               _matchedFiber3,
               newChild,
               lanes,
-              null
+              null,
+              mergeDebugInfo(debugInfo, newChild._debugInfo)
             );
           } // Usable node types
           //
@@ -9358,7 +8929,8 @@ to return true:wantsResponderID|                            |
               returnFiber,
               newIdx,
               unwrapThenable(thenable),
-              lanes
+              lanes,
+              debugInfo
             );
           }
 
@@ -9368,8 +8940,9 @@ to return true:wantsResponderID|                            |
               existingChildren,
               returnFiber,
               newIdx,
-              readContextDuringReconcilation(returnFiber, context, lanes),
-              lanes
+              readContextDuringReconciliation(returnFiber, context, lanes),
+              lanes,
+              debugInfo
             );
           }
 
@@ -9378,7 +8951,11 @@ to return true:wantsResponderID|                            |
 
         {
           if (typeof newChild === "function") {
-            warnOnFunctionType(returnFiber);
+            warnOnFunctionType(returnFiber, newChild);
+          }
+
+          if (typeof newChild === "symbol") {
+            warnOnSymbolType(returnFiber, newChild);
           }
         }
 
@@ -9441,7 +9018,8 @@ to return true:wantsResponderID|                            |
         returnFiber,
         currentFirstChild,
         newChildren,
-        lanes
+        lanes,
+        debugInfo
       ) {
         // This algorithm can't optimize by searching from both ends since we
         // don't have backpointers on fibers. I'm trying to see how far we can get
@@ -9487,7 +9065,8 @@ to return true:wantsResponderID|                            |
             returnFiber,
             oldFiber,
             newChildren[newIdx],
-            lanes
+            lanes,
+            debugInfo
           );
 
           if (newFiber === null) {
@@ -9541,7 +9120,8 @@ to return true:wantsResponderID|                            |
             var _newFiber = createChild(
               returnFiber,
               newChildren[newIdx],
-              lanes
+              lanes,
+              debugInfo
             );
 
             if (_newFiber === null) {
@@ -9563,7 +9143,7 @@ to return true:wantsResponderID|                            |
           return resultingFirstChild;
         } // Add all children to a key map for quick lookups.
 
-        var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.
+        var existingChildren = mapRemainingChildren(oldFiber); // Keep scanning and use the map to restore deleted items as moves.
 
         for (; newIdx < newChildren.length; newIdx++) {
           var _newFiber2 = updateFromMap(
@@ -9571,7 +9151,8 @@ to return true:wantsResponderID|                            |
             returnFiber,
             newIdx,
             newChildren[newIdx],
-            lanes
+            lanes,
+            debugInfo
           );
 
           if (_newFiber2 !== null) {
@@ -9614,7 +9195,8 @@ to return true:wantsResponderID|                            |
         returnFiber,
         currentFirstChild,
         newChildrenIterable,
-        lanes
+        lanes,
+        debugInfo
       ) {
         // This is the same implementation as reconcileChildrenArray(),
         // but using the iterator instead.
@@ -9699,7 +9281,13 @@ to return true:wantsResponderID|                            |
             nextOldFiber = oldFiber.sibling;
           }
 
-          var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
+          var newFiber = updateSlot(
+            returnFiber,
+            oldFiber,
+            step.value,
+            lanes,
+            debugInfo
+          );
 
           if (newFiber === null) {
             // TODO: This breaks on empty slots like null children. That's
@@ -9749,7 +9337,12 @@ to return true:wantsResponderID|                            |
           // If we don't have any more existing children we can choose a fast path
           // since the rest will all be insertions.
           for (; !step.done; newIdx++, step = newChildren.next()) {
-            var _newFiber3 = createChild(returnFiber, step.value, lanes);
+            var _newFiber3 = createChild(
+              returnFiber,
+              step.value,
+              lanes,
+              debugInfo
+            );
 
             if (_newFiber3 === null) {
               continue;
@@ -9770,7 +9363,7 @@ to return true:wantsResponderID|                            |
           return resultingFirstChild;
         } // Add all children to a key map for quick lookups.
 
-        var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.
+        var existingChildren = mapRemainingChildren(oldFiber); // Keep scanning and use the map to restore deleted items as moves.
 
         for (; !step.done; newIdx++, step = newChildren.next()) {
           var _newFiber4 = updateFromMap(
@@ -9778,7 +9371,8 @@ to return true:wantsResponderID|                            |
             returnFiber,
             newIdx,
             step.value,
-            lanes
+            lanes,
+            debugInfo
           );
 
           if (_newFiber4 !== null) {
@@ -9845,7 +9439,8 @@ to return true:wantsResponderID|                            |
         returnFiber,
         currentFirstChild,
         element,
-        lanes
+        lanes,
+        debugInfo
       ) {
         var key = element.key;
         var child = currentFirstChild;
@@ -9864,6 +9459,7 @@ to return true:wantsResponderID|                            |
 
                 {
                   existing._debugOwner = element._owner;
+                  existing._debugInfo = debugInfo;
                 }
 
                 return existing;
@@ -9884,11 +9480,12 @@ to return true:wantsResponderID|                            |
 
                 var _existing = useFiber(child, element.props);
 
-                _existing.ref = coerceRef(returnFiber, child, element);
+                coerceRef(returnFiber, child, _existing, element);
                 _existing.return = returnFiber;
 
                 {
                   _existing._debugOwner = element._owner;
+                  _existing._debugInfo = debugInfo;
                 }
 
                 return _existing;
@@ -9912,6 +9509,11 @@ to return true:wantsResponderID|                            |
             element.key
           );
           created.return = returnFiber;
+
+          {
+            created._debugInfo = debugInfo;
+          }
+
           return created;
         } else {
           var _created4 = createFiberFromElement(
@@ -9920,8 +9522,13 @@ to return true:wantsResponderID|                            |
             lanes
           );
 
-          _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
+          coerceRef(returnFiber, currentFirstChild, _created4, element);
           _created4.return = returnFiber;
+
+          {
+            _created4._debugInfo = debugInfo;
+          }
+
           return _created4;
         }
       }
@@ -9930,7 +9537,8 @@ to return true:wantsResponderID|                            |
         returnFiber,
         currentFirstChild,
         portal,
-        lanes
+        lanes,
+        debugInfo
       ) {
         var key = portal.key;
         var child = currentFirstChild;
@@ -9970,7 +9578,8 @@ to return true:wantsResponderID|                            |
         returnFiber,
         currentFirstChild,
         newChild,
-        lanes
+        lanes,
+        debugInfo
       ) {
         // This function is not recursive.
         // If the top level item is an array, we treat it as a set of children,
@@ -9998,7 +9607,8 @@ to return true:wantsResponderID|                            |
                   returnFiber,
                   currentFirstChild,
                   newChild,
-                  lanes
+                  lanes,
+                  mergeDebugInfo(debugInfo, newChild._debugInfo)
                 )
               );
 
@@ -10014,13 +9624,13 @@ to return true:wantsResponderID|                            |
 
             case REACT_LAZY_TYPE:
               var payload = newChild._payload;
-              var init = newChild._init; // TODO: This function is supposed to be non-recursive.
-
-              return reconcileChildFibers(
+              var init = newChild._init;
+              return reconcileChildFibersImpl(
                 returnFiber,
                 currentFirstChild,
                 init(payload),
-                lanes
+                lanes,
+                mergeDebugInfo(debugInfo, newChild._debugInfo)
               );
           }
 
@@ -10029,7 +9639,8 @@ to return true:wantsResponderID|                            |
               returnFiber,
               currentFirstChild,
               newChild,
-              lanes
+              lanes,
+              mergeDebugInfo(debugInfo, newChild._debugInfo)
             );
           }
 
@@ -10038,7 +9649,8 @@ to return true:wantsResponderID|                            |
               returnFiber,
               currentFirstChild,
               newChild,
-              lanes
+              lanes,
+              mergeDebugInfo(debugInfo, newChild._debugInfo)
             );
           } // Usables are a valid React node type. When React encounters a Usable in
           // a child position, it unwraps it using the same algorithm as `use`. For
@@ -10063,7 +9675,8 @@ to return true:wantsResponderID|                            |
               returnFiber,
               currentFirstChild,
               unwrapThenable(thenable),
-              lanes
+              lanes,
+              mergeDebugInfo(debugInfo, thenable._debugInfo)
             );
           }
 
@@ -10072,8 +9685,9 @@ to return true:wantsResponderID|                            |
             return reconcileChildFibersImpl(
               returnFiber,
               currentFirstChild,
-              readContextDuringReconcilation(returnFiber, context, lanes),
-              lanes
+              readContextDuringReconciliation(returnFiber, context, lanes),
+              lanes,
+              debugInfo
             );
           }
 
@@ -10082,12 +9696,13 @@ to return true:wantsResponderID|                            |
 
         if (
           (typeof newChild === "string" && newChild !== "") ||
-          typeof newChild === "number"
+          typeof newChild === "number" ||
+          enableBigIntSupport
         ) {
           return placeSingleChild(
             reconcileSingleTextNode(
               returnFiber,
-              currentFirstChild,
+              currentFirstChild, // $FlowFixMe[unsafe-addition] Flow doesn't want us to use `+` operator with string and bigint
               "" + newChild,
               lanes
             )
@@ -10096,7 +9711,11 @@ to return true:wantsResponderID|                            |
 
         {
           if (typeof newChild === "function") {
-            warnOnFunctionType(returnFiber);
+            warnOnFunctionType(returnFiber, newChild);
+          }
+
+          if (typeof newChild === "symbol") {
+            warnOnSymbolType(returnFiber, newChild);
           }
         } // Remaining cases are all treated as empty.
 
@@ -10116,7 +9735,8 @@ to return true:wantsResponderID|                            |
           returnFiber,
           currentFirstChild,
           newChild,
-          lanes
+          lanes,
+          null // debugInfo
         );
         thenableState$1 = null; // Don't bother to reset `thenableIndexCounter` to 0 because it always gets
         // set at the beginning.
@@ -10552,7 +10172,7 @@ to return true:wantsResponderID|                            |
             error(
               "React has detected a change in the order of Hooks called by %s. " +
                 "This will lead to bugs and errors if not fixed. " +
-                "For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n" +
+                "For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\n\n" +
                 "   Previous render            Next render\n" +
                 "   ------------------------------------------------------\n" +
                 "%s" +
@@ -10603,7 +10223,7 @@ to return true:wantsResponderID|                            |
           "1. You might have mismatching versions of React and the renderer (such as React DOM)\n" +
           "2. You might be breaking the Rules of Hooks\n" +
           "3. You might have more than one copy of React in the same app\n" +
-          "See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem."
+          "See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
       );
     }
 
@@ -12175,8 +11795,8 @@ to return true:wantsResponderID|                            |
     }
 
     function updateTransition() {
-      var _updateState = updateState(),
-        booleanOrThenable = _updateState[0];
+      var _updateState2 = updateState(),
+        booleanOrThenable = _updateState2[0];
 
       var hook = updateWorkInProgressHook();
       var start = hook.memoizedState;
@@ -12435,7 +12055,7 @@ to return true:wantsResponderID|                            |
           "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. " +
             "You can only call Hooks at the top level of your React function. " +
             "For more information, see " +
-            "https://reactjs.org/link/rules-of-hooks"
+            "https://react.dev/link/rules-of-hooks"
         );
       };
 
@@ -13464,7 +13084,6 @@ to return true:wantsResponderID|                            |
     var didWarnAboutLegacyLifecyclesAndDerivedState;
     var didWarnAboutUndefinedDerivedState;
     var didWarnAboutDirectlyAssigningPropsToState;
-    var didWarnAboutContextTypeAndContextTypes;
     var didWarnAboutInvalidateContextType;
     var didWarnOnInvalidCallback;
 
@@ -13475,7 +13094,6 @@ to return true:wantsResponderID|                            |
       didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
       didWarnAboutDirectlyAssigningPropsToState = new Set();
       didWarnAboutUndefinedDerivedState = new Set();
-      didWarnAboutContextTypeAndContextTypes = new Set();
       didWarnAboutInvalidateContextType = new Set();
       didWarnOnInvalidCallback = new Set(); // This is so gross but it's at least non-critical and can be removed if
       // it causes problems. This is meant to give a nicer error message for
@@ -13499,21 +13117,20 @@ to return true:wantsResponderID|                            |
       Object.freeze(fakeInternalInstance);
     }
 
-    function warnOnInvalidCallback(callback, callerName) {
+    function warnOnInvalidCallback(callback) {
       {
         if (callback === null || typeof callback === "function") {
           return;
-        }
+        } // eslint-disable-next-line react-internal/safe-string-coercion
 
-        var key = callerName + "_" + callback;
+        var key = String(callback);
 
         if (!didWarnOnInvalidCallback.has(key)) {
           didWarnOnInvalidCallback.add(key);
 
           error(
-            "%s(...): Expected the last optional `callback` argument to be a " +
+            "Expected the last optional `callback` argument to be a " +
               "function. Instead received: %s.",
-            callerName,
             callback
           );
         }
@@ -13587,7 +13204,7 @@ to return true:wantsResponderID|                            |
 
         if (callback !== undefined && callback !== null) {
           {
-            warnOnInvalidCallback(callback, "setState");
+            warnOnInvalidCallback(callback);
           }
 
           update.callback = callback;
@@ -13609,7 +13226,7 @@ to return true:wantsResponderID|                            |
 
         if (callback !== undefined && callback !== null) {
           {
-            warnOnInvalidCallback(callback, "replaceState");
+            warnOnInvalidCallback(callback);
           }
 
           update.callback = callback;
@@ -13631,7 +13248,7 @@ to return true:wantsResponderID|                            |
 
         if (callback !== undefined && callback !== null) {
           {
-            warnOnInvalidCallback(callback, "forceUpdate");
+            warnOnInvalidCallback(callback);
           }
 
           update.callback = callback;
@@ -13711,13 +13328,13 @@ to return true:wantsResponderID|                            |
         if (!renderPresent) {
           if (ctor.prototype && typeof ctor.prototype.render === "function") {
             error(
-              "%s(...): No `render` method found on the returned component " +
+              "No `render` method found on the %s " +
                 "instance: did you accidentally return an object from the constructor?",
               name
             );
           } else {
             error(
-              "%s(...): No `render` method found on the returned component " +
+              "No `render` method found on the %s " +
                 "instance: you may have forgotten to define `render`.",
               name
             );
@@ -13766,24 +13383,18 @@ to return true:wantsResponderID|                            |
         }
 
         {
-          if (instance.contextTypes) {
+          if (ctor.childContextTypes) {
             error(
-              "contextTypes was defined as an instance property on %s. Use a static " +
-                "property to define contextTypes instead.",
+              "%s uses the legacy childContextTypes API which is no longer supported. " +
+                "Use React.createContext() instead.",
               name
             );
           }
 
-          if (
-            ctor.contextType &&
-            ctor.contextTypes &&
-            !didWarnAboutContextTypeAndContextTypes.has(ctor)
-          ) {
-            didWarnAboutContextTypeAndContextTypes.add(ctor);
-
+          if (ctor.contextTypes) {
             error(
-              "%s declares both contextTypes and contextType static properties. " +
-                "The legacy contextTypes property will be ignored.",
+              "%s uses the legacy contextTypes API which is no longer supported. " +
+                "Use React.createContext() with static contextType instead.",
               name
             );
           }
@@ -13852,9 +13463,8 @@ to return true:wantsResponderID|                            |
 
         if (instance.props !== undefined && hasMutatedProps) {
           error(
-            "%s(...): When calling super() in `%s`, make sure to pass " +
+            "When calling super() in `%s`, make sure to pass " +
               "up the same props that your component's constructor was passed.",
-            name,
             name
           );
         }
@@ -13937,8 +13547,6 @@ to return true:wantsResponderID|                            |
     }
 
     function constructClassInstance(workInProgress, ctor, props) {
-      var isLegacyContextConsumer = false;
-      var unmaskedContext = emptyContextObject;
       var context = emptyContextObject;
       var contextType = ctor.contextType;
 
@@ -13947,8 +13555,7 @@ to return true:wantsResponderID|                            |
           var isValid = // Allow null for conditional declaration
             contextType === null ||
             (contextType !== undefined &&
-              contextType.$$typeof === REACT_CONTEXT_TYPE &&
-              contextType._context === undefined); // Not a <Context.Consumer>
+              contextType.$$typeof === REACT_CONTEXT_TYPE);
 
           if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
             didWarnAboutInvalidateContextType.add(ctor);
@@ -13962,11 +13569,7 @@ to return true:wantsResponderID|                            |
                 "try moving the createContext() call to a separate file.";
             } else if (typeof contextType !== "object") {
               addendum = " However, it is set to a " + typeof contextType + ".";
-            } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
-              addendum =
-                " Did you accidentally pass the Context.Provider instead?";
-            } else if (contextType._context !== undefined) {
-              // <Context.Consumer>
+            } else if (contextType.$$typeof === REACT_CONSUMER_TYPE) {
               addendum =
                 " Did you accidentally pass the Context.Consumer instead?";
             } else {
@@ -13988,14 +13591,6 @@ to return true:wantsResponderID|                            |
 
       if (typeof contextType === "object" && contextType !== null) {
         context = readContext(contextType);
-      } else {
-        unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
-        var contextTypes = ctor.contextTypes;
-        isLegacyContextConsumer =
-          contextTypes !== null && contextTypes !== undefined;
-        context = isLegacyContextConsumer
-          ? getMaskedContext(workInProgress, unmaskedContext)
-          : emptyContextObject;
       }
 
       var instance = new ctor(props, context); // Instantiate twice to help detect side-effects.
@@ -14103,7 +13698,7 @@ to return true:wantsResponderID|                            |
                 "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n" +
                   "%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n" +
                   "The above lifecycles should be removed. Learn more about this warning here:\n" +
-                  "https://reactjs.org/link/unsafe-component-lifecycles",
+                  "https://react.dev/link/unsafe-component-lifecycles",
                 _componentName,
                 newApiName,
                 foundWillMountName !== null ? "\n  " + foundWillMountName : "",
@@ -14116,11 +13711,6 @@ to return true:wantsResponderID|                            |
           }
         }
       } // Cache unmasked context so we can avoid recreating masked context unless necessary.
-      // ReactFiberContext usually updates this cache but can't for newly-created instances.
-
-      if (isLegacyContextConsumer) {
-        cacheContext(workInProgress, unmaskedContext, context);
-      }
 
       return instance;
     }
@@ -14210,8 +13800,7 @@ to return true:wantsResponderID|                            |
       if (typeof contextType === "object" && contextType !== null) {
         instance.context = readContext(contextType);
       } else {
-        var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
-        instance.context = getMaskedContext(workInProgress, unmaskedContext);
+        instance.context = emptyContextObject;
       }
 
       {
@@ -14289,22 +13878,12 @@ to return true:wantsResponderID|                            |
       var instance = workInProgress.stateNode;
       var oldProps = workInProgress.memoizedProps;
       instance.props = oldProps;
-      var oldContext = instance.context;
-      var contextType = ctor.contextType;
-      var nextContext = emptyContextObject;
-
-      if (typeof contextType === "object" && contextType !== null) {
-        nextContext = readContext(contextType);
-      } else {
-        var nextLegacyUnmaskedContext = getUnmaskedContext(
-          workInProgress,
-          ctor,
-          true
-        );
-        nextContext = getMaskedContext(
-          workInProgress,
-          nextLegacyUnmaskedContext
-        );
+      var oldContext = instance.context;
+      var contextType = ctor.contextType;
+      var nextContext = emptyContextObject;
+
+      if (typeof contextType === "object" && contextType !== null) {
+        nextContext = readContext(contextType);
       }
 
       var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
@@ -14448,13 +14027,6 @@ to return true:wantsResponderID|                            |
 
       if (typeof contextType === "object" && contextType !== null) {
         nextContext = readContext(contextType);
-      } else {
-        var nextUnmaskedContext = getUnmaskedContext(
-          workInProgress,
-          ctor,
-          true
-        );
-        nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);
       }
 
       var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
@@ -14608,17 +14180,37 @@ to return true:wantsResponderID|                            |
       return shouldUpdate;
     }
 
+    var CapturedStacks = new WeakMap();
     function createCapturedValueAtFiber(value, source) {
       // If the value is an error, call this function immediately after it is thrown
       // so the stack is accurate.
+      var stack;
+
+      if (typeof value === "object" && value !== null) {
+        var capturedStack = CapturedStacks.get(value);
+
+        if (typeof capturedStack === "string") {
+          stack = capturedStack;
+        } else {
+          stack = getStackByFiberInDevAndProd(source);
+          CapturedStacks.set(value, stack);
+        }
+      } else {
+        stack = getStackByFiberInDevAndProd(source);
+      }
+
       return {
         value: value,
         source: source,
-        stack: getStackByFiberInDevAndProd(source),
+        stack: stack,
         digest: null
       };
     }
-    function createCapturedValue(value, digest, stack) {
+    function createCapturedValueFromError(value, digest, stack) {
+      if (typeof stack === "string") {
+        CapturedStacks.set(value, stack);
+      }
+
       return {
         value: value,
         source: null,
@@ -14664,25 +14256,8 @@ to return true:wantsResponderID|                            |
         if (true) {
           var source = errorInfo.source;
           var stack = errorInfo.stack;
-          var componentStack = stack !== null ? stack : ""; // Browsers support silencing uncaught errors by calling
-          // `preventDefault()` in window `error` handler.
-          // We record this information as an expando on the error.
-
-          if (error != null && error._suppressLogging) {
-            if (boundary.tag === ClassComponent) {
-              // The error is recoverable and was silenced.
-              // Ignore it and don't print the stack addendum.
-              // This is handy for testing error boundaries without noise.
-              return;
-            } // The error is fatal. Since the silencing might have
-            // been accidental, we'll surface it anyway.
-            // However, the browser would have silenced the original error
-            // so we'll print it first, and then print the stack addendum.
-
-            console["error"](error); // Don't transform to our wrapper
-            // For a more detailed description of this block, see:
-            // https://github.com/facebook/react/pull/13384
-          }
+          var componentStack = stack !== null ? stack : ""; // TODO: There's no longer a way to silence these warnings e.g. for tests.
+          // See https://github.com/facebook/react/pull/13384
 
           var componentName = source ? getComponentNameFromFiber(source) : null;
           var componentNameMessage = componentName
@@ -14695,7 +14270,7 @@ to return true:wantsResponderID|                            |
           if (boundary.tag === HostRoot) {
             errorBoundaryMessage =
               "Consider adding an error boundary to your tree to customize error handling behavior.\n" +
-              "Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.";
+              "Visit https://react.dev/link/error-boundaries to learn more about error boundaries.";
           } else {
             var errorBoundaryName =
               getComponentNameFromFiber(boundary) || "Anonymous";
@@ -14704,19 +14279,17 @@ to return true:wantsResponderID|                            |
               ("using the error boundary you provided, " +
                 errorBoundaryName +
                 ".");
-          }
-
-          var combinedMessage =
-            componentNameMessage +
-            "\n" +
-            componentStack +
-            "\n\n" +
-            ("" + errorBoundaryMessage); // In development, we provide our own message with just the component stack.
-          // We don't include the original error message and JS stack because the browser
-          // has already printed it. Even if the application swallows the error, it is still
-          // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
-
-          console["error"](combinedMessage); // Don't transform to our wrapper
+          } // In development, we provide our own message which includes the component stack
+          // in addition to the error.
+
+          console["error"](
+            // Don't transform to our wrapper
+            "%o\n\n%s\n%s\n\n%s",
+            error,
+            componentNameMessage,
+            componentStack,
+            errorBoundaryMessage
+          );
         }
       } catch (e) {
         // This method must not throw, or React internal state will get messed up.
@@ -15307,25 +14880,13 @@ to return true:wantsResponderID|                            |
       // TODO: current can be non-null here even if the component
       // hasn't yet mounted. This happens after the first render suspends.
       // We'll need to figure out if this is fine or can cause issues.
-      {
-        if (workInProgress.type !== workInProgress.elementType) {
-          // Lazy component props can't be validated in createElement
-          // because they're only guaranteed to be resolved here.
-          var innerPropTypes = Component.propTypes;
-
-          if (innerPropTypes) {
-            checkPropTypes(
-              innerPropTypes,
-              nextProps, // Resolved props
-              "prop",
-              getComponentNameFromType(Component)
-            );
-          }
-        }
-      }
-
       var render = Component.render;
-      var ref = workInProgress.ref; // The rest is a fork of updateFunctionComponent
+      var ref = workInProgress.ref;
+      var propsWithoutRef;
+
+      {
+        propsWithoutRef = nextProps;
+      } // The rest is a fork of updateFunctionComponent
 
       var nextChildren;
       prepareToReadContext(workInProgress, renderLanes);
@@ -15337,7 +14898,7 @@ to return true:wantsResponderID|                            |
           current,
           workInProgress,
           render,
-          nextProps,
+          propsWithoutRef,
           ref,
           renderLanes
         );
@@ -15398,19 +14959,6 @@ to return true:wantsResponderID|                            |
         }
 
         {
-          var innerPropTypes = type.propTypes;
-
-          if (innerPropTypes) {
-            // Inner memo component props aren't currently validated in createElement.
-            // We could move it there, but we'd still need this for lazy code path.
-            checkPropTypes(
-              innerPropTypes,
-              nextProps, // Resolved props
-              "prop",
-              getComponentNameFromType(type)
-            );
-          }
-
           if (Component.defaultProps !== undefined) {
             var componentName = getComponentNameFromType(type) || "Unknown";
 
@@ -15440,22 +14988,6 @@ to return true:wantsResponderID|                            |
         return child;
       }
 
-      {
-        var _type = Component.type;
-        var _innerPropTypes = _type.propTypes;
-
-        if (_innerPropTypes) {
-          // Inner memo component props aren't currently validated in createElement.
-          // We could move it there, but we'd still need this for lazy code path.
-          checkPropTypes(
-            _innerPropTypes,
-            nextProps, // Resolved props
-            "prop",
-            getComponentNameFromType(_type)
-          );
-        }
-      }
-
       var currentChild = current.child; // This is always exactly one child
 
       var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(
@@ -15501,40 +15033,6 @@ to return true:wantsResponderID|                            |
       // TODO: current can be non-null here even if the component
       // hasn't yet mounted. This happens when the inner render suspends.
       // We'll need to figure out if this is fine or can cause issues.
-      {
-        if (workInProgress.type !== workInProgress.elementType) {
-          // Lazy component props can't be validated in createElement
-          // because they're only guaranteed to be resolved here.
-          var outerMemoType = workInProgress.elementType;
-
-          if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
-            // We warn when you define propTypes on lazy()
-            // so let's just skip over it to find memo() outer wrapper.
-            // Inner props for memo are validated later.
-            var lazyComponent = outerMemoType;
-            var payload = lazyComponent._payload;
-            var init = lazyComponent._init;
-
-            try {
-              outerMemoType = init(payload);
-            } catch (x) {
-              outerMemoType = null;
-            } // Inner propTypes will be validated in the function component path.
-
-            var outerPropTypes = outerMemoType && outerMemoType.propTypes;
-
-            if (outerPropTypes) {
-              checkPropTypes(
-                outerPropTypes,
-                nextProps, // Resolved (SimpleMemoComponent has no defaultProps)
-                "prop",
-                getComponentNameFromType(outerMemoType)
-              );
-            }
-          }
-        }
-      }
-
       if (current !== null) {
         var prevProps = current.memoizedProps;
 
@@ -15607,7 +15105,7 @@ to return true:wantsResponderID|                            |
       var nextIsDetached =
         (workInProgress.stateNode._pendingVisibility & OffscreenDetached) !== 0;
       var prevState = current !== null ? current.memoizedState : null;
-      markRef$1(current, workInProgress);
+      markRef(current, workInProgress);
 
       if (nextProps.mode === "hidden" || enableLegacyHidden || nextIsDetached) {
         // Rendering a hidden tree.
@@ -15772,16 +15270,26 @@ to return true:wantsResponderID|                            |
       return workInProgress.child;
     }
 
-    function markRef$1(current, workInProgress) {
+    function markRef(current, workInProgress) {
+      // TODO: Check props.ref instead of fiber.ref when enableRefAsProp is on.
       var ref = workInProgress.ref;
 
-      if (
-        (current === null && ref !== null) ||
-        (current !== null && current.ref !== ref)
-      ) {
-        // Schedule a Ref effect
-        workInProgress.flags |= Ref;
-        workInProgress.flags |= RefStatic;
+      if (ref === null) {
+        if (current !== null && current.ref !== null) {
+          // Schedule a Ref effect
+          workInProgress.flags |= Ref | RefStatic;
+        }
+      } else {
+        if (typeof ref !== "function" && typeof ref !== "object") {
+          throw new Error(
+            "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
+          );
+        }
+
+        if (current === null || current.ref !== ref) {
+          // Schedule a Ref effect
+          workInProgress.flags |= Ref | RefStatic;
+        }
       }
     }
 
@@ -15792,34 +15300,8 @@ to return true:wantsResponderID|                            |
       nextProps,
       renderLanes
     ) {
-      {
-        if (workInProgress.type !== workInProgress.elementType) {
-          // Lazy component props can't be validated in createElement
-          // because they're only guaranteed to be resolved here.
-          var innerPropTypes = Component.propTypes;
-
-          if (innerPropTypes) {
-            checkPropTypes(
-              innerPropTypes,
-              nextProps, // Resolved props
-              "prop",
-              getComponentNameFromType(Component)
-            );
-          }
-        }
-      }
-
       var context;
 
-      {
-        var unmaskedContext = getUnmaskedContext(
-          workInProgress,
-          Component,
-          true
-        );
-        context = getMaskedContext(workInProgress, unmaskedContext);
-      }
-
       var nextChildren;
       prepareToReadContext(workInProgress, renderLanes);
 
@@ -15929,30 +15411,14 @@ to return true:wantsResponderID|                            |
             break;
           }
         }
-
-        if (workInProgress.type !== workInProgress.elementType) {
-          // Lazy component props can't be validated in createElement
-          // because they're only guaranteed to be resolved here.
-          var innerPropTypes = Component.propTypes;
-
-          if (innerPropTypes) {
-            checkPropTypes(
-              innerPropTypes,
-              nextProps, // Resolved props
-              "prop",
-              getComponentNameFromType(Component)
-            );
-          }
-        }
       } // Push context providers early to prevent context stack mismatches.
       // During mounting we don't know the child context yet as the instance doesn't exist.
       // We will invalidate the child context in finishClassComponent() right after rendering.
 
       var hasContext;
 
-      if (isContextProvider(Component)) {
+      if (isContextProvider()) {
         hasContext = true;
-        pushContextProvider(workInProgress);
       } else {
         hasContext = false;
       }
@@ -16022,15 +15488,10 @@ to return true:wantsResponderID|                            |
       renderLanes
     ) {
       // Refs should update even if shouldComponentUpdate returns false
-      markRef$1(current, workInProgress);
+      markRef(current, workInProgress);
       var didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags$1;
 
       if (!shouldUpdate && !didCaptureError) {
-        // Context providers should defer to sCU for rendering
-        if (hasContext) {
-          invalidateContextProvider(workInProgress, Component, false);
-        }
-
         return bailoutOnAlreadyFinishedWork(
           current,
           workInProgress,
@@ -16096,27 +15557,12 @@ to return true:wantsResponderID|                            |
 
       workInProgress.memoizedState = instance.state; // The context might have changed so we need to recalculate it.
 
-      if (hasContext) {
-        invalidateContextProvider(workInProgress, Component, true);
-      }
-
       return workInProgress.child;
     }
 
     function pushHostRootContext(workInProgress) {
       var root = workInProgress.stateNode;
 
-      if (root.pendingContext) {
-        pushTopLevelContextObject(
-          workInProgress,
-          root.pendingContext,
-          root.pendingContext !== root.context
-        );
-      } else if (root.context) {
-        // Should always be set
-        pushTopLevelContextObject(workInProgress, root.context, false);
-      }
-
       pushHostContainer(workInProgress, root.containerInfo);
     }
 
@@ -16168,7 +15614,7 @@ to return true:wantsResponderID|                            |
         workInProgress.flags |= ContentReset;
       }
 
-      markRef$1(current, workInProgress);
+      markRef(current, workInProgress);
       reconcileChildren(current, workInProgress, nextChildren, renderLanes);
       return workInProgress.child;
     }
@@ -16249,21 +15695,6 @@ to return true:wantsResponderID|                            |
         }
 
         case MemoComponent: {
-          {
-            if (workInProgress.type !== workInProgress.elementType) {
-              var outerPropTypes = Component.propTypes;
-
-              if (outerPropTypes) {
-                checkPropTypes(
-                  outerPropTypes,
-                  resolvedProps, // Resolved for outer only
-                  "prop",
-                  getComponentNameFromType(Component)
-                );
-              }
-            }
-          }
-
           child = updateMemoComponent(
             null,
             workInProgress,
@@ -16313,9 +15744,8 @@ to return true:wantsResponderID|                            |
 
       var hasContext;
 
-      if (isContextProvider(Component)) {
+      if (isContextProvider()) {
         hasContext = true;
-        pushContextProvider(workInProgress);
       } else {
         hasContext = false;
       }
@@ -16343,15 +15773,6 @@ to return true:wantsResponderID|                            |
       var props = workInProgress.pendingProps;
       var context;
 
-      {
-        var unmaskedContext = getUnmaskedContext(
-          workInProgress,
-          Component,
-          false
-        );
-        context = getMaskedContext(workInProgress, unmaskedContext);
-      }
-
       prepareToReadContext(workInProgress, renderLanes);
       var value;
 
@@ -16461,9 +15882,8 @@ to return true:wantsResponderID|                            |
 
         var hasContext = false;
 
-        if (isContextProvider(Component)) {
+        if (isContextProvider()) {
           hasContext = true;
-          pushContextProvider(workInProgress);
         } else {
           hasContext = false;
         }
@@ -16487,6 +15907,16 @@ to return true:wantsResponderID|                            |
         // Proceed under the assumption that this is a function component
         workInProgress.tag = FunctionComponent;
 
+        {
+          if (Component.contextTypes) {
+            error(
+              "%s uses the legacy contextTypes API which is no longer supported. " +
+                "Use React.createContext() with React.useContext() instead.",
+              getComponentNameFromType(Component) || "Unknown"
+            );
+          }
+        }
+
         reconcileChildren(null, workInProgress, value, renderLanes);
 
         {
@@ -16502,7 +15932,8 @@ to return true:wantsResponderID|                            |
         if (Component) {
           if (Component.childContextTypes) {
             error(
-              "%s(...): childContextTypes cannot be defined on a function component.",
+              "childContextTypes cannot be defined on a function component.\n" +
+                "  %s.childContextTypes = ...",
               Component.displayName || Component.name || "Component"
             );
           }
@@ -17136,7 +16567,7 @@ to return true:wantsResponderID|                            |
             }
 
             error.digest = digest;
-            capturedValue = createCapturedValue(error, digest, stack);
+            capturedValue = createCapturedValueFromError(error, digest, stack);
           }
 
           return retrySuspenseComponentWithoutHydrating(
@@ -17246,7 +16677,7 @@ to return true:wantsResponderID|                            |
           pushPrimaryTreeSuspenseHandler(workInProgress);
           workInProgress.flags &= ~ForceClientRender;
 
-          var _capturedValue = createCapturedValue(
+          var _capturedValue = createCapturedValueFromError(
             new Error(
               "There was an error while hydrating this Suspense boundary. " +
                 "Switched to client rendering."
@@ -17735,8 +17166,12 @@ to return true:wantsResponderID|                            |
     var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
 
     function updateContextProvider(current, workInProgress, renderLanes) {
-      var providerType = workInProgress.type;
-      var context = providerType._context;
+      var context;
+
+      {
+        context = workInProgress.type._context;
+      }
+
       var newProps = workInProgress.pendingProps;
       var oldProps = workInProgress.memoizedProps;
       var newValue = newProps.value;
@@ -17751,17 +17186,6 @@ to return true:wantsResponderID|                            |
             );
           }
         }
-
-        var providerPropTypes = workInProgress.type.propTypes;
-
-        if (providerPropTypes) {
-          checkPropTypes(
-            providerPropTypes,
-            newProps,
-            "prop",
-            "Context.Provider"
-          );
-        }
       }
 
       pushProvider(workInProgress, context, newValue);
@@ -17795,34 +17219,16 @@ to return true:wantsResponderID|                            |
       return workInProgress.child;
     }
 
-    var hasWarnedAboutUsingContextAsConsumer = false;
-
     function updateContextConsumer(current, workInProgress, renderLanes) {
-      var context = workInProgress.type; // The logic below for Context differs depending on PROD or DEV mode. In
-      // DEV mode, we create a separate object for Context.Consumer that acts
-      // like a proxy to Context. This proxy object adds unnecessary code in PROD
-      // so we use the old behaviour (Context.Consumer references Context) to
-      // reduce size and overhead. The separate object references context via
-      // a property called "_context", which also gives us the ability to check
-      // in DEV mode if this property exists or not and warn if it does not.
+      var context;
 
       {
-        if (context._context === undefined) {
-          // This may be because it's a Context (rather than a Consumer).
-          // Or it may be because it's older React where they're the same thing.
-          // We only want to warn if we're sure it's a new React.
-          if (context !== context.Consumer) {
-            if (!hasWarnedAboutUsingContextAsConsumer) {
-              hasWarnedAboutUsingContextAsConsumer = true;
+        context = workInProgress.type;
 
-              error(
-                "Rendering <Context> directly is not supported and will be removed in " +
-                  "a future major release. Did you mean to render <Context.Consumer> instead?"
-              );
-            }
+        {
+          if (context._context !== undefined) {
+            context = context._context;
           }
-        } else {
-          context = context._context;
         }
       }
 
@@ -17923,7 +17329,11 @@ to return true:wantsResponderID|                            |
         newWorkInProgress.index = oldWorkInProgress.index;
         newWorkInProgress.sibling = oldWorkInProgress.sibling;
         newWorkInProgress.return = oldWorkInProgress.return;
-        newWorkInProgress.ref = oldWorkInProgress.ref; // Replace the child/sibling pointers above it.
+        newWorkInProgress.ref = oldWorkInProgress.ref;
+
+        {
+          newWorkInProgress._debugInfo = oldWorkInProgress._debugInfo;
+        } // Replace the child/sibling pointers above it.
 
         if (oldWorkInProgress === returnFiber.child) {
           returnFiber.child = newWorkInProgress;
@@ -17995,12 +17405,6 @@ to return true:wantsResponderID|                            |
           break;
 
         case ClassComponent: {
-          var Component = workInProgress.type;
-
-          if (isContextProvider(Component)) {
-            pushContextProvider(workInProgress);
-          }
-
           break;
         }
 
@@ -18013,7 +17417,12 @@ to return true:wantsResponderID|                            |
 
         case ContextProvider: {
           var newValue = workInProgress.memoizedProps.value;
-          var context = workInProgress.type._context;
+          var context;
+
+          {
+            context = workInProgress.type._context;
+          }
+
           pushProvider(workInProgress, context, newValue);
           break;
         }
@@ -18171,7 +17580,7 @@ to return true:wantsResponderID|                            |
       return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
     }
 
-    function beginWork$1(current, workInProgress, renderLanes) {
+    function beginWork(current, workInProgress, renderLanes) {
       {
         if (workInProgress._debugNeedsRemount && current !== null) {
           // This will restart the begin phase with a new fiber.
@@ -18357,31 +17766,16 @@ to return true:wantsResponderID|                            |
           return updateContextConsumer(current, workInProgress, renderLanes);
 
         case MemoComponent: {
-          var _type2 = workInProgress.type;
+          var _type = workInProgress.type;
           var _unresolvedProps3 = workInProgress.pendingProps; // Resolve outer props first, then resolve inner props.
 
-          var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
-
-          {
-            if (workInProgress.type !== workInProgress.elementType) {
-              var outerPropTypes = _type2.propTypes;
-
-              if (outerPropTypes) {
-                checkPropTypes(
-                  outerPropTypes,
-                  _resolvedProps3, // Resolved for outer only
-                  "prop",
-                  getComponentNameFromType(_type2)
-                );
-              }
-            }
-          }
+          var _resolvedProps3 = resolveDefaultProps(_type, _unresolvedProps3);
 
-          _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
+          _resolvedProps3 = resolveDefaultProps(_type.type, _resolvedProps3);
           return updateMemoComponent(
             current,
             workInProgress,
-            _type2,
+            _type,
             _resolvedProps3,
             renderLanes
           );
@@ -18744,7 +18138,7 @@ to return true:wantsResponderID|                            |
 
       return readContextForConsumer(currentlyRenderingFiber, context);
     }
-    function readContextDuringReconcilation(consumer, context, renderLanes) {
+    function readContextDuringReconciliation(consumer, context, renderLanes) {
       if (currentlyRenderingFiber === null) {
         prepareToReadContext(consumer, renderLanes);
       }
@@ -18793,6 +18187,10 @@ to return true:wantsResponderID|                            |
       var transition = ReactCurrentBatchConfig$1.transition;
 
       if (transition !== null) {
+        if (!transition._callbacks) {
+          transition._callbacks = new Set();
+        }
+
         // Whenever a transition update is scheduled, register a callback on the
         // transition object so we can get the return value of the scope function.
         transition._callbacks.add(handleAsyncAction);
@@ -18824,10 +18222,6 @@ to return true:wantsResponderID|                            |
       workInProgress.flags |= Update;
     }
 
-    function markRef(workInProgress) {
-      workInProgress.flags |= Ref | RefStatic;
-    }
-
     function appendAllChildren(
       parent,
       workInProgress,
@@ -19234,12 +18628,6 @@ to return true:wantsResponderID|                            |
           return null;
 
         case ClassComponent: {
-          var Component = workInProgress.type;
-
-          if (isContextProvider(Component)) {
-            popContext(workInProgress);
-          }
-
           bubbleProperties(workInProgress);
           return null;
         }
@@ -19247,7 +18635,6 @@ to return true:wantsResponderID|                            |
         case HostRoot: {
           var fiberRoot = workInProgress.stateNode;
           popHostContainer(workInProgress);
-          popTopLevelContextObject(workInProgress);
 
           if (fiberRoot.pendingContext) {
             fiberRoot.context = fiberRoot.pendingContext;
@@ -19302,10 +18689,6 @@ to return true:wantsResponderID|                            |
 
           if (current !== null && workInProgress.stateNode != null) {
             updateHostComponent(current, workInProgress, _type2, newProps);
-
-            if (current.ref !== workInProgress.ref) {
-              markRef(workInProgress);
-            }
           } else {
             if (!newProps) {
               if (workInProgress.stateNode === null) {
@@ -19351,11 +18734,6 @@ to return true:wantsResponderID|                            |
                 markUpdate(workInProgress);
               }
             }
-
-            if (workInProgress.ref !== null) {
-              // If there is a ref on a host node we need to schedule a callback
-              markRef(workInProgress);
-            }
           }
 
           bubbleProperties(workInProgress); // This must come at the very end of the complete phase, because it might
@@ -19410,7 +18788,6 @@ to return true:wantsResponderID|                            |
         }
 
         case SuspenseComponent: {
-          popSuspenseHandler(workInProgress);
           var nextState = workInProgress.memoizedState; // Special path for dehydrated boundaries. We may eventually move this
           // to its own fiber type so that we can add other kinds of hydration
           // boundaries that aren't associated with a Suspense tree. In anticipation
@@ -19431,17 +18808,21 @@ to return true:wantsResponderID|                            |
 
             if (!fallthroughToNormalSuspensePath) {
               if (workInProgress.flags & ForceClientRender) {
-                // Special case. There were remaining unhydrated nodes. We treat
+                popSuspenseHandler(workInProgress); // Special case. There were remaining unhydrated nodes. We treat
                 // this as a mismatch. Revert to client rendering.
+
                 return workInProgress;
               } else {
-                // Did not finish hydrating, either because this is the initial
+                popSuspenseHandler(workInProgress); // Did not finish hydrating, either because this is the initial
                 // render or because something suspended.
+
                 return null;
               }
             } // Continue with the normal Suspense path.
           }
 
+          popSuspenseHandler(workInProgress);
+
           if ((workInProgress.flags & DidCapture) !== NoFlags$1) {
             // Something suspended. Re-render with the fallback children.
             workInProgress.lanes = renderLanes; // Do not reset the effect list.
@@ -19507,20 +18888,17 @@ to return true:wantsResponderID|                            |
 
         case ContextProvider:
           // Pop provider fiber
-          var context = workInProgress.type._context;
+          var context;
+
+          {
+            context = workInProgress.type._context;
+          }
+
           popProvider(context, workInProgress);
           bubbleProperties(workInProgress);
           return null;
 
         case IncompleteClassComponent: {
-          // Same as class component case. I put it down here so that the tags are
-          // sequential to ensure this switch is compiled to a jump table.
-          var _Component = workInProgress.type;
-
-          if (isContextProvider(_Component)) {
-            popContext(workInProgress);
-          }
-
           bubbleProperties(workInProgress);
           return null;
         }
@@ -19812,12 +19190,6 @@ to return true:wantsResponderID|                            |
     function unwindWork(current, workInProgress, renderLanes) {
       switch (workInProgress.tag) {
         case ClassComponent: {
-          var Component = workInProgress.type;
-
-          if (isContextProvider(Component)) {
-            popContext(workInProgress);
-          }
-
           var flags = workInProgress.flags;
 
           if (flags & ShouldCapture) {
@@ -19835,7 +19207,6 @@ to return true:wantsResponderID|                            |
 
         case HostRoot: {
           popHostContainer(workInProgress);
-          popTopLevelContextObject(workInProgress);
           var _flags = workInProgress.flags;
 
           if (
@@ -19899,7 +19270,12 @@ to return true:wantsResponderID|                            |
           return null;
 
         case ContextProvider:
-          var context = workInProgress.type._context;
+          var context;
+
+          {
+            context = workInProgress.type._context;
+          }
+
           popProvider(context, workInProgress);
           return null;
 
@@ -19936,18 +19312,11 @@ to return true:wantsResponderID|                            |
     function unwindInterruptedWork(current, interruptedWork, renderLanes) {
       switch (interruptedWork.tag) {
         case ClassComponent: {
-          var childContextTypes = interruptedWork.type.childContextTypes;
-
-          if (childContextTypes !== null && childContextTypes !== undefined) {
-            popContext(interruptedWork);
-          }
-
           break;
         }
 
         case HostRoot: {
           popHostContainer(interruptedWork);
-          popTopLevelContextObject(interruptedWork);
           break;
         }
 
@@ -19971,7 +19340,12 @@ to return true:wantsResponderID|                            |
           break;
 
         case ContextProvider:
-          var context = interruptedWork.type._context;
+          var context;
+
+          {
+            context = interruptedWork.type._context;
+          }
+
           popProvider(context, interruptedWork);
           break;
 
@@ -20005,20 +19379,6 @@ to return true:wantsResponderID|                            |
       );
     }
 
-    function reportUncaughtErrorInDEV(error) {
-      // Wrapping each small part of the commit phase into a guarded
-      // callback is a bit too slow (https://github.com/facebook/react/pull/21666).
-      // But we rely on it to surface errors to DEV tools like overlays
-      // (https://github.com/facebook/react/issues/21712).
-      // As a compromise, rethrow only caught errors in a guard.
-      {
-        invokeGuardedCallback(null, function () {
-          throw error;
-        });
-        clearCaughtError();
-      }
-    }
-
     function callComponentWillUnmountWithTimer(current, instance) {
       instance.props = current.memoizedProps;
       instance.state = current.memoizedState;
@@ -20395,7 +19755,7 @@ to return true:wantsResponderID|                            |
                     "  }\n" +
                     "  fetchData();\n" +
                     "}, [someId]); // Or [] if effect doesn't need props or state\n\n" +
-                    "Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching";
+                    "Learn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching";
                 } else {
                   addendum = " You returned: " + destroy;
                 }
@@ -21030,6 +20390,8 @@ to return true:wantsResponderID|                            |
           }
         } else {
           {
+            // TODO: We should move these warnings to happen during the render
+            // phase (markRef).
             if (!ref.hasOwnProperty("current")) {
               error(
                 "Unexpected ref object provided for %s. " +
@@ -23283,7 +22645,9 @@ to return true:wantsResponderID|                            |
     var workInProgressRootConcurrentErrors = null; // These are errors that we recovered from without surfacing them to the UI.
     // We will log them once the tree commits.
 
-    var workInProgressRootRecoverableErrors = null; // The most recent time we either committed a fallback, or when a fallback was
+    var workInProgressRootRecoverableErrors = null; // Tracks when an update occurs during the render phase.
+
+    var workInProgressRootDidIncludeRecursiveRenderUpdate = false; // Thacks when an update occurs during the commit phase. It's a separate
     // filled in with the resolved UI. This lets us throttle the appearance of new
     // content as it streams in, to minimize jank.
     // TODO: Think of a better name for this variable?
@@ -23307,7 +22671,7 @@ to return true:wantsResponderID|                            |
     }
     var hasUncaughtError = false;
     var firstUncaughtError = null;
-    var legacyErrorBoundariesThatAlreadyFailed = null; // Only used when enableProfilerNestedUpdateScheduledHook is true;
+    var legacyErrorBoundariesThatAlreadyFailed = null;
     var rootDoesHavePassiveEffects = false;
     var rootWithPendingPassiveEffects = null;
     var pendingPassiveEffectsLanes = NoLanes;
@@ -23799,6 +23163,7 @@ to return true:wantsResponderID|                            |
           root,
           workInProgressRootRecoverableErrors,
           workInProgressTransitions,
+          workInProgressRootDidIncludeRecursiveRenderUpdate,
           workInProgressDeferredLane
         );
       } else {
@@ -23829,6 +23194,7 @@ to return true:wantsResponderID|                            |
                 finishedWork,
                 workInProgressRootRecoverableErrors,
                 workInProgressTransitions,
+                workInProgressRootDidIncludeRecursiveRenderUpdate,
                 lanes,
                 workInProgressDeferredLane
               ),
@@ -23843,6 +23209,7 @@ to return true:wantsResponderID|                            |
           finishedWork,
           workInProgressRootRecoverableErrors,
           workInProgressTransitions,
+          workInProgressRootDidIncludeRecursiveRenderUpdate,
           lanes,
           workInProgressDeferredLane
         );
@@ -23854,6 +23221,7 @@ to return true:wantsResponderID|                            |
       finishedWork,
       recoverableErrors,
       transitions,
+      didIncludeRenderPhaseUpdate,
       lanes,
       spawnedLane
     ) {
@@ -23878,14 +23246,26 @@ to return true:wantsResponderID|                            |
           // us that it's ready. This will be canceled if we start work on the
           // root again.
           root.cancelPendingCommit = schedulePendingCommit(
-            commitRoot.bind(null, root, recoverableErrors, transitions)
+            commitRoot.bind(
+              null,
+              root,
+              recoverableErrors,
+              transitions,
+              didIncludeRenderPhaseUpdate
+            )
           );
           markRootSuspended(root, lanes, spawnedLane);
           return;
         }
       } // Otherwise, commit immediately.
 
-      commitRoot(root, recoverableErrors, transitions, spawnedLane);
+      commitRoot(
+        root,
+        recoverableErrors,
+        transitions,
+        didIncludeRenderPhaseUpdate,
+        spawnedLane
+      );
     }
 
     function isRenderConsistentWithExternalStores(finishedWork) {
@@ -23948,13 +23328,23 @@ to return true:wantsResponderID|                            |
       // eslint-disable-next-line no-unreachable
 
       return true;
+    } // The extra indirections around markRootUpdated and markRootSuspended is
+    // needed to avoid a circular dependency between this module and
+    // ReactFiberLane. There's probably a better way to split up these modules and
+    // avoid this problem. Perhaps all the root-marking functions should move into
+    // the work loop.
+
+    function markRootUpdated(root, updatedLanes) {
+      markRootUpdated$1(root, updatedLanes);
+    }
+
+    function markRootPinged(root, pingedLanes) {
+      markRootPinged$1(root, pingedLanes);
     }
 
     function markRootSuspended(root, suspendedLanes, spawnedLane) {
       // When suspending, we should always exclude lanes that were pinged or (more
       // rarely, since we try to avoid it) updated during the render phase.
-      // TODO: Lol maybe there's a better way to factor this besides this
-      // obnoxiously named function :)
       suspendedLanes = removeLanes(
         suspendedLanes,
         workInProgressRootPingedLanes
@@ -23963,6 +23353,7 @@ to return true:wantsResponderID|                            |
         suspendedLanes,
         workInProgressRootInterleavedUpdatedLanes
       );
+
       markRootSuspended$1(root, suspendedLanes, spawnedLane);
     } // This is the entry point for synchronous tasks that don't go
     // through Scheduler
@@ -24037,6 +23428,7 @@ to return true:wantsResponderID|                            |
         root,
         workInProgressRootRecoverableErrors,
         workInProgressTransitions,
+        workInProgressRootDidIncludeRecursiveRenderUpdate,
         workInProgressDeferredLane
       ); // Before exiting, make sure there's a callback scheduled for the next
       // pending level.
@@ -24181,7 +23573,8 @@ to return true:wantsResponderID|                            |
       workInProgressRootPingedLanes = NoLanes;
       workInProgressDeferredLane = NoLane;
       workInProgressRootConcurrentErrors = null;
-      workInProgressRootRecoverableErrors = null; // Get the lanes that are entangled with whatever we're about to render. We
+      workInProgressRootRecoverableErrors = null;
+      workInProgressRootDidIncludeRecursiveRenderUpdate = false; // Get the lanes that are entangled with whatever we're about to render. We
       // track these separately so we can distinguish the priority of the render
       // task from the priority of the lanes it is entangled with. For example, a
       // transition may not be allowed to finish unless it includes the Sync lane,
@@ -24856,15 +24249,6 @@ to return true:wantsResponderID|                            |
               : resolveDefaultProps(Component, unresolvedProps);
           var context;
 
-          {
-            var unmaskedContext = getUnmaskedContext(
-              unitOfWork,
-              Component,
-              true
-            );
-            context = getMaskedContext(unitOfWork, unmaskedContext);
-          }
-
           next = replayFunctionComponent(
             current,
             unitOfWork,
@@ -25145,7 +24529,13 @@ to return true:wantsResponderID|                            |
       workInProgress = null;
     }
 
-    function commitRoot(root, recoverableErrors, transitions, spawnedLane) {
+    function commitRoot(
+      root,
+      recoverableErrors,
+      transitions,
+      didIncludeRenderPhaseUpdate,
+      spawnedLane
+    ) {
       // TODO: This no longer makes any sense. We already wrap the mutation and
       // layout phases. Should be able to remove.
       var previousUpdateLanePriority = getCurrentUpdatePriority();
@@ -25158,6 +24548,7 @@ to return true:wantsResponderID|                            |
           root,
           recoverableErrors,
           transitions,
+          didIncludeRenderPhaseUpdate,
           previousUpdateLanePriority,
           spawnedLane
         );
@@ -25173,6 +24564,7 @@ to return true:wantsResponderID|                            |
       root,
       recoverableErrors,
       transitions,
+      didIncludeRenderPhaseUpdate,
       renderPriorityLevel,
       spawnedLane
     ) {
@@ -25232,7 +24624,7 @@ to return true:wantsResponderID|                            |
 
       var concurrentlyUpdatedLanes = getConcurrentlyUpdatedLanes();
       remainingLanes = mergeLanes(remainingLanes, concurrentlyUpdatedLanes);
-      markRootFinished(root, remainingLanes, spawnedLane);
+      markRootFinished(root, remainingLanes, spawnedLane); // Reset this before firing side effects so we can detect recursive updates.
 
       if (root === workInProgressRoot) {
         // We can reset these now that they are finished.
@@ -25295,7 +24687,7 @@ to return true:wantsResponderID|                            |
           // Mark the current commit time to be shared by all Profilers in this
           // batch. This enables them to be grouped later.
           recordCommitTime();
-        }
+        } // The next phase is the mutation phase, where we mutate the host tree.
 
         commitMutationEffects(root, finishedWork, lanes);
         // the mutation phase, so that the previous tree is still current during
@@ -25414,6 +24806,9 @@ to return true:wantsResponderID|                            |
       // hydration is conceptually not an update.
 
       if (
+        // Check if there was a recursive update spawned by this render, in either
+        // the render phase or the commit phase. We track these explicitly because
+        // we can't infer from the remaining lanes alone.
         // Was the finished render the result of an update (not hydration)?
         includesSomeLane(lanes, UpdateLanes) && // Did it schedule a sync update?
         includesSomeLane(remainingLanes, SyncUpdateLanes)
@@ -25613,7 +25008,6 @@ to return true:wantsResponderID|                            |
       error$1
     ) {
       {
-        reportUncaughtErrorInDEV(error$1);
         setIsRunningInsertionEffect(false);
       }
 
@@ -25835,6 +25229,7 @@ to return true:wantsResponderID|                            |
         nestedPassiveUpdateCount = 0;
         rootWithNestedUpdates = null;
         rootWithPassiveNestedUpdates = null;
+
         throw new Error(
           "Maximum update depth exceeded. This can happen when a component " +
             "repeatedly calls setState inside componentWillUpdate or " +
@@ -25991,81 +25386,6 @@ to return true:wantsResponderID|                            |
         }
       }
     }
-    var beginWork;
-
-    {
-      var dummyFiber = null;
-
-      beginWork = function (current, unitOfWork, lanes) {
-        // If a component throws an error, we replay it again in a synchronously
-        // dispatched event, so that the debugger will treat it as an uncaught
-        // error See ReactErrorUtils for more information.
-        // Before entering the begin phase, copy the work-in-progress onto a dummy
-        // fiber. If beginWork throws, we'll use this to reset the state.
-        var originalWorkInProgressCopy = assignFiberPropertiesInDEV(
-          dummyFiber,
-          unitOfWork
-        );
-
-        try {
-          return beginWork$1(current, unitOfWork, lanes);
-        } catch (originalError) {
-          if (
-            didSuspendOrErrorWhileHydratingDEV() ||
-            originalError === SuspenseException ||
-            originalError === SelectiveHydrationException ||
-            (originalError !== null &&
-              typeof originalError === "object" &&
-              typeof originalError.then === "function")
-          ) {
-            // Don't replay promises.
-            // Don't replay errors if we are hydrating and have already suspended or handled an error
-            throw originalError;
-          } // Don't reset current debug fiber, since we're about to work on the
-          // same fiber again.
-          // Unwind the failed stack frame
-
-          resetSuspendedWorkLoopOnUnwind(unitOfWork);
-          unwindInterruptedWork(current, unitOfWork); // Restore the original properties of the fiber.
-
-          assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
-
-          if (unitOfWork.mode & ProfileMode) {
-            // Reset the profiler timer.
-            startProfilerTimer(unitOfWork);
-          } // Run beginWork again.
-
-          invokeGuardedCallback(
-            null,
-            beginWork$1,
-            null,
-            current,
-            unitOfWork,
-            lanes
-          );
-
-          if (hasCaughtError()) {
-            var replayError = clearCaughtError();
-
-            if (
-              typeof replayError === "object" &&
-              replayError !== null &&
-              replayError._suppressLogging &&
-              typeof originalError === "object" &&
-              originalError !== null &&
-              !originalError._suppressLogging
-            ) {
-              // If suppressed, let the flag carry over to the original error which is the one we'll rethrow.
-              originalError._suppressLogging = true;
-            }
-          } // We always throw the original error in case the second render pass is not idempotent.
-          // This can happen if a memoized function or CommonJS module doesn't throw after first invocation.
-
-          throw originalError;
-        }
-      };
-    }
-
     var didWarnAboutUpdateInRender = false;
     var didWarnAboutUpdateInRenderForAnotherComponent;
 
@@ -26096,7 +25416,7 @@ to return true:wantsResponderID|                            |
                 error(
                   "Cannot update a component (`%s`) while rendering a " +
                     "different component (`%s`). To locate the bad setState() call inside `%s`, " +
-                    "follow the stack trace as described in https://reactjs.org/link/setstate-in-render",
+                    "follow the stack trace as described in https://react.dev/link/setstate-in-render",
                   setStateComponentName,
                   renderingComponentName,
                   renderingComponentName
@@ -26205,7 +25525,7 @@ to return true:wantsResponderID|                            |
                 "/* assert on the output */\n\n" +
                 "This ensures that you're testing the behavior the user would see " +
                 "in the browser." +
-                " Learn more at https://reactjs.org/link/wrap-tests-with-act",
+                " Learn more at https://react.dev/link/wrap-tests-with-act",
               getComponentNameFromFiber(fiber)
             );
           } finally {
@@ -26237,7 +25557,7 @@ to return true:wantsResponderID|                            |
               "/* assert on the output */\n\n" +
               "This ensures that you're testing the behavior the user would see " +
               "in the browser." +
-              " Learn more at https://reactjs.org/link/wrap-tests-with-act"
+              " Learn more at https://react.dev/link/wrap-tests-with-act"
           );
         }
       }
@@ -26774,6 +26094,7 @@ to return true:wantsResponderID|                            |
 
       {
         // This isn't directly used but is handy for debugging internals:
+        this._debugInfo = null;
         this._debugOwner = null;
         this._debugNeedsRemount = false;
         this._debugHookTypes = null;
@@ -26912,6 +26233,7 @@ to return true:wantsResponderID|                            |
       }
 
       {
+        workInProgress._debugInfo = current._debugInfo;
         workInProgress._debugNeedsRemount = current._debugNeedsRemount;
 
         switch (workInProgress.tag) {
@@ -27110,14 +26432,21 @@ to return true:wantsResponderID|                            |
           default: {
             if (typeof type === "object" && type !== null) {
               switch (type.$$typeof) {
-                case REACT_PROVIDER_TYPE:
+                case REACT_PROVIDER_TYPE: {
                   fiberTag = ContextProvider;
                   break getTag;
+                }
 
-                case REACT_CONTEXT_TYPE:
-                  // This is a consumer
+                // Fall through
+
+                case REACT_CONTEXT_TYPE: {
                   fiberTag = ContextConsumer;
                   break getTag;
+                }
+
+                case REACT_CONSUMER_TYPE:
+
+                // Fall through
 
                 case REACT_FORWARD_REF_TYPE:
                   fiberTag = ForwardRef;
@@ -27286,54 +26615,6 @@ to return true:wantsResponderID|                            |
         implementation: portal.implementation
       };
       return fiber;
-    } // Used for stashing WIP properties to replay failed work in DEV.
-
-    function assignFiberPropertiesInDEV(target, source) {
-      if (target === null) {
-        // This Fiber's initial properties will always be overwritten.
-        // We only use a Fiber to ensure the same hidden class so DEV isn't slow.
-        target = createFiber(IndeterminateComponent, null, null, NoMode);
-      } // This is intentionally written as a list of all properties.
-      // We tried to use Object.assign() instead but this is called in
-      // the hottest path, and Object.assign() was too slow:
-      // https://github.com/facebook/react/issues/12502
-      // This code is DEV-only so size is not a concern.
-
-      target.tag = source.tag;
-      target.key = source.key;
-      target.elementType = source.elementType;
-      target.type = source.type;
-      target.stateNode = source.stateNode;
-      target.return = source.return;
-      target.child = source.child;
-      target.sibling = source.sibling;
-      target.index = source.index;
-      target.ref = source.ref;
-      target.refCleanup = source.refCleanup;
-      target.pendingProps = source.pendingProps;
-      target.memoizedProps = source.memoizedProps;
-      target.updateQueue = source.updateQueue;
-      target.memoizedState = source.memoizedState;
-      target.dependencies = source.dependencies;
-      target.mode = source.mode;
-      target.flags = source.flags;
-      target.subtreeFlags = source.subtreeFlags;
-      target.deletions = source.deletions;
-      target.lanes = source.lanes;
-      target.childLanes = source.childLanes;
-      target.alternate = source.alternate;
-
-      {
-        target.actualDuration = source.actualDuration;
-        target.actualStartTime = source.actualStartTime;
-        target.selfBaseDuration = source.selfBaseDuration;
-        target.treeBaseDuration = source.treeBaseDuration;
-      }
-
-      target._debugOwner = source._debugOwner;
-      target._debugNeedsRemount = source._debugNeedsRemount;
-      target._debugHookTypes = source._debugHookTypes;
-      return target;
     }
 
     function FiberRootNode(
@@ -27445,7 +26726,7 @@ to return true:wantsResponderID|                            |
       return root;
     }
 
-    var ReactVersion = "18.3.0-canary-03d6f7cf0-20240209";
+    var ReactVersion = "18.3.0-canary-9372c6311-20240315";
 
     function createPortal$1(
       children,
@@ -27487,12 +26768,12 @@ to return true:wantsResponderID|                            |
       }
 
       var fiber = get(parentComponent);
-      var parentContext = findCurrentUnmaskedContext(fiber);
+      var parentContext = findCurrentUnmaskedContext();
 
       if (fiber.tag === ClassComponent) {
         var Component = fiber.type;
 
-        if (isContextProvider(Component)) {
+        if (isContextProvider()) {
           return processChildContext(fiber, Component, parentContext);
         }
       }
@@ -27537,7 +26818,7 @@ to return true:wantsResponderID|                            |
                     "%s was passed an instance of %s which is inside StrictMode. " +
                     "Instead, add a ref directly to the element you want to reference. " +
                     "Learn more about using refs safely here: " +
-                    "https://reactjs.org/link/strict-mode-find-node",
+                    "https://react.dev/link/strict-mode-find-node",
                   methodName,
                   methodName,
                   componentName
@@ -27548,7 +26829,7 @@ to return true:wantsResponderID|                            |
                     "%s was passed an instance of %s which renders StrictMode children. " +
                     "Instead, add a ref directly to the element you want to reference. " +
                     "Learn more about using refs safely here: " +
-                    "https://reactjs.org/link/strict-mode-find-node",
+                    "https://react.dev/link/strict-mode-find-node",
                   methodName,
                   methodName,
                   componentName
@@ -27638,7 +26919,7 @@ to return true:wantsResponderID|                            |
         {
           if (typeof callback !== "function") {
             error(
-              "render(...): Expected the last optional `callback` argument to be a " +
+              "Expected the last optional `callback` argument to be a " +
                 "function. Instead received: %s.",
               callback
             );
diff --git a/node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-prod.js b/node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-prod.js
index 7f6b01a..799e3d6 100644
--- a/node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-prod.js
+++ b/node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-prod.js
@@ -8,76 +8,33 @@
  * @nolint
  * @providesModule ReactNativeRenderer-prod
  * @preventMunge
- * @generated SignedSource<<c59a64750c45a2b1d812de3370615944>>
+ * @generated SignedSource<<fe2907fc6f39fbb87dcc99c2ab30ab51>>
  */
 
 "use strict";
 require("react-native/Libraries/ReactPrivate/ReactNativePrivateInitializeCore");
 var ReactNativePrivateInterface = require("react-native/Libraries/ReactPrivate/ReactNativePrivateInterface"),
   React = require("react"),
-  Scheduler = require("scheduler");
-function invokeGuardedCallbackImpl(name, func, context) {
-  var funcArgs = Array.prototype.slice.call(arguments, 3);
-  try {
-    func.apply(context, funcArgs);
-  } catch (error) {
-    this.onError(error);
-  }
-}
-var hasError = !1,
+  Scheduler = require("scheduler"),
+  isArrayImpl = Array.isArray,
+  hasError = !1,
   caughtError = null,
-  hasRethrowError = !1,
-  rethrowError = null,
-  reporter = {
-    onError: function (error) {
-      hasError = !0;
-      caughtError = error;
-    }
-  };
-function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
-  hasError = !1;
-  caughtError = null;
-  invokeGuardedCallbackImpl.apply(reporter, arguments);
-}
-function invokeGuardedCallbackAndCatchFirstError(
-  name,
-  func,
-  context,
-  a,
-  b,
-  c,
-  d,
-  e,
-  f
-) {
-  invokeGuardedCallback.apply(this, arguments);
-  if (hasError) {
-    if (hasError) {
-      var error = caughtError;
-      hasError = !1;
-      caughtError = null;
-    } else
-      throw Error(
-        "clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue."
-      );
-    hasRethrowError || ((hasRethrowError = !0), (rethrowError = error));
-  }
-}
-var isArrayImpl = Array.isArray,
   getFiberCurrentPropsFromNode$1 = null,
   getInstanceFromNode = null,
   getNodeFromInstance = null;
 function executeDispatch(event, listener, inst) {
-  var type = event.type || "unknown-event";
   event.currentTarget = getNodeFromInstance(inst);
-  invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event);
+  try {
+    listener(event);
+  } catch (error) {
+    hasError || ((hasError = !0), (caughtError = error));
+  }
   event.currentTarget = null;
 }
 function executeDirectDispatch(event) {
   var dispatchListener = event._dispatchListeners,
     dispatchInstance = event._dispatchInstances;
-  if (isArrayImpl(dispatchListener))
-    throw Error("executeDirectDispatch(...): Invalid `event`.");
+  if (isArrayImpl(dispatchListener)) throw Error("Invalid `event`.");
   event.currentTarget = dispatchListener
     ? getNodeFromInstance(dispatchInstance)
     : null;
@@ -336,9 +293,7 @@ var instrumentationCallback,
   };
 function accumulate(current, next) {
   if (null == next)
-    throw Error(
-      "accumulate(...): Accumulated items must not be null or undefined."
-    );
+    throw Error("Accumulated items must not be null or undefined.");
   return null == current
     ? next
     : isArrayImpl(current)
@@ -349,9 +304,7 @@ function accumulate(current, next) {
 }
 function accumulateInto(current, next) {
   if (null == next)
-    throw Error(
-      "accumulateInto(...): Accumulated items must not be null or undefined."
-    );
+    throw Error("Accumulated items must not be null or undefined.");
   if (null == current) return next;
   if (isArrayImpl(current)) {
     if (isArrayImpl(next)) return current.push.apply(current, next), current;
@@ -940,7 +893,7 @@ eventPluginOrder = Array.prototype.slice.call([
   "ReactNativeBridgeEventPlugin"
 ]);
 recomputePluginOrdering();
-var injectedNamesToPlugins$jscomp$inline_238 = {
+var injectedNamesToPlugins$jscomp$inline_234 = {
     ResponderEventPlugin: ResponderEventPlugin,
     ReactNativeBridgeEventPlugin: {
       eventTypes: {},
@@ -986,32 +939,32 @@ var injectedNamesToPlugins$jscomp$inline_238 = {
       }
     }
   },
-  isOrderingDirty$jscomp$inline_239 = !1,
-  pluginName$jscomp$inline_240;
-for (pluginName$jscomp$inline_240 in injectedNamesToPlugins$jscomp$inline_238)
+  isOrderingDirty$jscomp$inline_235 = !1,
+  pluginName$jscomp$inline_236;
+for (pluginName$jscomp$inline_236 in injectedNamesToPlugins$jscomp$inline_234)
   if (
-    injectedNamesToPlugins$jscomp$inline_238.hasOwnProperty(
-      pluginName$jscomp$inline_240
+    injectedNamesToPlugins$jscomp$inline_234.hasOwnProperty(
+      pluginName$jscomp$inline_236
     )
   ) {
-    var pluginModule$jscomp$inline_241 =
-      injectedNamesToPlugins$jscomp$inline_238[pluginName$jscomp$inline_240];
+    var pluginModule$jscomp$inline_237 =
+      injectedNamesToPlugins$jscomp$inline_234[pluginName$jscomp$inline_236];
     if (
-      !namesToPlugins.hasOwnProperty(pluginName$jscomp$inline_240) ||
-      namesToPlugins[pluginName$jscomp$inline_240] !==
-        pluginModule$jscomp$inline_241
+      !namesToPlugins.hasOwnProperty(pluginName$jscomp$inline_236) ||
+      namesToPlugins[pluginName$jscomp$inline_236] !==
+        pluginModule$jscomp$inline_237
     ) {
-      if (namesToPlugins[pluginName$jscomp$inline_240])
+      if (namesToPlugins[pluginName$jscomp$inline_236])
         throw Error(
           "EventPluginRegistry: Cannot inject two different event plugins using the same name, `" +
-            (pluginName$jscomp$inline_240 + "`.")
+            (pluginName$jscomp$inline_236 + "`.")
         );
-      namesToPlugins[pluginName$jscomp$inline_240] =
-        pluginModule$jscomp$inline_241;
-      isOrderingDirty$jscomp$inline_239 = !0;
+      namesToPlugins[pluginName$jscomp$inline_236] =
+        pluginModule$jscomp$inline_237;
+      isOrderingDirty$jscomp$inline_235 = !0;
     }
   }
-isOrderingDirty$jscomp$inline_239 && recomputePluginOrdering();
+isOrderingDirty$jscomp$inline_235 && recomputePluginOrdering();
 var instanceCache = new Map(),
   instanceProps = new Map();
 function getInstanceFromTag(tag) {
@@ -1087,11 +1040,11 @@ function _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam) {
         throw Error(
           "processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented."
         );
-      if (hasRethrowError)
+      if (hasError)
         throw (
-          ((JSCompiler_inline_result = rethrowError),
-          (hasRethrowError = !1),
-          (rethrowError = null),
+          ((JSCompiler_inline_result = caughtError),
+          (hasError = !1),
+          (caughtError = null),
           JSCompiler_inline_result)
         );
     }
@@ -1165,6 +1118,7 @@ var ReactSharedInternals =
   REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
   REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
   REACT_PROVIDER_TYPE = Symbol.for("react.provider"),
+  REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
   REACT_CONTEXT_TYPE = Symbol.for("react.context"),
   REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
   REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
@@ -1185,115 +1139,7 @@ function getIteratorFn(maybeIterable) {
     maybeIterable["@@iterator"];
   return "function" === typeof maybeIterable ? maybeIterable : null;
 }
-var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
-function getComponentNameFromType(type) {
-  if (null == type) return null;
-  if ("function" === typeof type)
-    return type.$$typeof === REACT_CLIENT_REFERENCE
-      ? null
-      : type.displayName || type.name || null;
-  if ("string" === typeof type) return type;
-  switch (type) {
-    case REACT_FRAGMENT_TYPE:
-      return "Fragment";
-    case REACT_PORTAL_TYPE:
-      return "Portal";
-    case REACT_PROFILER_TYPE:
-      return "Profiler";
-    case REACT_STRICT_MODE_TYPE:
-      return "StrictMode";
-    case REACT_SUSPENSE_TYPE:
-      return "Suspense";
-    case REACT_SUSPENSE_LIST_TYPE:
-      return "SuspenseList";
-  }
-  if ("object" === typeof type)
-    switch (type.$$typeof) {
-      case REACT_CONTEXT_TYPE:
-        return (type.displayName || "Context") + ".Consumer";
-      case REACT_PROVIDER_TYPE:
-        return (type._context.displayName || "Context") + ".Provider";
-      case REACT_FORWARD_REF_TYPE:
-        var innerType = type.render;
-        type = type.displayName;
-        type ||
-          ((type = innerType.displayName || innerType.name || ""),
-          (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
-        return type;
-      case REACT_MEMO_TYPE:
-        return (
-          (innerType = type.displayName || null),
-          null !== innerType
-            ? innerType
-            : getComponentNameFromType(type.type) || "Memo"
-        );
-      case REACT_LAZY_TYPE:
-        innerType = type._payload;
-        type = type._init;
-        try {
-          return getComponentNameFromType(type(innerType));
-        } catch (x) {}
-    }
-  return null;
-}
-function getComponentNameFromFiber(fiber) {
-  var type = fiber.type;
-  switch (fiber.tag) {
-    case 24:
-      return "Cache";
-    case 9:
-      return (type.displayName || "Context") + ".Consumer";
-    case 10:
-      return (type._context.displayName || "Context") + ".Provider";
-    case 18:
-      return "DehydratedFragment";
-    case 11:
-      return (
-        (fiber = type.render),
-        (fiber = fiber.displayName || fiber.name || ""),
-        type.displayName ||
-          ("" !== fiber ? "ForwardRef(" + fiber + ")" : "ForwardRef")
-      );
-    case 7:
-      return "Fragment";
-    case 26:
-    case 27:
-    case 5:
-      return type;
-    case 4:
-      return "Portal";
-    case 3:
-      return "Root";
-    case 6:
-      return "Text";
-    case 16:
-      return getComponentNameFromType(type);
-    case 8:
-      return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
-    case 22:
-      return "Offscreen";
-    case 12:
-      return "Profiler";
-    case 21:
-      return "Scope";
-    case 13:
-      return "Suspense";
-    case 19:
-      return "SuspenseList";
-    case 25:
-      return "TracingMarker";
-    case 1:
-    case 0:
-    case 17:
-    case 2:
-    case 14:
-    case 15:
-      if ("function" === typeof type)
-        return type.displayName || type.name || null;
-      if ("string" === typeof type) return type;
-  }
-  return null;
-}
+Symbol.for("react.client.reference");
 function getNearestMountedFiber(fiber) {
   var node = fiber,
     nearestMounted = fiber;
@@ -1865,7 +1711,7 @@ function createLaneMap(initial) {
   for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
   return laneMap;
 }
-function markRootUpdated(root, updateLane) {
+function markRootUpdated$1(root, updateLane) {
   root.pendingLanes |= updateLane;
   268435456 !== updateLane &&
     ((root.suspendedLanes = 0), (root.pingedLanes = 0));
@@ -1976,18 +1822,7 @@ function getPublicInstance(instance) {
     : instance;
 }
 var scheduleTimeout = setTimeout,
-  cancelTimeout = clearTimeout;
-function describeComponentFrame(name, ownerName) {
-  var sourceInfo = "";
-  ownerName && (sourceInfo = " (created by " + ownerName + ")");
-  return "\n    in " + (name || "Unknown") + sourceInfo;
-}
-function describeFunctionComponentFrame(fn) {
-  return fn
-    ? describeComponentFrame(fn.displayName || fn.name || null, null)
-    : "";
-}
-var hasOwnProperty = Object.prototype.hasOwnProperty,
+  cancelTimeout = clearTimeout,
   valueStack = [],
   index = -1;
 function createCursor(defaultValue) {
@@ -2002,89 +1837,7 @@ function push(cursor, value) {
   valueStack[index] = cursor.current;
   cursor.current = value;
 }
-var emptyContextObject = {},
-  contextStackCursor$1 = createCursor(emptyContextObject),
-  didPerformWorkStackCursor = createCursor(!1),
-  previousContext = emptyContextObject;
-function getMaskedContext(workInProgress, unmaskedContext) {
-  var contextTypes = workInProgress.type.contextTypes;
-  if (!contextTypes) return emptyContextObject;
-  var instance = workInProgress.stateNode;
-  if (
-    instance &&
-    instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext
-  )
-    return instance.__reactInternalMemoizedMaskedChildContext;
-  var context = {},
-    key;
-  for (key in contextTypes) context[key] = unmaskedContext[key];
-  instance &&
-    ((workInProgress = workInProgress.stateNode),
-    (workInProgress.__reactInternalMemoizedUnmaskedChildContext =
-      unmaskedContext),
-    (workInProgress.__reactInternalMemoizedMaskedChildContext = context));
-  return context;
-}
-function isContextProvider(type) {
-  type = type.childContextTypes;
-  return null !== type && void 0 !== type;
-}
-function popContext() {
-  pop(didPerformWorkStackCursor);
-  pop(contextStackCursor$1);
-}
-function pushTopLevelContextObject(fiber, context, didChange) {
-  if (contextStackCursor$1.current !== emptyContextObject)
-    throw Error(
-      "Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue."
-    );
-  push(contextStackCursor$1, context);
-  push(didPerformWorkStackCursor, didChange);
-}
-function processChildContext(fiber, type, parentContext) {
-  var instance = fiber.stateNode;
-  type = type.childContextTypes;
-  if ("function" !== typeof instance.getChildContext) return parentContext;
-  instance = instance.getChildContext();
-  for (var contextKey in instance)
-    if (!(contextKey in type))
-      throw Error(
-        (getComponentNameFromFiber(fiber) || "Unknown") +
-          '.getChildContext(): key "' +
-          contextKey +
-          '" is not defined in childContextTypes.'
-      );
-  return assign({}, parentContext, instance);
-}
-function pushContextProvider(workInProgress) {
-  workInProgress =
-    ((workInProgress = workInProgress.stateNode) &&
-      workInProgress.__reactInternalMemoizedMergedChildContext) ||
-    emptyContextObject;
-  previousContext = contextStackCursor$1.current;
-  push(contextStackCursor$1, workInProgress);
-  push(didPerformWorkStackCursor, didPerformWorkStackCursor.current);
-  return !0;
-}
-function invalidateContextProvider(workInProgress, type, didChange) {
-  var instance = workInProgress.stateNode;
-  if (!instance)
-    throw Error(
-      "Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue."
-    );
-  didChange
-    ? ((workInProgress = processChildContext(
-        workInProgress,
-        type,
-        previousContext
-      )),
-      (instance.__reactInternalMemoizedMergedChildContext = workInProgress),
-      pop(didPerformWorkStackCursor),
-      pop(contextStackCursor$1),
-      push(contextStackCursor$1, workInProgress))
-    : pop(didPerformWorkStackCursor);
-  push(didPerformWorkStackCursor, didChange);
-}
+var emptyContextObject = {};
 function is(x, y) {
   return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
 }
@@ -2291,6 +2044,7 @@ function flushSyncWorkAcrossRoots_impl(onlyLegacy) {
                       workInProgressRootRenderLanes$11,
                       workInProgressRootRecoverableErrors,
                       workInProgressTransitions,
+                      workInProgressRootDidIncludeRecursiveRenderUpdate,
                       workInProgressDeferredLane
                     ));
               }
@@ -2645,6 +2399,7 @@ function commitCallbacks(updateQueue, context) {
     )
       callCallback(callbacks[updateQueue], context);
 }
+var hasOwnProperty = Object.prototype.hasOwnProperty;
 function shallowEqual(objA, objB) {
   if (objectIs(objA, objB)) return !0;
   if (
@@ -2667,6 +2422,16 @@ function shallowEqual(objA, objB) {
   }
   return !0;
 }
+function describeComponentFrame(name, ownerName) {
+  var sourceInfo = "";
+  ownerName && (sourceInfo = " (created by " + ownerName + ")");
+  return "\n    in " + (name || "Unknown") + sourceInfo;
+}
+function describeFunctionComponentFrame(fn) {
+  return fn
+    ? describeComponentFrame(fn.displayName || fn.name || null, null)
+    : "";
+}
 function describeFiber(fiber) {
   switch (fiber.tag) {
     case 26:
@@ -2755,16 +2520,16 @@ function trackUsedThenable(thenableState, thenable, index) {
             }
           }
         );
-        switch (thenable.status) {
-          case "fulfilled":
-            return thenable.value;
-          case "rejected":
-            throw (
-              ((thenableState = thenable.reason),
-              checkIfUseWrappedInAsyncCatch(thenableState),
-              thenableState)
-            );
-        }
+      }
+      switch (thenable.status) {
+        case "fulfilled":
+          return thenable.value;
+        case "rejected":
+          throw (
+            ((thenableState = thenable.reason),
+            checkIfUseWrappedInAsyncCatch(thenableState),
+            thenableState)
+          );
       }
       suspendedThenable = thenable;
       throw SuspenseException;
@@ -2794,56 +2559,54 @@ function unwrapThenable(thenable) {
   null === thenableState$1 && (thenableState$1 = []);
   return trackUsedThenable(thenableState$1, thenable, index);
 }
-function coerceRef(returnFiber, current, element) {
-  returnFiber = element.ref;
-  if (
-    null !== returnFiber &&
-    "function" !== typeof returnFiber &&
-    "object" !== typeof returnFiber
-  ) {
-    if (element._owner) {
-      element = element._owner;
-      if (element) {
-        if (1 !== element.tag)
-          throw Error(
-            "Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref"
-          );
-        var inst = element.stateNode;
-      }
-      if (!inst)
-        throw Error(
-          "Missing owner for string ref " +
-            returnFiber +
-            ". This error is likely caused by a bug in React. Please file an issue."
-        );
-      var resolvedInst = inst,
-        stringRef = "" + returnFiber;
-      if (
-        null !== current &&
-        null !== current.ref &&
-        "function" === typeof current.ref &&
-        current.ref._stringRef === stringRef
-      )
-        return current.ref;
-      current = function (value) {
-        var refs = resolvedInst.refs;
-        null === value ? delete refs[stringRef] : (refs[stringRef] = value);
-      };
-      current._stringRef = stringRef;
-      return current;
-    }
-    if ("string" !== typeof returnFiber)
-      throw Error(
-        "Expected ref to be a function, a string, an object returned by React.createRef(), or null."
-      );
-    if (!element._owner)
-      throw Error(
-        "Element ref was specified as a string (" +
-          returnFiber +
-          ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information."
-      );
+function convertStringRefToCallbackRef(
+  returnFiber,
+  current,
+  element,
+  mixedRef
+) {
+  function ref(value) {
+    var refs = inst.refs;
+    null === value ? delete refs[stringRef] : (refs[stringRef] = value);
   }
-  return returnFiber;
+  var stringRef = "" + mixedRef;
+  returnFiber = element._owner;
+  if (!returnFiber)
+    throw Error(
+      "Element ref was specified as a string (" +
+        stringRef +
+        ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://react.dev/link/refs-must-have-owner for more information."
+    );
+  if (1 !== returnFiber.tag)
+    throw Error(
+      "Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://react.dev/link/strict-mode-string-ref"
+    );
+  var inst = returnFiber.stateNode;
+  if (!inst)
+    throw Error(
+      "Missing owner for string ref " +
+        stringRef +
+        ". This error is likely caused by a bug in React. Please file an issue."
+    );
+  if (
+    null !== current &&
+    null !== current.ref &&
+    "function" === typeof current.ref &&
+    current.ref._stringRef === stringRef
+  )
+    return current.ref;
+  ref._stringRef = stringRef;
+  return ref;
+}
+function coerceRef(returnFiber, current, workInProgress, element) {
+  var mixedRef = element.ref;
+  returnFiber =
+    "string" === typeof mixedRef ||
+    "number" === typeof mixedRef ||
+    "boolean" === typeof mixedRef
+      ? convertStringRefToCallbackRef(returnFiber, current, element, mixedRef)
+      : mixedRef;
+  workInProgress.ref = returnFiber;
 }
 function throwOnInvalidObjectType(returnFiber, newChild) {
   returnFiber = Object.prototype.toString.call(newChild);
@@ -2875,13 +2638,13 @@ function createChildReconciler(shouldTrackSideEffects) {
         (currentFirstChild = currentFirstChild.sibling);
     return null;
   }
-  function mapRemainingChildren(returnFiber, currentFirstChild) {
-    for (returnFiber = new Map(); null !== currentFirstChild; )
+  function mapRemainingChildren(currentFirstChild) {
+    for (var existingChildren = new Map(); null !== currentFirstChild; )
       null !== currentFirstChild.key
-        ? returnFiber.set(currentFirstChild.key, currentFirstChild)
-        : returnFiber.set(currentFirstChild.index, currentFirstChild),
+        ? existingChildren.set(currentFirstChild.key, currentFirstChild)
+        : existingChildren.set(currentFirstChild.index, currentFirstChild),
         (currentFirstChild = currentFirstChild.sibling);
-    return returnFiber;
+    return existingChildren;
   }
   function useFiber(fiber, pendingProps) {
     fiber = createWorkInProgress(fiber, pendingProps);
@@ -2941,7 +2704,7 @@ function createChildReconciler(shouldTrackSideEffects) {
     )
       return (
         (lanes = useFiber(current, element.props)),
-        (lanes.ref = coerceRef(returnFiber, current, element)),
+        coerceRef(returnFiber, current, lanes, element),
         (lanes.return = returnFiber),
         lanes
       );
@@ -2953,7 +2716,7 @@ function createChildReconciler(shouldTrackSideEffects) {
       returnFiber.mode,
       lanes
     );
-    lanes.ref = coerceRef(returnFiber, current, element);
+    coerceRef(returnFiber, current, lanes, element);
     lanes.return = returnFiber;
     return lanes;
   }
@@ -3015,7 +2778,7 @@ function createChildReconciler(shouldTrackSideEffects) {
               returnFiber.mode,
               lanes
             )),
-            (lanes.ref = coerceRef(returnFiber, null, newChild)),
+            coerceRef(returnFiber, null, lanes, newChild),
             (lanes.return = returnFiber),
             lanes
           );
@@ -3049,7 +2812,7 @@ function createChildReconciler(shouldTrackSideEffects) {
       if (newChild.$$typeof === REACT_CONTEXT_TYPE)
         return createChild(
           returnFiber,
-          readContextDuringReconcilation(returnFiber, newChild, lanes),
+          readContextDuringReconciliation(returnFiber, newChild, lanes),
           lanes
         );
       throwOnInvalidObjectType(returnFiber, newChild);
@@ -3096,7 +2859,7 @@ function createChildReconciler(shouldTrackSideEffects) {
         return updateSlot(
           returnFiber,
           oldFiber,
-          readContextDuringReconcilation(returnFiber, newChild, lanes),
+          readContextDuringReconciliation(returnFiber, newChild, lanes),
           lanes
         );
       throwOnInvalidObjectType(returnFiber, newChild);
@@ -3164,7 +2927,7 @@ function createChildReconciler(shouldTrackSideEffects) {
           existingChildren,
           returnFiber,
           newIdx,
-          readContextDuringReconcilation(returnFiber, newChild, lanes),
+          readContextDuringReconciliation(returnFiber, newChild, lanes),
           lanes
         );
       throwOnInvalidObjectType(returnFiber, newChild);
@@ -3230,7 +2993,7 @@ function createChildReconciler(shouldTrackSideEffects) {
       return resultingFirstChild;
     }
     for (
-      oldFiber = mapRemainingChildren(returnFiber, oldFiber);
+      oldFiber = mapRemainingChildren(oldFiber);
       newIdx < newChildren.length;
       newIdx++
     )
@@ -3318,7 +3081,7 @@ function createChildReconciler(shouldTrackSideEffects) {
       return iteratorFn;
     }
     for (
-      oldFiber = mapRemainingChildren(returnFiber, oldFiber);
+      oldFiber = mapRemainingChildren(oldFiber);
       !step.done;
       newIdx++, step = newChildrenIterable.next()
     )
@@ -3380,11 +3143,7 @@ function createChildReconciler(shouldTrackSideEffects) {
                 ) {
                   deleteRemainingChildren(returnFiber, child.sibling);
                   currentFirstChild = useFiber(child, newChild.props);
-                  currentFirstChild.ref = coerceRef(
-                    returnFiber,
-                    child,
-                    newChild
-                  );
+                  coerceRef(returnFiber, child, currentFirstChild, newChild);
                   currentFirstChild.return = returnFiber;
                   returnFiber = currentFirstChild;
                   break a;
@@ -3411,11 +3170,7 @@ function createChildReconciler(shouldTrackSideEffects) {
                   returnFiber.mode,
                   lanes
                 )),
-                (lanes.ref = coerceRef(
-                  returnFiber,
-                  currentFirstChild,
-                  newChild
-                )),
+                coerceRef(returnFiber, currentFirstChild, lanes, newChild),
                 (lanes.return = returnFiber),
                 (returnFiber = lanes));
           }
@@ -3461,7 +3216,7 @@ function createChildReconciler(shouldTrackSideEffects) {
         case REACT_LAZY_TYPE:
           return (
             (child = newChild._init),
-            reconcileChildFibers(
+            reconcileChildFibersImpl(
               returnFiber,
               currentFirstChild,
               child(newChild._payload),
@@ -3494,7 +3249,7 @@ function createChildReconciler(shouldTrackSideEffects) {
         return reconcileChildFibersImpl(
           returnFiber,
           currentFirstChild,
-          readContextDuringReconcilation(returnFiber, newChild, lanes),
+          readContextDuringReconciliation(returnFiber, newChild, lanes),
           lanes
         );
       throwOnInvalidObjectType(returnFiber, newChild);
@@ -3518,12 +3273,7 @@ function createChildReconciler(shouldTrackSideEffects) {
         placeSingleChild(returnFiber))
       : deleteRemainingChildren(returnFiber, currentFirstChild);
   }
-  function reconcileChildFibers(
-    returnFiber,
-    currentFirstChild,
-    newChild,
-    lanes
-  ) {
+  return function (returnFiber, currentFirstChild, newChild, lanes) {
     thenableIndexCounter$1 = 0;
     returnFiber = reconcileChildFibersImpl(
       returnFiber,
@@ -3533,8 +3283,7 @@ function createChildReconciler(shouldTrackSideEffects) {
     );
     thenableState$1 = null;
     return returnFiber;
-  }
-  return reconcileChildFibers;
+  };
 }
 var reconcileChildFibers = createChildReconciler(!0),
   mountChildFibers = createChildReconciler(!1),
@@ -3627,7 +3376,7 @@ var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher,
   globalClientIdCounter = 0;
 function throwInvalidHookError() {
   throw Error(
-    "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem."
+    "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
   );
 }
 function areHookInputsEqual(nextDeps, prevDeps) {
@@ -4516,30 +4265,17 @@ function checkShouldComponentUpdate(
     : !0;
 }
 function constructClassInstance(workInProgress, ctor, props) {
-  var isLegacyContextConsumer = !1,
-    unmaskedContext = emptyContextObject;
-  var context = ctor.contextType;
-  "object" === typeof context && null !== context
-    ? (context = readContext(context))
-    : ((unmaskedContext = isContextProvider(ctor)
-        ? previousContext
-        : contextStackCursor$1.current),
-      (isLegacyContextConsumer = ctor.contextTypes),
-      (context = (isLegacyContextConsumer =
-        null !== isLegacyContextConsumer && void 0 !== isLegacyContextConsumer)
-        ? getMaskedContext(workInProgress, unmaskedContext)
-        : emptyContextObject));
+  var context = emptyContextObject,
+    contextType = ctor.contextType;
+  "object" === typeof contextType &&
+    null !== contextType &&
+    (context = readContext(contextType));
   ctor = new ctor(props, context);
   workInProgress.memoizedState =
     null !== ctor.state && void 0 !== ctor.state ? ctor.state : null;
   ctor.updater = classComponentUpdater;
   workInProgress.stateNode = ctor;
   ctor._reactInternals = workInProgress;
-  isLegacyContextConsumer &&
-    ((workInProgress = workInProgress.stateNode),
-    (workInProgress.__reactInternalMemoizedUnmaskedChildContext =
-      unmaskedContext),
-    (workInProgress.__reactInternalMemoizedMaskedChildContext = context));
   return ctor;
 }
 function callComponentWillReceiveProps(
@@ -4563,12 +4299,10 @@ function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {
   instance.refs = {};
   initializeUpdateQueue(workInProgress);
   var contextType = ctor.contextType;
-  "object" === typeof contextType && null !== contextType
-    ? (instance.context = readContext(contextType))
-    : ((contextType = isContextProvider(ctor)
-        ? previousContext
-        : contextStackCursor$1.current),
-      (instance.context = getMaskedContext(workInProgress, contextType)));
+  instance.context =
+    "object" === typeof contextType && null !== contextType
+      ? readContext(contextType)
+      : emptyContextObject;
   instance.state = workInProgress.memoizedState;
   contextType = ctor.getDerivedStateFromProps;
   "function" === typeof contextType &&
@@ -4590,12 +4324,23 @@ function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {
   "function" === typeof instance.componentDidMount &&
     (workInProgress.flags |= 4194308);
 }
+var CapturedStacks = new WeakMap();
 function createCapturedValueAtFiber(value, source) {
+  if ("object" === typeof value && null !== value) {
+    var stack = CapturedStacks.get(value);
+    "string" !== typeof stack &&
+      ((stack = getStackByFiberInDevAndProd(source)),
+      CapturedStacks.set(value, stack));
+  } else stack = getStackByFiberInDevAndProd(source);
+  return { value: value, source: source, stack: stack, digest: null };
+}
+function createCapturedValueFromError(value, digest, stack) {
+  "string" === typeof stack && CapturedStacks.set(value, stack);
   return {
     value: value,
-    source: source,
-    stack: getStackByFiberInDevAndProd(source),
-    digest: null
+    source: null,
+    stack: null != stack ? stack : null,
+    digest: null != digest ? digest : null
   };
 }
 if (
@@ -4941,7 +4686,7 @@ function updateOffscreenComponent(current, workInProgress, renderLanes) {
     nextChildren = nextProps.children,
     nextIsDetached = 0 !== (workInProgress.stateNode._pendingVisibility & 2),
     prevState = null !== current ? current.memoizedState : null;
-  markRef$1(current, workInProgress);
+  markRef(current, workInProgress);
   if ("hidden" === nextProps.mode || nextIsDetached) {
     if (0 !== (workInProgress.flags & 128)) {
       renderLanes =
@@ -4995,13 +4740,20 @@ function deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes) {
   pushOffscreenSuspenseHandler(workInProgress);
   return null;
 }
-function markRef$1(current, workInProgress) {
+function markRef(current, workInProgress) {
   var ref = workInProgress.ref;
-  if (
-    (null === current && null !== ref) ||
-    (null !== current && current.ref !== ref)
-  )
-    (workInProgress.flags |= 512), (workInProgress.flags |= 2097152);
+  if (null === ref)
+    null !== current &&
+      null !== current.ref &&
+      (workInProgress.flags |= 2097664);
+  else {
+    if ("function" !== typeof ref && "object" !== typeof ref)
+      throw Error(
+        "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
+      );
+    if (null === current || current.ref !== ref)
+      workInProgress.flags |= 2097664;
+  }
 }
 function updateFunctionComponent(
   current,
@@ -5010,17 +4762,13 @@ function updateFunctionComponent(
   nextProps,
   renderLanes
 ) {
-  var context = isContextProvider(Component)
-    ? previousContext
-    : contextStackCursor$1.current;
-  context = getMaskedContext(workInProgress, context);
   prepareToReadContext(workInProgress, renderLanes);
   Component = renderWithHooks(
     current,
     workInProgress,
     Component,
     nextProps,
-    context,
+    void 0,
     renderLanes
   );
   if (null !== current && !didReceiveUpdate)
@@ -5064,10 +4812,6 @@ function updateClassComponent(
   nextProps,
   renderLanes
 ) {
-  if (isContextProvider(Component)) {
-    var hasContext = !0;
-    pushContextProvider(workInProgress);
-  } else hasContext = !1;
   prepareToReadContext(workInProgress, renderLanes);
   if (null === workInProgress.stateNode)
     resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress),
@@ -5079,36 +4823,30 @@ function updateClassComponent(
       oldProps = workInProgress.memoizedProps;
     instance.props = oldProps;
     var oldContext = instance.context,
-      contextType = Component.contextType;
-    "object" === typeof contextType && null !== contextType
-      ? (contextType = readContext(contextType))
-      : ((contextType = isContextProvider(Component)
-          ? previousContext
-          : contextStackCursor$1.current),
-        (contextType = getMaskedContext(workInProgress, contextType)));
-    var getDerivedStateFromProps = Component.getDerivedStateFromProps,
-      hasNewLifecycles =
-        "function" === typeof getDerivedStateFromProps ||
-        "function" === typeof instance.getSnapshotBeforeUpdate;
-    hasNewLifecycles ||
+      contextType = Component.contextType,
+      nextContext = emptyContextObject;
+    "object" === typeof contextType &&
+      null !== contextType &&
+      (nextContext = readContext(contextType));
+    var getDerivedStateFromProps = Component.getDerivedStateFromProps;
+    (contextType =
+      "function" === typeof getDerivedStateFromProps ||
+      "function" === typeof instance.getSnapshotBeforeUpdate) ||
       ("function" !== typeof instance.UNSAFE_componentWillReceiveProps &&
         "function" !== typeof instance.componentWillReceiveProps) ||
-      ((oldProps !== nextProps || oldContext !== contextType) &&
+      ((oldProps !== nextProps || oldContext !== nextContext) &&
         callComponentWillReceiveProps(
           workInProgress,
           instance,
           nextProps,
-          contextType
+          nextContext
         ));
     hasForceUpdate = !1;
     var oldState = workInProgress.memoizedState;
     instance.state = oldState;
     processUpdateQueue(workInProgress, nextProps, instance, renderLanes);
     oldContext = workInProgress.memoizedState;
-    oldProps !== nextProps ||
-    oldState !== oldContext ||
-    didPerformWorkStackCursor.current ||
-    hasForceUpdate
+    oldProps !== nextProps || oldState !== oldContext || hasForceUpdate
       ? ("function" === typeof getDerivedStateFromProps &&
           (applyDerivedStateFromProps(
             workInProgress,
@@ -5126,9 +4864,9 @@ function updateClassComponent(
             nextProps,
             oldState,
             oldContext,
-            contextType
+            nextContext
           ))
-          ? (hasNewLifecycles ||
+          ? (contextType ||
               ("function" !== typeof instance.UNSAFE_componentWillMount &&
                 "function" !== typeof instance.componentWillMount) ||
               ("function" === typeof instance.componentWillMount &&
@@ -5143,7 +4881,7 @@ function updateClassComponent(
             (workInProgress.memoizedState = oldContext)),
         (instance.props = nextProps),
         (instance.state = oldContext),
-        (instance.context = contextType),
+        (instance.context = nextContext),
         (nextProps = oldProps))
       : ("function" === typeof instance.componentDidMount &&
           (workInProgress.flags |= 4194308),
@@ -5151,48 +4889,46 @@ function updateClassComponent(
   } else {
     instance = workInProgress.stateNode;
     cloneUpdateQueue(current, workInProgress);
-    oldProps = workInProgress.memoizedProps;
+    nextContext = workInProgress.memoizedProps;
     contextType =
       workInProgress.type === workInProgress.elementType
-        ? oldProps
-        : resolveDefaultProps(workInProgress.type, oldProps);
+        ? nextContext
+        : resolveDefaultProps(workInProgress.type, nextContext);
     instance.props = contextType;
-    hasNewLifecycles = workInProgress.pendingProps;
-    oldState = instance.context;
+    getDerivedStateFromProps = workInProgress.pendingProps;
+    var oldContext$jscomp$0 = instance.context;
     oldContext = Component.contextType;
-    "object" === typeof oldContext && null !== oldContext
-      ? (oldContext = readContext(oldContext))
-      : ((oldContext = isContextProvider(Component)
-          ? previousContext
-          : contextStackCursor$1.current),
-        (oldContext = getMaskedContext(workInProgress, oldContext)));
-    var getDerivedStateFromProps$jscomp$0 = Component.getDerivedStateFromProps;
-    (getDerivedStateFromProps =
-      "function" === typeof getDerivedStateFromProps$jscomp$0 ||
+    oldProps = emptyContextObject;
+    "object" === typeof oldContext &&
+      null !== oldContext &&
+      (oldProps = readContext(oldContext));
+    oldState = Component.getDerivedStateFromProps;
+    (oldContext =
+      "function" === typeof oldState ||
       "function" === typeof instance.getSnapshotBeforeUpdate) ||
       ("function" !== typeof instance.UNSAFE_componentWillReceiveProps &&
         "function" !== typeof instance.componentWillReceiveProps) ||
-      ((oldProps !== hasNewLifecycles || oldState !== oldContext) &&
+      ((nextContext !== getDerivedStateFromProps ||
+        oldContext$jscomp$0 !== oldProps) &&
         callComponentWillReceiveProps(
           workInProgress,
           instance,
           nextProps,
-          oldContext
+          oldProps
         ));
     hasForceUpdate = !1;
-    oldState = workInProgress.memoizedState;
-    instance.state = oldState;
+    oldContext$jscomp$0 = workInProgress.memoizedState;
+    instance.state = oldContext$jscomp$0;
     processUpdateQueue(workInProgress, nextProps, instance, renderLanes);
     var newState = workInProgress.memoizedState;
-    oldProps !== hasNewLifecycles ||
-    oldState !== newState ||
-    didPerformWorkStackCursor.current ||
+    nextContext !== getDerivedStateFromProps ||
+    oldContext$jscomp$0 !== newState ||
     hasForceUpdate
-      ? ("function" === typeof getDerivedStateFromProps$jscomp$0 &&
+      ? ("function" === typeof oldState &&
           (applyDerivedStateFromProps(
             workInProgress,
             Component,
-            getDerivedStateFromProps$jscomp$0,
+            oldState,
             nextProps
           ),
           (newState = workInProgress.memoizedState)),
@@ -5203,47 +4939,47 @@ function updateClassComponent(
             Component,
             contextType,
             nextProps,
-            oldState,
+            oldContext$jscomp$0,
             newState,
-            oldContext
+            oldProps
           ) ||
           !1)
-          ? (getDerivedStateFromProps ||
+          ? (oldContext ||
               ("function" !== typeof instance.UNSAFE_componentWillUpdate &&
                 "function" !== typeof instance.componentWillUpdate) ||
               ("function" === typeof instance.componentWillUpdate &&
-                instance.componentWillUpdate(nextProps, newState, oldContext),
+                instance.componentWillUpdate(nextProps, newState, oldProps),
               "function" === typeof instance.UNSAFE_componentWillUpdate &&
                 instance.UNSAFE_componentWillUpdate(
                   nextProps,
                   newState,
-                  oldContext
+                  oldProps
                 )),
             "function" === typeof instance.componentDidUpdate &&
               (workInProgress.flags |= 4),
             "function" === typeof instance.getSnapshotBeforeUpdate &&
               (workInProgress.flags |= 1024))
           : ("function" !== typeof instance.componentDidUpdate ||
-              (oldProps === current.memoizedProps &&
-                oldState === current.memoizedState) ||
+              (nextContext === current.memoizedProps &&
+                oldContext$jscomp$0 === current.memoizedState) ||
               (workInProgress.flags |= 4),
             "function" !== typeof instance.getSnapshotBeforeUpdate ||
-              (oldProps === current.memoizedProps &&
-                oldState === current.memoizedState) ||
+              (nextContext === current.memoizedProps &&
+                oldContext$jscomp$0 === current.memoizedState) ||
               (workInProgress.flags |= 1024),
             (workInProgress.memoizedProps = nextProps),
             (workInProgress.memoizedState = newState)),
         (instance.props = nextProps),
         (instance.state = newState),
-        (instance.context = oldContext),
+        (instance.context = oldProps),
         (nextProps = contextType))
       : ("function" !== typeof instance.componentDidUpdate ||
-          (oldProps === current.memoizedProps &&
-            oldState === current.memoizedState) ||
+          (nextContext === current.memoizedProps &&
+            oldContext$jscomp$0 === current.memoizedState) ||
           (workInProgress.flags |= 4),
         "function" !== typeof instance.getSnapshotBeforeUpdate ||
-          (oldProps === current.memoizedProps &&
-            oldState === current.memoizedState) ||
+          (nextContext === current.memoizedProps &&
+            oldContext$jscomp$0 === current.memoizedState) ||
           (workInProgress.flags |= 1024),
         (nextProps = !1));
   }
@@ -5252,7 +4988,7 @@ function updateClassComponent(
     workInProgress,
     Component,
     nextProps,
-    hasContext,
+    !1,
     renderLanes
   );
 }
@@ -5264,21 +5000,18 @@ function finishClassComponent(
   hasContext,
   renderLanes
 ) {
-  markRef$1(current, workInProgress);
-  var didCaptureError = 0 !== (workInProgress.flags & 128);
-  if (!shouldUpdate && !didCaptureError)
-    return (
-      hasContext && invalidateContextProvider(workInProgress, Component, !1),
-      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
-    );
+  markRef(current, workInProgress);
+  hasContext = 0 !== (workInProgress.flags & 128);
+  if (!shouldUpdate && !hasContext)
+    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
   shouldUpdate = workInProgress.stateNode;
   ReactCurrentOwner$1.current = workInProgress;
-  var nextChildren =
-    didCaptureError && "function" !== typeof Component.getDerivedStateFromError
+  Component =
+    hasContext && "function" !== typeof Component.getDerivedStateFromError
       ? null
       : shouldUpdate.render();
   workInProgress.flags |= 1;
-  null !== current && didCaptureError
+  null !== current && hasContext
     ? ((workInProgress.child = reconcileChildFibers(
         workInProgress,
         current.child,
@@ -5288,26 +5021,13 @@ function finishClassComponent(
       (workInProgress.child = reconcileChildFibers(
         workInProgress,
         null,
-        nextChildren,
+        Component,
         renderLanes
       )))
-    : reconcileChildren(current, workInProgress, nextChildren, renderLanes);
+    : reconcileChildren(current, workInProgress, Component, renderLanes);
   workInProgress.memoizedState = shouldUpdate.state;
-  hasContext && invalidateContextProvider(workInProgress, Component, !0);
   return workInProgress.child;
 }
-function pushHostRootContext(workInProgress) {
-  var root = workInProgress.stateNode;
-  root.pendingContext
-    ? pushTopLevelContextObject(
-        workInProgress,
-        root.pendingContext,
-        root.pendingContext !== root.context
-      )
-    : root.context &&
-      pushTopLevelContextObject(workInProgress, root.context, !1);
-  pushHostContainer(workInProgress, root.containerInfo);
-}
 var SUSPENDED_MARKER = { dehydrated: null, treeContext: null, retryLane: 0 };
 function mountSuspenseOffscreenState(renderLanes) {
   return { baseLanes: renderLanes, cachePool: null };
@@ -5499,18 +5219,16 @@ function updateDehydratedSuspenseComponent(
       return (
         pushPrimaryTreeSuspenseHandler(workInProgress),
         (workInProgress.flags &= -257),
+        (didPrimaryChildrenDefer = createCapturedValueFromError(
+          Error(
+            "There was an error while hydrating this Suspense boundary. Switched to client rendering."
+          )
+        )),
         retrySuspenseComponentWithoutHydrating(
           current,
           workInProgress,
           renderLanes,
-          {
-            value: Error(
-              "There was an error while hydrating this Suspense boundary. Switched to client rendering."
-            ),
-            source: null,
-            stack: null,
-            digest: null
-          }
+          didPrimaryChildrenDefer
         )
       );
     if (null !== workInProgress.memoizedState)
@@ -5567,17 +5285,16 @@ function updateDehydratedSuspenseComponent(
         "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."
       )),
       (suspenseState.digest = didPrimaryChildrenDefer),
+      (didPrimaryChildrenDefer = createCapturedValueFromError(
+        suspenseState,
+        didPrimaryChildrenDefer,
+        void 0
+      )),
       retrySuspenseComponentWithoutHydrating(
         current,
         workInProgress,
         renderLanes,
-        {
-          value: suspenseState,
-          source: null,
-          stack: null,
-          digest:
-            null != didPrimaryChildrenDefer ? didPrimaryChildrenDefer : null
-        }
+        didPrimaryChildrenDefer
       )
     );
   didPrimaryChildrenDefer = 0 !== (renderLanes & current.childLanes);
@@ -5807,29 +5524,25 @@ function attemptEarlyBailoutIfNoScheduledUpdate(
 ) {
   switch (workInProgress.tag) {
     case 3:
-      pushHostRootContext(workInProgress);
+      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
       break;
     case 27:
     case 5:
       pushHostContext(workInProgress);
       break;
-    case 1:
-      isContextProvider(workInProgress.type) &&
-        pushContextProvider(workInProgress);
-      break;
     case 4:
       pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
       break;
     case 10:
-      var context = workInProgress.type._context,
-        nextValue = workInProgress.memoizedProps.value;
+      var newValue = workInProgress.memoizedProps.value,
+        context = workInProgress.type._context;
       push(valueCursor, context._currentValue);
-      context._currentValue = nextValue;
+      context._currentValue = newValue;
       break;
     case 13:
-      context = workInProgress.memoizedState;
-      if (null !== context) {
-        if (null !== context.dehydrated)
+      newValue = workInProgress.memoizedState;
+      if (null !== newValue) {
+        if (null !== newValue.dehydrated)
           return (
             pushPrimaryTreeSuspenseHandler(workInProgress),
             (workInProgress.flags |= 128),
@@ -5848,9 +5561,9 @@ function attemptEarlyBailoutIfNoScheduledUpdate(
       pushPrimaryTreeSuspenseHandler(workInProgress);
       break;
     case 19:
-      context = 0 !== (renderLanes & workInProgress.childLanes);
+      newValue = 0 !== (renderLanes & workInProgress.childLanes);
       if (0 !== (current.flags & 128)) {
-        if (context)
+        if (newValue)
           return updateSuspenseListComponent(
             current,
             workInProgress,
@@ -5858,13 +5571,13 @@ function attemptEarlyBailoutIfNoScheduledUpdate(
           );
         workInProgress.flags |= 128;
       }
-      nextValue = workInProgress.memoizedState;
-      null !== nextValue &&
-        ((nextValue.rendering = null),
-        (nextValue.tail = null),
-        (nextValue.lastEffect = null));
+      context = workInProgress.memoizedState;
+      null !== context &&
+        ((context.rendering = null),
+        (context.tail = null),
+        (context.lastEffect = null));
       push(suspenseStackCursor, suspenseStackCursor.current);
-      if (context) break;
+      if (newValue) break;
       else return null;
     case 22:
     case 23:
@@ -5875,3285 +5588,3260 @@ function attemptEarlyBailoutIfNoScheduledUpdate(
   }
   return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
 }
-var valueCursor = createCursor(null),
-  currentlyRenderingFiber = null,
-  lastContextDependency = null,
-  lastFullyObservedContext = null;
-function resetContextDependencies() {
-  lastFullyObservedContext =
-    lastContextDependency =
-    currentlyRenderingFiber =
-      null;
-}
-function popProvider(context) {
-  context._currentValue = valueCursor.current;
-  pop(valueCursor);
-}
-function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {
-  for (; null !== parent; ) {
-    var alternate = parent.alternate;
-    (parent.childLanes & renderLanes) !== renderLanes
-      ? ((parent.childLanes |= renderLanes),
-        null !== alternate && (alternate.childLanes |= renderLanes))
-      : null !== alternate &&
-        (alternate.childLanes & renderLanes) !== renderLanes &&
-        (alternate.childLanes |= renderLanes);
-    if (parent === propagationRoot) break;
-    parent = parent.return;
-  }
-}
-function prepareToReadContext(workInProgress, renderLanes) {
-  currentlyRenderingFiber = workInProgress;
-  lastFullyObservedContext = lastContextDependency = null;
-  workInProgress = workInProgress.dependencies;
-  null !== workInProgress &&
-    null !== workInProgress.firstContext &&
-    (0 !== (workInProgress.lanes & renderLanes) && (didReceiveUpdate = !0),
-    (workInProgress.firstContext = null));
-}
-function readContext(context) {
-  return readContextForConsumer(currentlyRenderingFiber, context);
-}
-function readContextDuringReconcilation(consumer, context, renderLanes) {
-  null === currentlyRenderingFiber &&
-    prepareToReadContext(consumer, renderLanes);
-  return readContextForConsumer(consumer, context);
-}
-function readContextForConsumer(consumer, context) {
-  var value = context._currentValue;
-  if (lastFullyObservedContext !== context)
-    if (
-      ((context = { context: context, memoizedValue: value, next: null }),
-      null === lastContextDependency)
-    ) {
-      if (null === consumer)
-        throw Error(
-          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
+function beginWork(current, workInProgress, renderLanes) {
+  if (null !== current)
+    if (current.memoizedProps !== workInProgress.pendingProps)
+      didReceiveUpdate = !0;
+    else {
+      if (
+        0 === (current.lanes & renderLanes) &&
+        0 === (workInProgress.flags & 128)
+      )
+        return (
+          (didReceiveUpdate = !1),
+          attemptEarlyBailoutIfNoScheduledUpdate(
+            current,
+            workInProgress,
+            renderLanes
+          )
         );
-      lastContextDependency = context;
-      consumer.dependencies = { lanes: 0, firstContext: context };
-    } else lastContextDependency = lastContextDependency.next = context;
-  return value;
-}
-var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
-function handleAsyncAction() {}
-function scheduleRetryEffect(workInProgress, retryQueue) {
-  null !== retryQueue
-    ? (workInProgress.flags |= 4)
-    : workInProgress.flags & 16384 &&
-      ((retryQueue =
-        22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),
-      (workInProgress.lanes |= retryQueue));
-}
-function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
-  switch (renderState.tailMode) {
-    case "hidden":
-      hasRenderedATailFallback = renderState.tail;
-      for (var lastTailNode = null; null !== hasRenderedATailFallback; )
-        null !== hasRenderedATailFallback.alternate &&
-          (lastTailNode = hasRenderedATailFallback),
-          (hasRenderedATailFallback = hasRenderedATailFallback.sibling);
-      null === lastTailNode
-        ? (renderState.tail = null)
-        : (lastTailNode.sibling = null);
-      break;
-    case "collapsed":
-      lastTailNode = renderState.tail;
-      for (var lastTailNode$61 = null; null !== lastTailNode; )
-        null !== lastTailNode.alternate && (lastTailNode$61 = lastTailNode),
-          (lastTailNode = lastTailNode.sibling);
-      null === lastTailNode$61
-        ? hasRenderedATailFallback || null === renderState.tail
-          ? (renderState.tail = null)
-          : (renderState.tail.sibling = null)
-        : (lastTailNode$61.sibling = null);
-  }
-}
-function bubbleProperties(completedWork) {
-  var didBailout =
-      null !== completedWork.alternate &&
-      completedWork.alternate.child === completedWork.child,
-    newChildLanes = 0,
-    subtreeFlags = 0;
-  if (didBailout)
-    for (var child$62 = completedWork.child; null !== child$62; )
-      (newChildLanes |= child$62.lanes | child$62.childLanes),
-        (subtreeFlags |= child$62.subtreeFlags & 31457280),
-        (subtreeFlags |= child$62.flags & 31457280),
-        (child$62.return = completedWork),
-        (child$62 = child$62.sibling);
-  else
-    for (child$62 = completedWork.child; null !== child$62; )
-      (newChildLanes |= child$62.lanes | child$62.childLanes),
-        (subtreeFlags |= child$62.subtreeFlags),
-        (subtreeFlags |= child$62.flags),
-        (child$62.return = completedWork),
-        (child$62 = child$62.sibling);
-  completedWork.subtreeFlags |= subtreeFlags;
-  completedWork.childLanes = newChildLanes;
-  return didBailout;
-}
-function completeWork(current, workInProgress, renderLanes) {
-  var newProps = workInProgress.pendingProps;
+      didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;
+    }
+  else didReceiveUpdate = !1;
+  workInProgress.lanes = 0;
   switch (workInProgress.tag) {
     case 2:
+      var Component = workInProgress.type;
+      resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress);
+      current = workInProgress.pendingProps;
+      prepareToReadContext(workInProgress, renderLanes);
+      var value = renderWithHooks(
+        null,
+        workInProgress,
+        Component,
+        current,
+        void 0,
+        renderLanes
+      );
+      workInProgress.flags |= 1;
+      "object" === typeof value &&
+      null !== value &&
+      "function" === typeof value.render &&
+      void 0 === value.$$typeof
+        ? ((workInProgress.tag = 1),
+          (workInProgress.memoizedState = null),
+          (workInProgress.updateQueue = null),
+          (workInProgress.memoizedState =
+            null !== value.state && void 0 !== value.state
+              ? value.state
+              : null),
+          initializeUpdateQueue(workInProgress),
+          (value.updater = classComponentUpdater),
+          (workInProgress.stateNode = value),
+          (value._reactInternals = workInProgress),
+          mountClassInstance(workInProgress, Component, current, renderLanes),
+          (workInProgress = finishClassComponent(
+            null,
+            workInProgress,
+            Component,
+            !0,
+            !1,
+            renderLanes
+          )))
+        : ((workInProgress.tag = 0),
+          reconcileChildren(null, workInProgress, value, renderLanes),
+          (workInProgress = workInProgress.child));
+      return workInProgress;
     case 16:
-    case 15:
+      Component = workInProgress.elementType;
+      a: {
+        resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress);
+        current = workInProgress.pendingProps;
+        value = Component._init;
+        Component = value(Component._payload);
+        workInProgress.type = Component;
+        value = workInProgress.tag = resolveLazyComponentTag(Component);
+        current = resolveDefaultProps(Component, current);
+        switch (value) {
+          case 0:
+            workInProgress = updateFunctionComponent(
+              null,
+              workInProgress,
+              Component,
+              current,
+              renderLanes
+            );
+            break a;
+          case 1:
+            workInProgress = updateClassComponent(
+              null,
+              workInProgress,
+              Component,
+              current,
+              renderLanes
+            );
+            break a;
+          case 11:
+            workInProgress = updateForwardRef(
+              null,
+              workInProgress,
+              Component,
+              current,
+              renderLanes
+            );
+            break a;
+          case 14:
+            workInProgress = updateMemoComponent(
+              null,
+              workInProgress,
+              Component,
+              resolveDefaultProps(Component.type, current),
+              renderLanes
+            );
+            break a;
+        }
+        throw Error(
+          "Element type is invalid. Received a promise that resolves to: " +
+            Component +
+            ". Lazy element type must resolve to a class or function."
+        );
+      }
+      return workInProgress;
     case 0:
-    case 11:
-    case 7:
-    case 8:
-    case 12:
-    case 9:
-    case 14:
-      return bubbleProperties(workInProgress), null;
-    case 1:
       return (
-        isContextProvider(workInProgress.type) && popContext(),
-        bubbleProperties(workInProgress),
-        null
+        (Component = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === Component
+            ? value
+            : resolveDefaultProps(Component, value)),
+        updateFunctionComponent(
+          current,
+          workInProgress,
+          Component,
+          value,
+          renderLanes
+        )
       );
-    case 3:
+    case 1:
       return (
-        (renderLanes = workInProgress.stateNode),
-        popHostContainer(),
-        pop(didPerformWorkStackCursor),
-        pop(contextStackCursor$1),
-        renderLanes.pendingContext &&
-          ((renderLanes.context = renderLanes.pendingContext),
-          (renderLanes.pendingContext = null)),
-        (null !== current && null !== current.child) ||
-          null === current ||
-          (current.memoizedState.isDehydrated &&
-            0 === (workInProgress.flags & 256)) ||
-          ((workInProgress.flags |= 1024),
-          null !== hydrationErrors &&
-            (queueRecoverableErrors(hydrationErrors),
-            (hydrationErrors = null))),
-        bubbleProperties(workInProgress),
-        null
+        (Component = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === Component
+            ? value
+            : resolveDefaultProps(Component, value)),
+        updateClassComponent(
+          current,
+          workInProgress,
+          Component,
+          value,
+          renderLanes
+        )
       );
+    case 3:
+      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
+      if (null === current)
+        throw Error("Should have a current fiber. This is a bug in React.");
+      value = workInProgress.pendingProps;
+      Component = workInProgress.memoizedState.element;
+      cloneUpdateQueue(current, workInProgress);
+      processUpdateQueue(workInProgress, value, null, renderLanes);
+      value = workInProgress.memoizedState.element;
+      value === Component
+        ? (workInProgress = bailoutOnAlreadyFinishedWork(
+            current,
+            workInProgress,
+            renderLanes
+          ))
+        : (reconcileChildren(current, workInProgress, value, renderLanes),
+          (workInProgress = workInProgress.child));
+      return workInProgress;
     case 26:
     case 27:
     case 5:
-      popHostContext(workInProgress);
-      var type = workInProgress.type;
-      if (null !== current && null != workInProgress.stateNode)
-        current.memoizedProps !== newProps && (workInProgress.flags |= 4),
-          current.ref !== workInProgress.ref &&
-            (workInProgress.flags |= 2097664);
-      else {
-        if (!newProps) {
-          if (null === workInProgress.stateNode)
-            throw Error(
-              "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
-            );
-          bubbleProperties(workInProgress);
-          return null;
-        }
-        current = rootInstanceStackCursor.current;
-        renderLanes = allocateTag();
-        type = getViewConfigForType(type);
-        var updatePayload = diffProperties(
-          null,
-          emptyObject,
-          newProps,
-          type.validAttributes
-        );
-        ReactNativePrivateInterface.UIManager.createView(
-          renderLanes,
-          type.uiViewClassName,
-          current,
-          updatePayload
-        );
-        current = new ReactNativeFiberHostComponent(
-          renderLanes,
-          type,
-          workInProgress
-        );
-        instanceCache.set(renderLanes, workInProgress);
-        instanceProps.set(renderLanes, newProps);
-        a: for (renderLanes = workInProgress.child; null !== renderLanes; ) {
-          if (5 === renderLanes.tag || 6 === renderLanes.tag)
-            current._children.push(renderLanes.stateNode);
-          else if (4 !== renderLanes.tag && null !== renderLanes.child) {
-            renderLanes.child.return = renderLanes;
-            renderLanes = renderLanes.child;
-            continue;
-          }
-          if (renderLanes === workInProgress) break a;
-          for (; null === renderLanes.sibling; ) {
-            if (
-              null === renderLanes.return ||
-              renderLanes.return === workInProgress
-            )
-              break a;
-            renderLanes = renderLanes.return;
-          }
-          renderLanes.sibling.return = renderLanes.return;
-          renderLanes = renderLanes.sibling;
-        }
-        workInProgress.stateNode = current;
-        finalizeInitialChildren(current) && (workInProgress.flags |= 4);
-        null !== workInProgress.ref && (workInProgress.flags |= 2097664);
-      }
-      bubbleProperties(workInProgress);
-      workInProgress.flags &= -16777217;
-      return null;
+      return (
+        pushHostContext(workInProgress),
+        (Component = workInProgress.pendingProps.children),
+        markRef(current, workInProgress),
+        reconcileChildren(current, workInProgress, Component, renderLanes),
+        workInProgress.child
+      );
     case 6:
-      if (current && null != workInProgress.stateNode)
-        current.memoizedProps !== newProps && (workInProgress.flags |= 4);
-      else {
-        if ("string" !== typeof newProps && null === workInProgress.stateNode)
-          throw Error(
-            "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
-          );
-        renderLanes = rootInstanceStackCursor.current;
-        if (!contextStackCursor.current.isInAParentText)
-          throw Error(
-            "Text strings must be rendered within a <Text> component."
-          );
-        current = allocateTag();
-        ReactNativePrivateInterface.UIManager.createView(
-          current,
-          "RCTRawText",
-          renderLanes,
-          { text: newProps }
-        );
-        instanceCache.set(current, workInProgress);
-        workInProgress.stateNode = current;
-      }
-      bubbleProperties(workInProgress);
       return null;
     case 13:
-      popSuspenseHandler(workInProgress);
-      newProps = workInProgress.memoizedState;
-      if (
-        null === current ||
-        (null !== current.memoizedState &&
-          null !== current.memoizedState.dehydrated)
-      ) {
-        if (null !== newProps && null !== newProps.dehydrated) {
-          if (null === current) {
-            throw Error(
-              "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
-            );
-            throw Error(
-              "Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
-            );
-          }
-          0 === (workInProgress.flags & 128) &&
-            (workInProgress.memoizedState = null);
-          workInProgress.flags |= 4;
-          bubbleProperties(workInProgress);
-          type = !1;
-        } else
-          null !== hydrationErrors &&
-            (queueRecoverableErrors(hydrationErrors), (hydrationErrors = null)),
-            (type = !0);
-        if (!type) return workInProgress.flags & 256 ? workInProgress : null;
-      }
-      if (0 !== (workInProgress.flags & 128))
-        return (workInProgress.lanes = renderLanes), workInProgress;
-      renderLanes = null !== newProps;
-      renderLanes !== (null !== current && null !== current.memoizedState) &&
-        renderLanes &&
-        (workInProgress.child.flags |= 8192);
-      scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
-      bubbleProperties(workInProgress);
-      return null;
+      return updateSuspenseComponent(current, workInProgress, renderLanes);
     case 4:
-      return popHostContainer(), bubbleProperties(workInProgress), null;
-    case 10:
       return (
-        popProvider(workInProgress.type._context),
-        bubbleProperties(workInProgress),
-        null
+        pushHostContainer(
+          workInProgress,
+          workInProgress.stateNode.containerInfo
+        ),
+        (Component = workInProgress.pendingProps),
+        null === current
+          ? (workInProgress.child = reconcileChildFibers(
+              workInProgress,
+              null,
+              Component,
+              renderLanes
+            ))
+          : reconcileChildren(current, workInProgress, Component, renderLanes),
+        workInProgress.child
       );
-    case 17:
+    case 11:
       return (
-        isContextProvider(workInProgress.type) && popContext(),
-        bubbleProperties(workInProgress),
-        null
+        (Component = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === Component
+            ? value
+            : resolveDefaultProps(Component, value)),
+        updateForwardRef(current, workInProgress, Component, value, renderLanes)
       );
-    case 19:
-      pop(suspenseStackCursor);
-      type = workInProgress.memoizedState;
-      if (null === type) return bubbleProperties(workInProgress), null;
-      newProps = 0 !== (workInProgress.flags & 128);
-      updatePayload = type.rendering;
-      if (null === updatePayload)
-        if (newProps) cutOffTailIfNeeded(type, !1);
-        else {
-          if (
-            0 !== workInProgressRootExitStatus ||
-            (null !== current && 0 !== (current.flags & 128))
-          )
-            for (current = workInProgress.child; null !== current; ) {
-              updatePayload = findFirstSuspended(current);
-              if (null !== updatePayload) {
-                workInProgress.flags |= 128;
-                cutOffTailIfNeeded(type, !1);
-                current = updatePayload.updateQueue;
-                workInProgress.updateQueue = current;
-                scheduleRetryEffect(workInProgress, current);
-                workInProgress.subtreeFlags = 0;
-                for (current = workInProgress.child; null !== current; )
-                  resetWorkInProgress(current, renderLanes),
-                    (current = current.sibling);
-                push(
-                  suspenseStackCursor,
-                  (suspenseStackCursor.current & 1) | 2
-                );
-                return workInProgress.child;
-              }
-              current = current.sibling;
-            }
-          null !== type.tail &&
-            now() > workInProgressRootRenderTargetTime &&
-            ((workInProgress.flags |= 128),
-            (newProps = !0),
-            cutOffTailIfNeeded(type, !1),
-            (workInProgress.lanes = 4194304));
-        }
-      else {
-        if (!newProps)
-          if (
-            ((current = findFirstSuspended(updatePayload)), null !== current)
-          ) {
-            if (
-              ((workInProgress.flags |= 128),
-              (newProps = !0),
-              (renderLanes = current.updateQueue),
-              (workInProgress.updateQueue = renderLanes),
-              scheduleRetryEffect(workInProgress, renderLanes),
-              cutOffTailIfNeeded(type, !0),
-              null === type.tail &&
-                "hidden" === type.tailMode &&
-                !updatePayload.alternate)
-            )
-              return bubbleProperties(workInProgress), null;
-          } else
-            2 * now() - type.renderingStartTime >
-              workInProgressRootRenderTargetTime &&
-              536870912 !== renderLanes &&
-              ((workInProgress.flags |= 128),
-              (newProps = !0),
-              cutOffTailIfNeeded(type, !1),
-              (workInProgress.lanes = 4194304));
-        type.isBackwards
-          ? ((updatePayload.sibling = workInProgress.child),
-            (workInProgress.child = updatePayload))
-          : ((renderLanes = type.last),
-            null !== renderLanes
-              ? (renderLanes.sibling = updatePayload)
-              : (workInProgress.child = updatePayload),
-            (type.last = updatePayload));
-      }
-      if (null !== type.tail)
-        return (
-          (workInProgress = type.tail),
-          (type.rendering = workInProgress),
-          (type.tail = workInProgress.sibling),
-          (type.renderingStartTime = now()),
-          (workInProgress.sibling = null),
-          (renderLanes = suspenseStackCursor.current),
-          push(
-            suspenseStackCursor,
-            newProps ? (renderLanes & 1) | 2 : renderLanes & 1
-          ),
-          workInProgress
-        );
-      bubbleProperties(workInProgress);
-      return null;
-    case 22:
-    case 23:
+    case 7:
       return (
-        popSuspenseHandler(workInProgress),
-        popHiddenContext(),
-        (newProps = null !== workInProgress.memoizedState),
-        null !== current
-          ? (null !== current.memoizedState) !== newProps &&
-            (workInProgress.flags |= 8192)
-          : newProps && (workInProgress.flags |= 8192),
-        newProps && 0 !== (workInProgress.mode & 1)
-          ? 0 !== (renderLanes & 536870912) &&
-            0 === (workInProgress.flags & 128) &&
-            (bubbleProperties(workInProgress),
-            workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192))
-          : bubbleProperties(workInProgress),
-        (renderLanes = workInProgress.updateQueue),
-        null !== renderLanes &&
-          scheduleRetryEffect(workInProgress, renderLanes.retryQueue),
-        null
+        reconcileChildren(
+          current,
+          workInProgress,
+          workInProgress.pendingProps,
+          renderLanes
+        ),
+        workInProgress.child
       );
-    case 24:
-      return null;
-    case 25:
-      return null;
-  }
-  throw Error(
-    "Unknown unit of work tag (" +
-      workInProgress.tag +
-      "). This error is likely caused by a bug in React. Please file an issue."
-  );
-}
-function unwindWork(current, workInProgress) {
-  switch (workInProgress.tag) {
-    case 1:
+    case 8:
       return (
-        isContextProvider(workInProgress.type) && popContext(),
-        (current = workInProgress.flags),
-        current & 65536
-          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
-          : null
+        reconcileChildren(
+          current,
+          workInProgress,
+          workInProgress.pendingProps.children,
+          renderLanes
+        ),
+        workInProgress.child
       );
-    case 3:
+    case 12:
       return (
-        popHostContainer(),
-        pop(didPerformWorkStackCursor),
-        pop(contextStackCursor$1),
-        (current = workInProgress.flags),
-        0 !== (current & 65536) && 0 === (current & 128)
-          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
-          : null
+        reconcileChildren(
+          current,
+          workInProgress,
+          workInProgress.pendingProps.children,
+          renderLanes
+        ),
+        workInProgress.child
       );
-    case 26:
-    case 27:
-    case 5:
-      return popHostContext(workInProgress), null;
-    case 13:
-      popSuspenseHandler(workInProgress);
-      current = workInProgress.memoizedState;
-      if (
-        null !== current &&
-        null !== current.dehydrated &&
-        null === workInProgress.alternate
-      )
-        throw Error(
-          "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
-        );
-      current = workInProgress.flags;
-      return current & 65536
-        ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
-        : null;
-    case 19:
-      return pop(suspenseStackCursor), null;
-    case 4:
-      return popHostContainer(), null;
     case 10:
-      return popProvider(workInProgress.type._context), null;
-    case 22:
-    case 23:
-      return (
-        popSuspenseHandler(workInProgress),
-        popHiddenContext(),
-        (current = workInProgress.flags),
-        current & 65536
-          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
-          : null
+      a: {
+        Component = workInProgress.type._context;
+        value = workInProgress.pendingProps;
+        var oldProps = workInProgress.memoizedProps,
+          newValue = value.value;
+        push(valueCursor, Component._currentValue);
+        Component._currentValue = newValue;
+        if (null !== oldProps)
+          if (objectIs(oldProps.value, newValue)) {
+            if (oldProps.children === value.children) {
+              workInProgress = bailoutOnAlreadyFinishedWork(
+                current,
+                workInProgress,
+                renderLanes
+              );
+              break a;
+            }
+          } else
+            for (
+              oldProps = workInProgress.child,
+                null !== oldProps && (oldProps.return = workInProgress);
+              null !== oldProps;
+
+            ) {
+              var list = oldProps.dependencies;
+              if (null !== list) {
+                newValue = oldProps.child;
+                for (
+                  var dependency = list.firstContext;
+                  null !== dependency;
+
+                ) {
+                  if (dependency.context === Component) {
+                    if (1 === oldProps.tag) {
+                      dependency = createUpdate(renderLanes & -renderLanes);
+                      dependency.tag = 2;
+                      var updateQueue = oldProps.updateQueue;
+                      if (null !== updateQueue) {
+                        updateQueue = updateQueue.shared;
+                        var pending = updateQueue.pending;
+                        null === pending
+                          ? (dependency.next = dependency)
+                          : ((dependency.next = pending.next),
+                            (pending.next = dependency));
+                        updateQueue.pending = dependency;
+                      }
+                    }
+                    oldProps.lanes |= renderLanes;
+                    dependency = oldProps.alternate;
+                    null !== dependency && (dependency.lanes |= renderLanes);
+                    scheduleContextWorkOnParentPath(
+                      oldProps.return,
+                      renderLanes,
+                      workInProgress
+                    );
+                    list.lanes |= renderLanes;
+                    break;
+                  }
+                  dependency = dependency.next;
+                }
+              } else if (10 === oldProps.tag)
+                newValue =
+                  oldProps.type === workInProgress.type ? null : oldProps.child;
+              else if (18 === oldProps.tag) {
+                newValue = oldProps.return;
+                if (null === newValue)
+                  throw Error(
+                    "We just came from a parent so we must have had a parent. This is a bug in React."
+                  );
+                newValue.lanes |= renderLanes;
+                list = newValue.alternate;
+                null !== list && (list.lanes |= renderLanes);
+                scheduleContextWorkOnParentPath(
+                  newValue,
+                  renderLanes,
+                  workInProgress
+                );
+                newValue = oldProps.sibling;
+              } else newValue = oldProps.child;
+              if (null !== newValue) newValue.return = oldProps;
+              else
+                for (newValue = oldProps; null !== newValue; ) {
+                  if (newValue === workInProgress) {
+                    newValue = null;
+                    break;
+                  }
+                  oldProps = newValue.sibling;
+                  if (null !== oldProps) {
+                    oldProps.return = newValue.return;
+                    newValue = oldProps;
+                    break;
+                  }
+                  newValue = newValue.return;
+                }
+              oldProps = newValue;
+            }
+        reconcileChildren(current, workInProgress, value.children, renderLanes);
+        workInProgress = workInProgress.child;
+      }
+      return workInProgress;
+    case 9:
+      return (
+        (value = workInProgress.type),
+        (Component = workInProgress.pendingProps.children),
+        prepareToReadContext(workInProgress, renderLanes),
+        (value = readContext(value)),
+        (Component = Component(value)),
+        (workInProgress.flags |= 1),
+        reconcileChildren(current, workInProgress, Component, renderLanes),
+        workInProgress.child
+      );
+    case 14:
+      return (
+        (Component = workInProgress.type),
+        (value = resolveDefaultProps(Component, workInProgress.pendingProps)),
+        (value = resolveDefaultProps(Component.type, value)),
+        updateMemoComponent(
+          current,
+          workInProgress,
+          Component,
+          value,
+          renderLanes
+        )
+      );
+    case 15:
+      return updateSimpleMemoComponent(
+        current,
+        workInProgress,
+        workInProgress.type,
+        workInProgress.pendingProps,
+        renderLanes
+      );
+    case 17:
+      return (
+        (Component = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === Component
+            ? value
+            : resolveDefaultProps(Component, value)),
+        resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress),
+        (workInProgress.tag = 1),
+        prepareToReadContext(workInProgress, renderLanes),
+        constructClassInstance(workInProgress, Component, value),
+        mountClassInstance(workInProgress, Component, value, renderLanes),
+        finishClassComponent(
+          null,
+          workInProgress,
+          Component,
+          !0,
+          !1,
+          renderLanes
+        )
       );
-    case 24:
-      return null;
-    case 25:
-      return null;
-    default:
-      return null;
-  }
-}
-function unwindInterruptedWork(current, interruptedWork) {
-  switch (interruptedWork.tag) {
-    case 1:
-      current = interruptedWork.type.childContextTypes;
-      null !== current && void 0 !== current && popContext();
-      break;
-    case 3:
-      popHostContainer();
-      pop(didPerformWorkStackCursor);
-      pop(contextStackCursor$1);
-      break;
-    case 26:
-    case 27:
-    case 5:
-      popHostContext(interruptedWork);
-      break;
-    case 4:
-      popHostContainer();
-      break;
-    case 13:
-      popSuspenseHandler(interruptedWork);
-      break;
     case 19:
-      pop(suspenseStackCursor);
-      break;
-    case 10:
-      popProvider(interruptedWork.type._context);
-      break;
+      return updateSuspenseListComponent(current, workInProgress, renderLanes);
     case 22:
-    case 23:
-      popSuspenseHandler(interruptedWork), popHiddenContext();
+      return updateOffscreenComponent(current, workInProgress, renderLanes);
   }
+  throw Error(
+    "Unknown unit of work tag (" +
+      workInProgress.tag +
+      "). This error is likely caused by a bug in React. Please file an issue."
+  );
 }
-var offscreenSubtreeIsHidden = !1,
-  offscreenSubtreeWasHidden = !1,
-  PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
-  nextEffect = null;
-function safelyAttachRef(current, nearestMountedAncestor) {
-  try {
-    var ref = current.ref;
-    if (null !== ref) {
-      var instance = current.stateNode;
-      switch (current.tag) {
-        case 26:
-        case 27:
-        case 5:
-          var instanceToUse = getPublicInstance(instance);
-          break;
-        default:
-          instanceToUse = instance;
-      }
-      "function" === typeof ref
-        ? (current.refCleanup = ref(instanceToUse))
-        : (ref.current = instanceToUse);
-    }
-  } catch (error) {
-    captureCommitPhaseError(current, nearestMountedAncestor, error);
-  }
+var valueCursor = createCursor(null),
+  currentlyRenderingFiber = null,
+  lastContextDependency = null,
+  lastFullyObservedContext = null;
+function resetContextDependencies() {
+  lastFullyObservedContext =
+    lastContextDependency =
+    currentlyRenderingFiber =
+      null;
 }
-function safelyDetachRef(current, nearestMountedAncestor) {
-  var ref = current.ref,
-    refCleanup = current.refCleanup;
-  if (null !== ref)
-    if ("function" === typeof refCleanup)
-      try {
-        refCleanup();
-      } catch (error) {
-        captureCommitPhaseError(current, nearestMountedAncestor, error);
-      } finally {
-        (current.refCleanup = null),
-          (current = current.alternate),
-          null != current && (current.refCleanup = null);
-      }
-    else if ("function" === typeof ref)
-      try {
-        ref(null);
-      } catch (error$77) {
-        captureCommitPhaseError(current, nearestMountedAncestor, error$77);
-      }
-    else ref.current = null;
+function popProvider(context) {
+  context._currentValue = valueCursor.current;
+  pop(valueCursor);
 }
-function safelyCallDestroy(current, nearestMountedAncestor, destroy) {
-  try {
-    destroy();
-  } catch (error) {
-    captureCommitPhaseError(current, nearestMountedAncestor, error);
+function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {
+  for (; null !== parent; ) {
+    var alternate = parent.alternate;
+    (parent.childLanes & renderLanes) !== renderLanes
+      ? ((parent.childLanes |= renderLanes),
+        null !== alternate && (alternate.childLanes |= renderLanes))
+      : null !== alternate &&
+        (alternate.childLanes & renderLanes) !== renderLanes &&
+        (alternate.childLanes |= renderLanes);
+    if (parent === propagationRoot) break;
+    parent = parent.return;
   }
 }
-var shouldFireAfterActiveInstanceBlur = !1;
-function commitBeforeMutationEffects(root, firstChild) {
-  for (nextEffect = firstChild; null !== nextEffect; )
+function prepareToReadContext(workInProgress, renderLanes) {
+  currentlyRenderingFiber = workInProgress;
+  lastFullyObservedContext = lastContextDependency = null;
+  workInProgress = workInProgress.dependencies;
+  null !== workInProgress &&
+    null !== workInProgress.firstContext &&
+    (0 !== (workInProgress.lanes & renderLanes) && (didReceiveUpdate = !0),
+    (workInProgress.firstContext = null));
+}
+function readContext(context) {
+  return readContextForConsumer(currentlyRenderingFiber, context);
+}
+function readContextDuringReconciliation(consumer, context, renderLanes) {
+  null === currentlyRenderingFiber &&
+    prepareToReadContext(consumer, renderLanes);
+  return readContextForConsumer(consumer, context);
+}
+function readContextForConsumer(consumer, context) {
+  var value = context._currentValue;
+  if (lastFullyObservedContext !== context)
     if (
-      ((root = nextEffect),
-      (firstChild = root.child),
-      0 !== (root.subtreeFlags & 1028) && null !== firstChild)
-    )
-      (firstChild.return = root), (nextEffect = firstChild);
-    else
-      for (; null !== nextEffect; ) {
-        root = nextEffect;
-        try {
-          var current = root.alternate,
-            flags = root.flags;
-          switch (root.tag) {
-            case 0:
-              break;
-            case 11:
-            case 15:
-              break;
-            case 1:
-              if (0 !== (flags & 1024) && null !== current) {
-                var prevProps = current.memoizedProps,
-                  prevState = current.memoizedState,
-                  instance = root.stateNode,
-                  snapshot = instance.getSnapshotBeforeUpdate(
-                    root.elementType === root.type
-                      ? prevProps
-                      : resolveDefaultProps(root.type, prevProps),
-                    prevState
-                  );
-                instance.__reactInternalSnapshotBeforeUpdate = snapshot;
-              }
-              break;
-            case 3:
-              break;
-            case 5:
-            case 26:
-            case 27:
-            case 6:
-            case 4:
-            case 17:
-              break;
-            default:
-              if (0 !== (flags & 1024))
-                throw Error(
-                  "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
-                );
-          }
-        } catch (error) {
-          captureCommitPhaseError(root, root.return, error);
-        }
-        firstChild = root.sibling;
-        if (null !== firstChild) {
-          firstChild.return = root.return;
-          nextEffect = firstChild;
-          break;
-        }
-        nextEffect = root.return;
-      }
-  current = shouldFireAfterActiveInstanceBlur;
-  shouldFireAfterActiveInstanceBlur = !1;
-  return current;
-}
-function commitHookEffectListUnmount(
-  flags,
-  finishedWork,
-  nearestMountedAncestor
-) {
-  var updateQueue = finishedWork.updateQueue;
-  updateQueue = null !== updateQueue ? updateQueue.lastEffect : null;
-  if (null !== updateQueue) {
-    var effect = (updateQueue = updateQueue.next);
-    do {
-      if ((effect.tag & flags) === flags) {
-        var inst = effect.inst,
-          destroy = inst.destroy;
-        void 0 !== destroy &&
-          ((inst.destroy = void 0),
-          safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy));
-      }
-      effect = effect.next;
-    } while (effect !== updateQueue);
-  }
+      ((context = { context: context, memoizedValue: value, next: null }),
+      null === lastContextDependency)
+    ) {
+      if (null === consumer)
+        throw Error(
+          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
+        );
+      lastContextDependency = context;
+      consumer.dependencies = { lanes: 0, firstContext: context };
+    } else lastContextDependency = lastContextDependency.next = context;
+  return value;
 }
-function commitHookEffectListMount(flags, finishedWork) {
-  finishedWork = finishedWork.updateQueue;
-  finishedWork = null !== finishedWork ? finishedWork.lastEffect : null;
-  if (null !== finishedWork) {
-    var effect = (finishedWork = finishedWork.next);
-    do {
-      if ((effect.tag & flags) === flags) {
-        var create$78 = effect.create,
-          inst = effect.inst;
-        create$78 = create$78();
-        inst.destroy = create$78;
-      }
-      effect = effect.next;
-    } while (effect !== finishedWork);
-  }
+var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
+function handleAsyncAction() {}
+function scheduleRetryEffect(workInProgress, retryQueue) {
+  null !== retryQueue
+    ? (workInProgress.flags |= 4)
+    : workInProgress.flags & 16384 &&
+      ((retryQueue =
+        22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),
+      (workInProgress.lanes |= retryQueue));
 }
-function commitHookLayoutEffects(finishedWork, hookFlags) {
-  try {
-    commitHookEffectListMount(hookFlags, finishedWork);
-  } catch (error) {
-    captureCommitPhaseError(finishedWork, finishedWork.return, error);
+function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
+  switch (renderState.tailMode) {
+    case "hidden":
+      hasRenderedATailFallback = renderState.tail;
+      for (var lastTailNode = null; null !== hasRenderedATailFallback; )
+        null !== hasRenderedATailFallback.alternate &&
+          (lastTailNode = hasRenderedATailFallback),
+          (hasRenderedATailFallback = hasRenderedATailFallback.sibling);
+      null === lastTailNode
+        ? (renderState.tail = null)
+        : (lastTailNode.sibling = null);
+      break;
+    case "collapsed":
+      lastTailNode = renderState.tail;
+      for (var lastTailNode$61 = null; null !== lastTailNode; )
+        null !== lastTailNode.alternate && (lastTailNode$61 = lastTailNode),
+          (lastTailNode = lastTailNode.sibling);
+      null === lastTailNode$61
+        ? hasRenderedATailFallback || null === renderState.tail
+          ? (renderState.tail = null)
+          : (renderState.tail.sibling = null)
+        : (lastTailNode$61.sibling = null);
   }
 }
-function commitClassCallbacks(finishedWork) {
-  var updateQueue = finishedWork.updateQueue;
-  if (null !== updateQueue) {
-    var instance = finishedWork.stateNode;
-    try {
-      commitCallbacks(updateQueue, instance);
-    } catch (error) {
-      captureCommitPhaseError(finishedWork, finishedWork.return, error);
-    }
-  }
+function bubbleProperties(completedWork) {
+  var didBailout =
+      null !== completedWork.alternate &&
+      completedWork.alternate.child === completedWork.child,
+    newChildLanes = 0,
+    subtreeFlags = 0;
+  if (didBailout)
+    for (var child$62 = completedWork.child; null !== child$62; )
+      (newChildLanes |= child$62.lanes | child$62.childLanes),
+        (subtreeFlags |= child$62.subtreeFlags & 31457280),
+        (subtreeFlags |= child$62.flags & 31457280),
+        (child$62.return = completedWork),
+        (child$62 = child$62.sibling);
+  else
+    for (child$62 = completedWork.child; null !== child$62; )
+      (newChildLanes |= child$62.lanes | child$62.childLanes),
+        (subtreeFlags |= child$62.subtreeFlags),
+        (subtreeFlags |= child$62.flags),
+        (child$62.return = completedWork),
+        (child$62 = child$62.sibling);
+  completedWork.subtreeFlags |= subtreeFlags;
+  completedWork.childLanes = newChildLanes;
+  return didBailout;
 }
-function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
-  var flags = finishedWork.flags;
-  switch (finishedWork.tag) {
+function completeWork(current, workInProgress, renderLanes) {
+  var newProps = workInProgress.pendingProps;
+  switch (workInProgress.tag) {
+    case 2:
+    case 16:
+    case 15:
     case 0:
     case 11:
-    case 15:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      flags & 4 && commitHookLayoutEffects(finishedWork, 5);
-      break;
+    case 7:
+    case 8:
+    case 12:
+    case 9:
+    case 14:
+      return bubbleProperties(workInProgress), null;
     case 1:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      if (flags & 4)
-        if (((finishedRoot = finishedWork.stateNode), null === current))
-          try {
-            finishedRoot.componentDidMount();
-          } catch (error) {
-            captureCommitPhaseError(finishedWork, finishedWork.return, error);
-          }
-        else {
-          var prevProps =
-            finishedWork.elementType === finishedWork.type
-              ? current.memoizedProps
-              : resolveDefaultProps(finishedWork.type, current.memoizedProps);
-          current = current.memoizedState;
-          try {
-            finishedRoot.componentDidUpdate(
-              prevProps,
-              current,
-              finishedRoot.__reactInternalSnapshotBeforeUpdate
-            );
-          } catch (error$79) {
-            captureCommitPhaseError(
-              finishedWork,
-              finishedWork.return,
-              error$79
-            );
-          }
-        }
-      flags & 64 && commitClassCallbacks(finishedWork);
-      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
-      break;
+      return bubbleProperties(workInProgress), null;
     case 3:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      if (flags & 64 && ((flags = finishedWork.updateQueue), null !== flags)) {
-        finishedRoot = null;
-        if (null !== finishedWork.child)
-          switch (finishedWork.child.tag) {
-            case 27:
-            case 5:
-              finishedRoot = getPublicInstance(finishedWork.child.stateNode);
-              break;
-            case 1:
-              finishedRoot = finishedWork.child.stateNode;
-          }
-        try {
-          commitCallbacks(flags, finishedRoot);
-        } catch (error) {
-          captureCommitPhaseError(finishedWork, finishedWork.return, error);
-        }
-      }
-      break;
+      return (
+        (renderLanes = workInProgress.stateNode),
+        popHostContainer(),
+        renderLanes.pendingContext &&
+          ((renderLanes.context = renderLanes.pendingContext),
+          (renderLanes.pendingContext = null)),
+        (null !== current && null !== current.child) ||
+          null === current ||
+          (current.memoizedState.isDehydrated &&
+            0 === (workInProgress.flags & 256)) ||
+          ((workInProgress.flags |= 1024),
+          null !== hydrationErrors &&
+            (queueRecoverableErrors(hydrationErrors),
+            (hydrationErrors = null))),
+        bubbleProperties(workInProgress),
+        null
+      );
     case 26:
     case 27:
     case 5:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
-      break;
-    case 12:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      break;
-    case 13:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      break;
-    case 22:
-      if (0 !== (finishedWork.mode & 1)) {
-        if (
-          ((prevProps =
-            null !== finishedWork.memoizedState || offscreenSubtreeIsHidden),
-          !prevProps)
-        ) {
-          current =
-            (null !== current && null !== current.memoizedState) ||
-            offscreenSubtreeWasHidden;
-          var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
-            prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
-          offscreenSubtreeIsHidden = prevProps;
-          (offscreenSubtreeWasHidden = current) &&
-          !prevOffscreenSubtreeWasHidden
-            ? recursivelyTraverseReappearLayoutEffects(
-                finishedRoot,
-                finishedWork,
-                0 !== (finishedWork.subtreeFlags & 8772)
-              )
-            : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
-          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
-        }
-      } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      flags & 512 &&
-        ("manual" === finishedWork.memoizedProps.mode
-          ? safelyAttachRef(finishedWork, finishedWork.return)
-          : safelyDetachRef(finishedWork, finishedWork.return));
-      break;
-    default:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-  }
-}
-function detachFiberAfterEffects(fiber) {
-  var alternate = fiber.alternate;
-  null !== alternate &&
-    ((fiber.alternate = null), detachFiberAfterEffects(alternate));
-  fiber.child = null;
-  fiber.deletions = null;
-  fiber.sibling = null;
-  fiber.stateNode = null;
-  fiber.return = null;
-  fiber.dependencies = null;
-  fiber.memoizedProps = null;
-  fiber.memoizedState = null;
-  fiber.pendingProps = null;
-  fiber.stateNode = null;
-  fiber.updateQueue = null;
-}
-function isHostParent(fiber) {
-  return 5 === fiber.tag || 3 === fiber.tag || 4 === fiber.tag;
-}
-function getHostSibling(fiber) {
-  a: for (;;) {
-    for (; null === fiber.sibling; ) {
-      if (null === fiber.return || isHostParent(fiber.return)) return null;
-      fiber = fiber.return;
-    }
-    fiber.sibling.return = fiber.return;
-    for (
-      fiber = fiber.sibling;
-      5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;
-
-    ) {
-      if (fiber.flags & 2) continue a;
-      if (null === fiber.child || 4 === fiber.tag) continue a;
-      else (fiber.child.return = fiber), (fiber = fiber.child);
-    }
-    if (!(fiber.flags & 2)) return fiber.stateNode;
-  }
-}
-function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
-  var tag = node.tag;
-  if (5 === tag || 6 === tag)
-    if (((node = node.stateNode), before)) {
-      if ("number" === typeof parent)
-        throw Error("Container does not support insertBefore operation");
-    } else
-      ReactNativePrivateInterface.UIManager.setChildren(parent, [
-        "number" === typeof node ? node : node._nativeTag
-      ]);
-  else if (4 !== tag && ((node = node.child), null !== node))
-    for (
-      insertOrAppendPlacementNodeIntoContainer(node, before, parent),
-        node = node.sibling;
-      null !== node;
-
-    )
-      insertOrAppendPlacementNodeIntoContainer(node, before, parent),
-        (node = node.sibling);
-}
-function insertOrAppendPlacementNode(node, before, parent) {
-  var tag = node.tag;
-  if (5 === tag || 6 === tag)
-    if (((node = node.stateNode), before)) {
-      tag = parent._children;
-      var index = tag.indexOf(node);
-      0 <= index
-        ? (tag.splice(index, 1),
-          (before = tag.indexOf(before)),
-          tag.splice(before, 0, node),
-          ReactNativePrivateInterface.UIManager.manageChildren(
-            parent._nativeTag,
-            [index],
-            [before],
-            [],
-            [],
-            []
-          ))
-        : ((before = tag.indexOf(before)),
-          tag.splice(before, 0, node),
-          ReactNativePrivateInterface.UIManager.manageChildren(
-            parent._nativeTag,
-            [],
-            [],
-            ["number" === typeof node ? node : node._nativeTag],
-            [before],
-            []
-          ));
-    } else
-      (before = "number" === typeof node ? node : node._nativeTag),
-        (tag = parent._children),
-        (index = tag.indexOf(node)),
-        0 <= index
-          ? (tag.splice(index, 1),
-            tag.push(node),
-            ReactNativePrivateInterface.UIManager.manageChildren(
-              parent._nativeTag,
-              [index],
-              [tag.length - 1],
-              [],
-              [],
-              []
-            ))
-          : (tag.push(node),
-            ReactNativePrivateInterface.UIManager.manageChildren(
-              parent._nativeTag,
-              [],
-              [],
-              [before],
-              [tag.length - 1],
-              []
-            ));
-  else if (4 !== tag && ((node = node.child), null !== node))
-    for (
-      insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
-      null !== node;
-
-    )
-      insertOrAppendPlacementNode(node, before, parent), (node = node.sibling);
-}
-var hostParent = null,
-  hostParentIsContainer = !1;
-function recursivelyTraverseDeletionEffects(
-  finishedRoot,
-  nearestMountedAncestor,
-  parent
-) {
-  for (parent = parent.child; null !== parent; )
-    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent),
-      (parent = parent.sibling);
-}
-function commitDeletionEffectsOnFiber(
-  finishedRoot,
-  nearestMountedAncestor,
-  deletedFiber
-) {
-  if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
-    try {
-      injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
-    } catch (err) {}
-  switch (deletedFiber.tag) {
-    case 26:
-    case 27:
-    case 5:
-      offscreenSubtreeWasHidden ||
-        safelyDetachRef(deletedFiber, nearestMountedAncestor);
-    case 6:
-      var prevHostParent = hostParent,
-        prevHostParentIsContainer = hostParentIsContainer;
-      hostParent = null;
-      recursivelyTraverseDeletionEffects(
-        finishedRoot,
-        nearestMountedAncestor,
-        deletedFiber
-      );
-      hostParent = prevHostParent;
-      hostParentIsContainer = prevHostParentIsContainer;
-      null !== hostParent &&
-        (hostParentIsContainer
-          ? ((finishedRoot = hostParent),
-            recursivelyUncacheFiberNode(deletedFiber.stateNode),
-            ReactNativePrivateInterface.UIManager.manageChildren(
-              finishedRoot,
-              [],
-              [],
-              [],
-              [],
-              [0]
-            ))
-          : ((finishedRoot = hostParent),
-            (nearestMountedAncestor = deletedFiber.stateNode),
-            recursivelyUncacheFiberNode(nearestMountedAncestor),
-            (deletedFiber = finishedRoot._children),
-            (nearestMountedAncestor = deletedFiber.indexOf(
-              nearestMountedAncestor
-            )),
-            deletedFiber.splice(nearestMountedAncestor, 1),
-            ReactNativePrivateInterface.UIManager.manageChildren(
-              finishedRoot._nativeTag,
-              [],
-              [],
-              [],
-              [],
-              [nearestMountedAncestor]
-            )));
-      break;
-    case 18:
-      null !== hostParent && shim$1();
-      break;
-    case 4:
-      prevHostParent = hostParent;
-      prevHostParentIsContainer = hostParentIsContainer;
-      hostParent = deletedFiber.stateNode.containerInfo;
-      hostParentIsContainer = !0;
-      recursivelyTraverseDeletionEffects(
-        finishedRoot,
-        nearestMountedAncestor,
-        deletedFiber
-      );
-      hostParent = prevHostParent;
-      hostParentIsContainer = prevHostParentIsContainer;
-      break;
-    case 0:
-    case 11:
-    case 14:
-    case 15:
-      if (
-        !offscreenSubtreeWasHidden &&
-        ((prevHostParent = deletedFiber.updateQueue),
-        null !== prevHostParent &&
-          ((prevHostParent = prevHostParent.lastEffect),
-          null !== prevHostParent))
-      ) {
-        prevHostParentIsContainer = prevHostParent = prevHostParent.next;
-        do {
-          var tag = prevHostParentIsContainer.tag,
-            inst = prevHostParentIsContainer.inst,
-            destroy = inst.destroy;
-          void 0 !== destroy &&
-            (0 !== (tag & 2)
-              ? ((inst.destroy = void 0),
-                safelyCallDestroy(
-                  deletedFiber,
-                  nearestMountedAncestor,
-                  destroy
-                ))
-              : 0 !== (tag & 4) &&
-                ((inst.destroy = void 0),
-                safelyCallDestroy(
-                  deletedFiber,
-                  nearestMountedAncestor,
-                  destroy
-                )));
-          prevHostParentIsContainer = prevHostParentIsContainer.next;
-        } while (prevHostParentIsContainer !== prevHostParent);
-      }
-      recursivelyTraverseDeletionEffects(
-        finishedRoot,
-        nearestMountedAncestor,
-        deletedFiber
-      );
-      break;
-    case 1:
-      if (
-        !offscreenSubtreeWasHidden &&
-        (safelyDetachRef(deletedFiber, nearestMountedAncestor),
-        (prevHostParent = deletedFiber.stateNode),
-        "function" === typeof prevHostParent.componentWillUnmount)
-      )
-        try {
-          (prevHostParent.props = deletedFiber.memoizedProps),
-            (prevHostParent.state = deletedFiber.memoizedState),
-            prevHostParent.componentWillUnmount();
-        } catch (error) {
-          captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
-        }
-      recursivelyTraverseDeletionEffects(
-        finishedRoot,
-        nearestMountedAncestor,
-        deletedFiber
-      );
-      break;
-    case 21:
-      recursivelyTraverseDeletionEffects(
-        finishedRoot,
-        nearestMountedAncestor,
-        deletedFiber
-      );
-      break;
-    case 22:
-      safelyDetachRef(deletedFiber, nearestMountedAncestor);
-      deletedFiber.mode & 1
-        ? ((offscreenSubtreeWasHidden =
-            (prevHostParent = offscreenSubtreeWasHidden) ||
-            null !== deletedFiber.memoizedState),
-          recursivelyTraverseDeletionEffects(
-            finishedRoot,
-            nearestMountedAncestor,
-            deletedFiber
-          ),
-          (offscreenSubtreeWasHidden = prevHostParent))
-        : recursivelyTraverseDeletionEffects(
-            finishedRoot,
-            nearestMountedAncestor,
-            deletedFiber
-          );
-      break;
-    default:
-      recursivelyTraverseDeletionEffects(
-        finishedRoot,
-        nearestMountedAncestor,
-        deletedFiber
-      );
-  }
-}
-function getRetryCache(finishedWork) {
-  switch (finishedWork.tag) {
-    case 13:
-    case 19:
-      var retryCache = finishedWork.stateNode;
-      null === retryCache &&
-        (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
-      return retryCache;
-    case 22:
-      return (
-        (finishedWork = finishedWork.stateNode),
-        (retryCache = finishedWork._retryCache),
-        null === retryCache &&
-          (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),
-        retryCache
-      );
-    default:
-      throw Error(
-        "Unexpected Suspense handler tag (" +
-          finishedWork.tag +
-          "). This is a bug in React."
-      );
-  }
-}
-function attachSuspenseRetryListeners(finishedWork, wakeables) {
-  var retryCache = getRetryCache(finishedWork);
-  wakeables.forEach(function (wakeable) {
-    var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
-    retryCache.has(wakeable) ||
-      (retryCache.add(wakeable), wakeable.then(retry, retry));
-  });
-}
-function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
-  var deletions = parentFiber.deletions;
-  if (null !== deletions)
-    for (var i = 0; i < deletions.length; i++) {
-      var childToDelete = deletions[i];
-      try {
-        var root = root$jscomp$0,
-          returnFiber = parentFiber,
-          parent = returnFiber;
-        a: for (; null !== parent; ) {
-          switch (parent.tag) {
-            case 27:
-            case 5:
-              hostParent = parent.stateNode;
-              hostParentIsContainer = !1;
-              break a;
-            case 3:
-              hostParent = parent.stateNode.containerInfo;
-              hostParentIsContainer = !0;
-              break a;
-            case 4:
-              hostParent = parent.stateNode.containerInfo;
-              hostParentIsContainer = !0;
+      popHostContext(workInProgress);
+      var type = workInProgress.type;
+      if (null !== current && null != workInProgress.stateNode)
+        current.memoizedProps !== newProps && (workInProgress.flags |= 4);
+      else {
+        if (!newProps) {
+          if (null === workInProgress.stateNode)
+            throw Error(
+              "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
+            );
+          bubbleProperties(workInProgress);
+          return null;
+        }
+        current = rootInstanceStackCursor.current;
+        renderLanes = allocateTag();
+        type = getViewConfigForType(type);
+        var updatePayload = diffProperties(
+          null,
+          emptyObject,
+          newProps,
+          type.validAttributes
+        );
+        ReactNativePrivateInterface.UIManager.createView(
+          renderLanes,
+          type.uiViewClassName,
+          current,
+          updatePayload
+        );
+        current = new ReactNativeFiberHostComponent(
+          renderLanes,
+          type,
+          workInProgress
+        );
+        instanceCache.set(renderLanes, workInProgress);
+        instanceProps.set(renderLanes, newProps);
+        a: for (renderLanes = workInProgress.child; null !== renderLanes; ) {
+          if (5 === renderLanes.tag || 6 === renderLanes.tag)
+            current._children.push(renderLanes.stateNode);
+          else if (4 !== renderLanes.tag && null !== renderLanes.child) {
+            renderLanes.child.return = renderLanes;
+            renderLanes = renderLanes.child;
+            continue;
+          }
+          if (renderLanes === workInProgress) break a;
+          for (; null === renderLanes.sibling; ) {
+            if (
+              null === renderLanes.return ||
+              renderLanes.return === workInProgress
+            )
               break a;
+            renderLanes = renderLanes.return;
           }
-          parent = parent.return;
-        }
-        if (null === hostParent)
-          throw Error(
-            "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
-          );
-        commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);
-        hostParent = null;
-        hostParentIsContainer = !1;
-        var alternate = childToDelete.alternate;
-        null !== alternate && (alternate.return = null);
-        childToDelete.return = null;
-      } catch (error) {
-        captureCommitPhaseError(childToDelete, parentFiber, error);
-      }
-    }
-  if (parentFiber.subtreeFlags & 12854)
-    for (parentFiber = parentFiber.child; null !== parentFiber; )
-      commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),
-        (parentFiber = parentFiber.sibling);
-}
-function commitMutationEffectsOnFiber(finishedWork, root) {
-  var current = finishedWork.alternate,
-    flags = finishedWork.flags;
-  switch (finishedWork.tag) {
-    case 0:
-    case 11:
-    case 14:
-    case 15:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      if (flags & 4) {
-        try {
-          commitHookEffectListUnmount(3, finishedWork, finishedWork.return),
-            commitHookEffectListMount(3, finishedWork);
-        } catch (error) {
-          captureCommitPhaseError(finishedWork, finishedWork.return, error);
-        }
-        try {
-          commitHookEffectListUnmount(5, finishedWork, finishedWork.return);
-        } catch (error$87) {
-          captureCommitPhaseError(finishedWork, finishedWork.return, error$87);
-        }
-      }
-      break;
-    case 1:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      flags & 512 &&
-        null !== current &&
-        safelyDetachRef(current, current.return);
-      flags & 64 &&
-        offscreenSubtreeIsHidden &&
-        ((finishedWork = finishedWork.updateQueue),
-        null !== finishedWork &&
-          ((flags = finishedWork.callbacks),
-          null !== flags &&
-            ((current = finishedWork.shared.hiddenCallbacks),
-            (finishedWork.shared.hiddenCallbacks =
-              null === current ? flags : current.concat(flags)))));
-      break;
-    case 26:
-    case 27:
-    case 5:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      flags & 512 &&
-        null !== current &&
-        safelyDetachRef(current, current.return);
-      if (flags & 4 && ((flags = finishedWork.stateNode), null != flags)) {
-        var newProps = finishedWork.memoizedProps;
-        current = null !== current ? current.memoizedProps : newProps;
-        finishedWork.updateQueue = null;
-        try {
-          var viewConfig = flags.viewConfig;
-          instanceProps.set(flags._nativeTag, newProps);
-          var updatePayload = diffProperties(
-            null,
-            current,
-            newProps,
-            viewConfig.validAttributes
-          );
-          null != updatePayload &&
-            ReactNativePrivateInterface.UIManager.updateView(
-              flags._nativeTag,
-              viewConfig.uiViewClassName,
-              updatePayload
-            );
-        } catch (error$90) {
-          captureCommitPhaseError(finishedWork, finishedWork.return, error$90);
+          renderLanes.sibling.return = renderLanes.return;
+          renderLanes = renderLanes.sibling;
         }
+        workInProgress.stateNode = current;
+        finalizeInitialChildren(current) && (workInProgress.flags |= 4);
       }
-      break;
+      bubbleProperties(workInProgress);
+      workInProgress.flags &= -16777217;
+      return null;
     case 6:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      if (flags & 4) {
-        if (null === finishedWork.stateNode)
+      if (current && null != workInProgress.stateNode)
+        current.memoizedProps !== newProps && (workInProgress.flags |= 4);
+      else {
+        if ("string" !== typeof newProps && null === workInProgress.stateNode)
           throw Error(
-            "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
+            "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
           );
-        flags = finishedWork.stateNode;
-        current = finishedWork.memoizedProps;
-        try {
-          ReactNativePrivateInterface.UIManager.updateView(
-            flags,
-            "RCTRawText",
-            { text: current }
+        renderLanes = rootInstanceStackCursor.current;
+        if (!contextStackCursor.current.isInAParentText)
+          throw Error(
+            "Text strings must be rendered within a <Text> component."
           );
-        } catch (error$91) {
-          captureCommitPhaseError(finishedWork, finishedWork.return, error$91);
-        }
-      }
-      break;
-    case 3:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      break;
-    case 4:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      break;
-    case 13:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      finishedWork.child.flags & 8192 &&
-        ((current = null !== current && null !== current.memoizedState),
-        null === finishedWork.memoizedState ||
-          current ||
-          (globalMostRecentFallbackTime = now()));
-      flags & 4 &&
-        ((flags = finishedWork.updateQueue),
-        null !== flags &&
-          ((finishedWork.updateQueue = null),
-          attachSuspenseRetryListeners(finishedWork, flags)));
-      break;
-    case 22:
-      flags & 512 &&
-        null !== current &&
-        safelyDetachRef(current, current.return);
-      viewConfig = null !== finishedWork.memoizedState;
-      updatePayload = null !== current && null !== current.memoizedState;
-      if (finishedWork.mode & 1) {
-        var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
-          prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
-        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || viewConfig;
-        offscreenSubtreeWasHidden =
-          prevOffscreenSubtreeWasHidden || updatePayload;
-        recursivelyTraverseMutationEffects(root, finishedWork);
-        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
-        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
-      } else recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      root = finishedWork.stateNode;
-      root._current = finishedWork;
-      root._visibility &= -3;
-      root._visibility |= root._pendingVisibility & 2;
+        current = allocateTag();
+        ReactNativePrivateInterface.UIManager.createView(
+          current,
+          "RCTRawText",
+          renderLanes,
+          { text: newProps }
+        );
+        instanceCache.set(current, workInProgress);
+        workInProgress.stateNode = current;
+      }
+      bubbleProperties(workInProgress);
+      return null;
+    case 13:
+      newProps = workInProgress.memoizedState;
       if (
-        flags & 8192 &&
-        ((root._visibility = viewConfig
-          ? root._visibility & -2
-          : root._visibility | 1),
-        viewConfig &&
-          ((root = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden),
-          null === current ||
-            updatePayload ||
-            root ||
-            (0 !== (finishedWork.mode & 1) &&
-              recursivelyTraverseDisappearLayoutEffects(finishedWork))),
-        null === finishedWork.memoizedProps ||
-          "manual" !== finishedWork.memoizedProps.mode)
-      )
-        a: for (current = null, root = finishedWork; ; ) {
-          if (5 === root.tag) {
-            if (null === current) {
-              current = root;
-              try {
-                if (((newProps = root.stateNode), viewConfig)) {
-                  var viewConfig$jscomp$0 = newProps.viewConfig;
-                  var updatePayload$jscomp$0 = diffProperties(
-                    null,
-                    emptyObject,
-                    { style: { display: "none" } },
-                    viewConfig$jscomp$0.validAttributes
-                  );
-                  ReactNativePrivateInterface.UIManager.updateView(
-                    newProps._nativeTag,
-                    viewConfig$jscomp$0.uiViewClassName,
-                    updatePayload$jscomp$0
-                  );
-                } else {
-                  var instance = root.stateNode,
-                    props = root.memoizedProps,
-                    viewConfig$jscomp$1 = instance.viewConfig,
-                    prevProps = assign({}, props, {
-                      style: [props.style, { display: "none" }]
-                    });
-                  var updatePayload$jscomp$1 = diffProperties(
-                    null,
-                    prevProps,
-                    props,
-                    viewConfig$jscomp$1.validAttributes
-                  );
-                  ReactNativePrivateInterface.UIManager.updateView(
-                    instance._nativeTag,
-                    viewConfig$jscomp$1.uiViewClassName,
-                    updatePayload$jscomp$1
-                  );
-                }
-              } catch (error) {
-                captureCommitPhaseError(
-                  finishedWork,
-                  finishedWork.return,
-                  error
+        null === current ||
+        (null !== current.memoizedState &&
+          null !== current.memoizedState.dehydrated)
+      ) {
+        if (null !== newProps && null !== newProps.dehydrated) {
+          if (null === current) {
+            throw Error(
+              "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
+            );
+            throw Error(
+              "Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
+            );
+          }
+          0 === (workInProgress.flags & 128) &&
+            (workInProgress.memoizedState = null);
+          workInProgress.flags |= 4;
+          bubbleProperties(workInProgress);
+          type = !1;
+        } else
+          null !== hydrationErrors &&
+            (queueRecoverableErrors(hydrationErrors), (hydrationErrors = null)),
+            (type = !0);
+        if (!type) {
+          if (workInProgress.flags & 256)
+            return popSuspenseHandler(workInProgress), workInProgress;
+          popSuspenseHandler(workInProgress);
+          return null;
+        }
+      }
+      popSuspenseHandler(workInProgress);
+      if (0 !== (workInProgress.flags & 128))
+        return (workInProgress.lanes = renderLanes), workInProgress;
+      renderLanes = null !== newProps;
+      renderLanes !== (null !== current && null !== current.memoizedState) &&
+        renderLanes &&
+        (workInProgress.child.flags |= 8192);
+      scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
+      bubbleProperties(workInProgress);
+      return null;
+    case 4:
+      return popHostContainer(), bubbleProperties(workInProgress), null;
+    case 10:
+      return (
+        popProvider(workInProgress.type._context),
+        bubbleProperties(workInProgress),
+        null
+      );
+    case 17:
+      return bubbleProperties(workInProgress), null;
+    case 19:
+      pop(suspenseStackCursor);
+      type = workInProgress.memoizedState;
+      if (null === type) return bubbleProperties(workInProgress), null;
+      newProps = 0 !== (workInProgress.flags & 128);
+      updatePayload = type.rendering;
+      if (null === updatePayload)
+        if (newProps) cutOffTailIfNeeded(type, !1);
+        else {
+          if (
+            0 !== workInProgressRootExitStatus ||
+            (null !== current && 0 !== (current.flags & 128))
+          )
+            for (current = workInProgress.child; null !== current; ) {
+              updatePayload = findFirstSuspended(current);
+              if (null !== updatePayload) {
+                workInProgress.flags |= 128;
+                cutOffTailIfNeeded(type, !1);
+                current = updatePayload.updateQueue;
+                workInProgress.updateQueue = current;
+                scheduleRetryEffect(workInProgress, current);
+                workInProgress.subtreeFlags = 0;
+                for (current = workInProgress.child; null !== current; )
+                  resetWorkInProgress(current, renderLanes),
+                    (current = current.sibling);
+                push(
+                  suspenseStackCursor,
+                  (suspenseStackCursor.current & 1) | 2
                 );
+                return workInProgress.child;
               }
+              current = current.sibling;
             }
-          } else if (6 === root.tag) {
-            if (null === current)
-              try {
-                throw Error("Not yet implemented.");
-              } catch (error$81) {
-                captureCommitPhaseError(
-                  finishedWork,
-                  finishedWork.return,
-                  error$81
-                );
-              }
-          } else if (
-            ((22 !== root.tag && 23 !== root.tag) ||
-              null === root.memoizedState ||
-              root === finishedWork) &&
-            null !== root.child
-          ) {
-            root.child.return = root;
-            root = root.child;
-            continue;
-          }
-          if (root === finishedWork) break a;
-          for (; null === root.sibling; ) {
-            if (null === root.return || root.return === finishedWork) break a;
-            current === root && (current = null);
-            root = root.return;
-          }
-          current === root && (current = null);
-          root.sibling.return = root.return;
-          root = root.sibling;
+          null !== type.tail &&
+            now() > workInProgressRootRenderTargetTime &&
+            ((workInProgress.flags |= 128),
+            (newProps = !0),
+            cutOffTailIfNeeded(type, !1),
+            (workInProgress.lanes = 4194304));
         }
-      flags & 4 &&
-        ((flags = finishedWork.updateQueue),
-        null !== flags &&
-          ((current = flags.retryQueue),
-          null !== current &&
-            ((flags.retryQueue = null),
-            attachSuspenseRetryListeners(finishedWork, current))));
+      else {
+        if (!newProps)
+          if (
+            ((current = findFirstSuspended(updatePayload)), null !== current)
+          ) {
+            if (
+              ((workInProgress.flags |= 128),
+              (newProps = !0),
+              (renderLanes = current.updateQueue),
+              (workInProgress.updateQueue = renderLanes),
+              scheduleRetryEffect(workInProgress, renderLanes),
+              cutOffTailIfNeeded(type, !0),
+              null === type.tail &&
+                "hidden" === type.tailMode &&
+                !updatePayload.alternate)
+            )
+              return bubbleProperties(workInProgress), null;
+          } else
+            2 * now() - type.renderingStartTime >
+              workInProgressRootRenderTargetTime &&
+              536870912 !== renderLanes &&
+              ((workInProgress.flags |= 128),
+              (newProps = !0),
+              cutOffTailIfNeeded(type, !1),
+              (workInProgress.lanes = 4194304));
+        type.isBackwards
+          ? ((updatePayload.sibling = workInProgress.child),
+            (workInProgress.child = updatePayload))
+          : ((renderLanes = type.last),
+            null !== renderLanes
+              ? (renderLanes.sibling = updatePayload)
+              : (workInProgress.child = updatePayload),
+            (type.last = updatePayload));
+      }
+      if (null !== type.tail)
+        return (
+          (workInProgress = type.tail),
+          (type.rendering = workInProgress),
+          (type.tail = workInProgress.sibling),
+          (type.renderingStartTime = now()),
+          (workInProgress.sibling = null),
+          (renderLanes = suspenseStackCursor.current),
+          push(
+            suspenseStackCursor,
+            newProps ? (renderLanes & 1) | 2 : renderLanes & 1
+          ),
+          workInProgress
+        );
+      bubbleProperties(workInProgress);
+      return null;
+    case 22:
+    case 23:
+      return (
+        popSuspenseHandler(workInProgress),
+        popHiddenContext(),
+        (newProps = null !== workInProgress.memoizedState),
+        null !== current
+          ? (null !== current.memoizedState) !== newProps &&
+            (workInProgress.flags |= 8192)
+          : newProps && (workInProgress.flags |= 8192),
+        newProps && 0 !== (workInProgress.mode & 1)
+          ? 0 !== (renderLanes & 536870912) &&
+            0 === (workInProgress.flags & 128) &&
+            (bubbleProperties(workInProgress),
+            workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192))
+          : bubbleProperties(workInProgress),
+        (renderLanes = workInProgress.updateQueue),
+        null !== renderLanes &&
+          scheduleRetryEffect(workInProgress, renderLanes.retryQueue),
+        null
+      );
+    case 24:
+      return null;
+    case 25:
+      return null;
+  }
+  throw Error(
+    "Unknown unit of work tag (" +
+      workInProgress.tag +
+      "). This error is likely caused by a bug in React. Please file an issue."
+  );
+}
+function unwindWork(current, workInProgress) {
+  switch (workInProgress.tag) {
+    case 1:
+      return (
+        (current = workInProgress.flags),
+        current & 65536
+          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
+          : null
+      );
+    case 3:
+      return (
+        popHostContainer(),
+        (current = workInProgress.flags),
+        0 !== (current & 65536) && 0 === (current & 128)
+          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
+          : null
+      );
+    case 26:
+    case 27:
+    case 5:
+      return popHostContext(workInProgress), null;
+    case 13:
+      popSuspenseHandler(workInProgress);
+      current = workInProgress.memoizedState;
+      if (
+        null !== current &&
+        null !== current.dehydrated &&
+        null === workInProgress.alternate
+      )
+        throw Error(
+          "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
+        );
+      current = workInProgress.flags;
+      return current & 65536
+        ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
+        : null;
+    case 19:
+      return pop(suspenseStackCursor), null;
+    case 4:
+      return popHostContainer(), null;
+    case 10:
+      return popProvider(workInProgress.type._context), null;
+    case 22:
+    case 23:
+      return (
+        popSuspenseHandler(workInProgress),
+        popHiddenContext(),
+        (current = workInProgress.flags),
+        current & 65536
+          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
+          : null
+      );
+    case 24:
+      return null;
+    case 25:
+      return null;
+    default:
+      return null;
+  }
+}
+function unwindInterruptedWork(current, interruptedWork) {
+  switch (interruptedWork.tag) {
+    case 3:
+      popHostContainer();
+      break;
+    case 26:
+    case 27:
+    case 5:
+      popHostContext(interruptedWork);
+      break;
+    case 4:
+      popHostContainer();
+      break;
+    case 13:
+      popSuspenseHandler(interruptedWork);
       break;
     case 19:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      flags & 4 &&
-        ((flags = finishedWork.updateQueue),
-        null !== flags &&
-          ((finishedWork.updateQueue = null),
-          attachSuspenseRetryListeners(finishedWork, flags)));
+      pop(suspenseStackCursor);
       break;
-    case 21:
+    case 10:
+      popProvider(interruptedWork.type._context);
       break;
-    default:
-      recursivelyTraverseMutationEffects(root, finishedWork),
-        commitReconciliationEffects(finishedWork);
+    case 22:
+    case 23:
+      popSuspenseHandler(interruptedWork), popHiddenContext();
   }
 }
-function commitReconciliationEffects(finishedWork) {
-  var flags = finishedWork.flags;
-  if (flags & 2) {
-    try {
-      a: {
-        for (var parent = finishedWork.return; null !== parent; ) {
-          if (isHostParent(parent)) {
-            var JSCompiler_inline_result = parent;
-            break a;
-          }
-          parent = parent.return;
-        }
-        throw Error(
-          "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
-        );
-      }
-      switch (JSCompiler_inline_result.tag) {
+var offscreenSubtreeIsHidden = !1,
+  offscreenSubtreeWasHidden = !1,
+  PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
+  nextEffect = null;
+function safelyAttachRef(current, nearestMountedAncestor) {
+  try {
+    var ref = current.ref;
+    if (null !== ref) {
+      var instance = current.stateNode;
+      switch (current.tag) {
+        case 26:
         case 27:
         case 5:
-          var parent$jscomp$0 = JSCompiler_inline_result.stateNode;
-          JSCompiler_inline_result.flags & 32 &&
-            (JSCompiler_inline_result.flags &= -33);
-          var before = getHostSibling(finishedWork);
-          insertOrAppendPlacementNode(finishedWork, before, parent$jscomp$0);
-          break;
-        case 3:
-        case 4:
-          var parent$82 = JSCompiler_inline_result.stateNode.containerInfo,
-            before$83 = getHostSibling(finishedWork);
-          insertOrAppendPlacementNodeIntoContainer(
-            finishedWork,
-            before$83,
-            parent$82
-          );
+          var instanceToUse = getPublicInstance(instance);
           break;
         default:
-          throw Error(
-            "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
-          );
+          instanceToUse = instance;
       }
-    } catch (error) {
-      captureCommitPhaseError(finishedWork, finishedWork.return, error);
+      "function" === typeof ref
+        ? (current.refCleanup = ref(instanceToUse))
+        : (ref.current = instanceToUse);
     }
-    finishedWork.flags &= -3;
+  } catch (error) {
+    captureCommitPhaseError(current, nearestMountedAncestor, error);
   }
-  flags & 4096 && (finishedWork.flags &= -4097);
 }
-function recursivelyTraverseLayoutEffects(root, parentFiber) {
-  if (parentFiber.subtreeFlags & 8772)
-    for (parentFiber = parentFiber.child; null !== parentFiber; )
-      commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),
-        (parentFiber = parentFiber.sibling);
+function safelyDetachRef(current, nearestMountedAncestor) {
+  var ref = current.ref,
+    refCleanup = current.refCleanup;
+  if (null !== ref)
+    if ("function" === typeof refCleanup)
+      try {
+        refCleanup();
+      } catch (error) {
+        captureCommitPhaseError(current, nearestMountedAncestor, error);
+      } finally {
+        (current.refCleanup = null),
+          (current = current.alternate),
+          null != current && (current.refCleanup = null);
+      }
+    else if ("function" === typeof ref)
+      try {
+        ref(null);
+      } catch (error$76) {
+        captureCommitPhaseError(current, nearestMountedAncestor, error$76);
+      }
+    else ref.current = null;
 }
-function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
-  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
-    var finishedWork = parentFiber;
-    switch (finishedWork.tag) {
-      case 0:
-      case 11:
-      case 14:
-      case 15:
-        commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
-        recursivelyTraverseDisappearLayoutEffects(finishedWork);
-        break;
-      case 1:
-        safelyDetachRef(finishedWork, finishedWork.return);
-        var instance = finishedWork.stateNode;
-        if ("function" === typeof instance.componentWillUnmount) {
-          var current = finishedWork,
-            nearestMountedAncestor = finishedWork.return;
-          try {
-            var current$jscomp$0 = current;
-            instance.props = current$jscomp$0.memoizedProps;
-            instance.state = current$jscomp$0.memoizedState;
-            instance.componentWillUnmount();
-          } catch (error) {
-            captureCommitPhaseError(current, nearestMountedAncestor, error);
+function safelyCallDestroy(current, nearestMountedAncestor, destroy) {
+  try {
+    destroy();
+  } catch (error) {
+    captureCommitPhaseError(current, nearestMountedAncestor, error);
+  }
+}
+var shouldFireAfterActiveInstanceBlur = !1;
+function commitBeforeMutationEffects(root, firstChild) {
+  for (nextEffect = firstChild; null !== nextEffect; )
+    if (
+      ((root = nextEffect),
+      (firstChild = root.child),
+      0 !== (root.subtreeFlags & 1028) && null !== firstChild)
+    )
+      (firstChild.return = root), (nextEffect = firstChild);
+    else
+      for (; null !== nextEffect; ) {
+        root = nextEffect;
+        try {
+          var current = root.alternate,
+            flags = root.flags;
+          switch (root.tag) {
+            case 0:
+              break;
+            case 11:
+            case 15:
+              break;
+            case 1:
+              if (0 !== (flags & 1024) && null !== current) {
+                var prevProps = current.memoizedProps,
+                  prevState = current.memoizedState,
+                  instance = root.stateNode,
+                  snapshot = instance.getSnapshotBeforeUpdate(
+                    root.elementType === root.type
+                      ? prevProps
+                      : resolveDefaultProps(root.type, prevProps),
+                    prevState
+                  );
+                instance.__reactInternalSnapshotBeforeUpdate = snapshot;
+              }
+              break;
+            case 3:
+              break;
+            case 5:
+            case 26:
+            case 27:
+            case 6:
+            case 4:
+            case 17:
+              break;
+            default:
+              if (0 !== (flags & 1024))
+                throw Error(
+                  "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
+                );
           }
+        } catch (error) {
+          captureCommitPhaseError(root, root.return, error);
         }
-        recursivelyTraverseDisappearLayoutEffects(finishedWork);
-        break;
-      case 26:
-      case 27:
-      case 5:
-        safelyDetachRef(finishedWork, finishedWork.return);
-        recursivelyTraverseDisappearLayoutEffects(finishedWork);
-        break;
-      case 22:
-        safelyDetachRef(finishedWork, finishedWork.return);
-        null === finishedWork.memoizedState &&
-          recursivelyTraverseDisappearLayoutEffects(finishedWork);
-        break;
-      default:
-        recursivelyTraverseDisappearLayoutEffects(finishedWork);
-    }
-    parentFiber = parentFiber.sibling;
-  }
+        firstChild = root.sibling;
+        if (null !== firstChild) {
+          firstChild.return = root.return;
+          nextEffect = firstChild;
+          break;
+        }
+        nextEffect = root.return;
+      }
+  current = shouldFireAfterActiveInstanceBlur;
+  shouldFireAfterActiveInstanceBlur = !1;
+  return current;
 }
-function recursivelyTraverseReappearLayoutEffects(
-  finishedRoot$jscomp$0,
-  parentFiber,
-  includeWorkInProgressEffects
+function commitHookEffectListUnmount(
+  flags,
+  finishedWork,
+  nearestMountedAncestor
 ) {
-  includeWorkInProgressEffects =
-    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
-  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
-    var finishedRoot = finishedRoot$jscomp$0,
-      finishedWork = parentFiber,
-      flags = finishedWork.flags;
-    switch (finishedWork.tag) {
-      case 0:
-      case 11:
-      case 15:
-        recursivelyTraverseReappearLayoutEffects(
-          finishedRoot,
-          finishedWork,
-          includeWorkInProgressEffects
-        );
-        commitHookLayoutEffects(finishedWork, 4);
-        break;
-      case 1:
-        recursivelyTraverseReappearLayoutEffects(
-          finishedRoot,
-          finishedWork,
-          includeWorkInProgressEffects
-        );
-        var instance = finishedWork.stateNode;
-        if ("function" === typeof instance.componentDidMount)
-          try {
-            instance.componentDidMount();
-          } catch (error) {
-            captureCommitPhaseError(finishedWork, finishedWork.return, error);
-          }
-        finishedRoot = finishedWork.updateQueue;
-        if (null !== finishedRoot) {
-          var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
-          if (null !== hiddenCallbacks)
-            for (
-              finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0;
-              finishedRoot < hiddenCallbacks.length;
-              finishedRoot++
-            )
-              callCallback(hiddenCallbacks[finishedRoot], instance);
-        }
-        includeWorkInProgressEffects &&
-          flags & 64 &&
-          commitClassCallbacks(finishedWork);
-        safelyAttachRef(finishedWork, finishedWork.return);
-        break;
-      case 26:
-      case 27:
-      case 5:
-        recursivelyTraverseReappearLayoutEffects(
-          finishedRoot,
-          finishedWork,
-          includeWorkInProgressEffects
-        );
-        safelyAttachRef(finishedWork, finishedWork.return);
-        break;
-      case 12:
-        recursivelyTraverseReappearLayoutEffects(
-          finishedRoot,
-          finishedWork,
-          includeWorkInProgressEffects
-        );
-        break;
-      case 13:
-        recursivelyTraverseReappearLayoutEffects(
-          finishedRoot,
-          finishedWork,
-          includeWorkInProgressEffects
-        );
-        break;
-      case 22:
-        null === finishedWork.memoizedState &&
-          recursivelyTraverseReappearLayoutEffects(
-            finishedRoot,
-            finishedWork,
-            includeWorkInProgressEffects
-          );
-        safelyAttachRef(finishedWork, finishedWork.return);
-        break;
-      default:
-        recursivelyTraverseReappearLayoutEffects(
-          finishedRoot,
-          finishedWork,
-          includeWorkInProgressEffects
-        );
-    }
-    parentFiber = parentFiber.sibling;
+  var updateQueue = finishedWork.updateQueue;
+  updateQueue = null !== updateQueue ? updateQueue.lastEffect : null;
+  if (null !== updateQueue) {
+    var effect = (updateQueue = updateQueue.next);
+    do {
+      if ((effect.tag & flags) === flags) {
+        var inst = effect.inst,
+          destroy = inst.destroy;
+        void 0 !== destroy &&
+          ((inst.destroy = void 0),
+          safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy));
+      }
+      effect = effect.next;
+    } while (effect !== updateQueue);
   }
 }
-function commitHookPassiveMountEffects(finishedWork, hookFlags) {
+function commitHookEffectListMount(flags, finishedWork) {
+  finishedWork = finishedWork.updateQueue;
+  finishedWork = null !== finishedWork ? finishedWork.lastEffect : null;
+  if (null !== finishedWork) {
+    var effect = (finishedWork = finishedWork.next);
+    do {
+      if ((effect.tag & flags) === flags) {
+        var create$77 = effect.create,
+          inst = effect.inst;
+        create$77 = create$77();
+        inst.destroy = create$77;
+      }
+      effect = effect.next;
+    } while (effect !== finishedWork);
+  }
+}
+function commitHookLayoutEffects(finishedWork, hookFlags) {
   try {
     commitHookEffectListMount(hookFlags, finishedWork);
   } catch (error) {
     captureCommitPhaseError(finishedWork, finishedWork.return, error);
   }
 }
-function recursivelyTraversePassiveMountEffects(root, parentFiber) {
-  if (parentFiber.subtreeFlags & 10256)
-    for (parentFiber = parentFiber.child; null !== parentFiber; )
-      commitPassiveMountOnFiber(root, parentFiber),
-        (parentFiber = parentFiber.sibling);
+function commitClassCallbacks(finishedWork) {
+  var updateQueue = finishedWork.updateQueue;
+  if (null !== updateQueue) {
+    var instance = finishedWork.stateNode;
+    try {
+      commitCallbacks(updateQueue, instance);
+    } catch (error) {
+      captureCommitPhaseError(finishedWork, finishedWork.return, error);
+    }
+  }
 }
-function commitPassiveMountOnFiber(finishedRoot, finishedWork) {
+function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
   var flags = finishedWork.flags;
   switch (finishedWork.tag) {
     case 0:
     case 11:
     case 15:
-      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
-      flags & 2048 && commitHookPassiveMountEffects(finishedWork, 9);
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      flags & 4 && commitHookLayoutEffects(finishedWork, 5);
+      break;
+    case 1:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      if (flags & 4)
+        if (((finishedRoot = finishedWork.stateNode), null === current))
+          try {
+            finishedRoot.componentDidMount();
+          } catch (error) {
+            captureCommitPhaseError(finishedWork, finishedWork.return, error);
+          }
+        else {
+          var prevProps =
+            finishedWork.elementType === finishedWork.type
+              ? current.memoizedProps
+              : resolveDefaultProps(finishedWork.type, current.memoizedProps);
+          current = current.memoizedState;
+          try {
+            finishedRoot.componentDidUpdate(
+              prevProps,
+              current,
+              finishedRoot.__reactInternalSnapshotBeforeUpdate
+            );
+          } catch (error$78) {
+            captureCommitPhaseError(
+              finishedWork,
+              finishedWork.return,
+              error$78
+            );
+          }
+        }
+      flags & 64 && commitClassCallbacks(finishedWork);
+      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
       break;
     case 3:
-      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      if (flags & 64 && ((flags = finishedWork.updateQueue), null !== flags)) {
+        finishedRoot = null;
+        if (null !== finishedWork.child)
+          switch (finishedWork.child.tag) {
+            case 27:
+            case 5:
+              finishedRoot = getPublicInstance(finishedWork.child.stateNode);
+              break;
+            case 1:
+              finishedRoot = finishedWork.child.stateNode;
+          }
+        try {
+          commitCallbacks(flags, finishedRoot);
+        } catch (error) {
+          captureCommitPhaseError(finishedWork, finishedWork.return, error);
+        }
+      }
       break;
-    case 23:
+    case 26:
+    case 27:
+    case 5:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
       break;
-    case 22:
-      flags = finishedWork.stateNode;
-      null !== finishedWork.memoizedState
-        ? flags._visibility & 4
-          ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork)
-          : finishedWork.mode & 1 ||
-            ((flags._visibility |= 4),
-            recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork))
-        : flags._visibility & 4
-        ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork)
-        : ((flags._visibility |= 4),
-          recursivelyTraverseReconnectPassiveEffects(
-            finishedRoot,
-            finishedWork
-          ));
+    case 12:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
       break;
-    case 24:
-      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
+    case 13:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      break;
+    case 22:
+      if (0 !== (finishedWork.mode & 1)) {
+        if (
+          ((prevProps =
+            null !== finishedWork.memoizedState || offscreenSubtreeIsHidden),
+          !prevProps)
+        ) {
+          current =
+            (null !== current && null !== current.memoizedState) ||
+            offscreenSubtreeWasHidden;
+          var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
+            prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
+          offscreenSubtreeIsHidden = prevProps;
+          (offscreenSubtreeWasHidden = current) &&
+          !prevOffscreenSubtreeWasHidden
+            ? recursivelyTraverseReappearLayoutEffects(
+                finishedRoot,
+                finishedWork,
+                0 !== (finishedWork.subtreeFlags & 8772)
+              )
+            : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
+          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
+        }
+      } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      flags & 512 &&
+        ("manual" === finishedWork.memoizedProps.mode
+          ? safelyAttachRef(finishedWork, finishedWork.return)
+          : safelyDetachRef(finishedWork, finishedWork.return));
       break;
     default:
-      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
   }
 }
-function recursivelyTraverseReconnectPassiveEffects(
-  finishedRoot$jscomp$0,
-  parentFiber
-) {
-  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
-    var finishedRoot = finishedRoot$jscomp$0,
-      finishedWork = parentFiber;
-    switch (finishedWork.tag) {
-      case 0:
-      case 11:
-      case 15:
-        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork);
-        commitHookPassiveMountEffects(finishedWork, 8);
-        break;
-      case 23:
-        break;
-      case 22:
-        var instance = finishedWork.stateNode;
-        null !== finishedWork.memoizedState
-          ? instance._visibility & 4
-            ? recursivelyTraverseReconnectPassiveEffects(
-                finishedRoot,
-                finishedWork
-              )
-            : finishedWork.mode & 1 ||
-              ((instance._visibility |= 4),
-              recursivelyTraverseReconnectPassiveEffects(
-                finishedRoot,
-                finishedWork
-              ))
-          : ((instance._visibility |= 4),
-            recursivelyTraverseReconnectPassiveEffects(
-              finishedRoot,
-              finishedWork
-            ));
-        break;
-      case 24:
-        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork);
-        break;
-      default:
-        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork);
+function detachFiberAfterEffects(fiber) {
+  var alternate = fiber.alternate;
+  null !== alternate &&
+    ((fiber.alternate = null), detachFiberAfterEffects(alternate));
+  fiber.child = null;
+  fiber.deletions = null;
+  fiber.sibling = null;
+  fiber.stateNode = null;
+  fiber.return = null;
+  fiber.dependencies = null;
+  fiber.memoizedProps = null;
+  fiber.memoizedState = null;
+  fiber.pendingProps = null;
+  fiber.stateNode = null;
+  fiber.updateQueue = null;
+}
+function isHostParent(fiber) {
+  return 5 === fiber.tag || 3 === fiber.tag || 4 === fiber.tag;
+}
+function getHostSibling(fiber) {
+  a: for (;;) {
+    for (; null === fiber.sibling; ) {
+      if (null === fiber.return || isHostParent(fiber.return)) return null;
+      fiber = fiber.return;
     }
-    parentFiber = parentFiber.sibling;
+    fiber.sibling.return = fiber.return;
+    for (
+      fiber = fiber.sibling;
+      5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;
+
+    ) {
+      if (fiber.flags & 2) continue a;
+      if (null === fiber.child || 4 === fiber.tag) continue a;
+      else (fiber.child.return = fiber), (fiber = fiber.child);
+    }
+    if (!(fiber.flags & 2)) return fiber.stateNode;
   }
 }
-var suspenseyCommitFlag = 8192;
-function recursivelyAccumulateSuspenseyCommit(parentFiber) {
-  if (parentFiber.subtreeFlags & suspenseyCommitFlag)
-    for (parentFiber = parentFiber.child; null !== parentFiber; )
-      accumulateSuspenseyCommitOnFiber(parentFiber),
-        (parentFiber = parentFiber.sibling);
+function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
+  var tag = node.tag;
+  if (5 === tag || 6 === tag)
+    if (((node = node.stateNode), before)) {
+      if ("number" === typeof parent)
+        throw Error("Container does not support insertBefore operation");
+    } else
+      ReactNativePrivateInterface.UIManager.setChildren(parent, [
+        "number" === typeof node ? node : node._nativeTag
+      ]);
+  else if (4 !== tag && ((node = node.child), null !== node))
+    for (
+      insertOrAppendPlacementNodeIntoContainer(node, before, parent),
+        node = node.sibling;
+      null !== node;
+
+    )
+      insertOrAppendPlacementNodeIntoContainer(node, before, parent),
+        (node = node.sibling);
 }
-function accumulateSuspenseyCommitOnFiber(fiber) {
-  switch (fiber.tag) {
+function insertOrAppendPlacementNode(node, before, parent) {
+  var tag = node.tag;
+  if (5 === tag || 6 === tag)
+    if (((node = node.stateNode), before)) {
+      tag = parent._children;
+      var index = tag.indexOf(node);
+      0 <= index
+        ? (tag.splice(index, 1),
+          (before = tag.indexOf(before)),
+          tag.splice(before, 0, node),
+          ReactNativePrivateInterface.UIManager.manageChildren(
+            parent._nativeTag,
+            [index],
+            [before],
+            [],
+            [],
+            []
+          ))
+        : ((before = tag.indexOf(before)),
+          tag.splice(before, 0, node),
+          ReactNativePrivateInterface.UIManager.manageChildren(
+            parent._nativeTag,
+            [],
+            [],
+            ["number" === typeof node ? node : node._nativeTag],
+            [before],
+            []
+          ));
+    } else
+      (before = "number" === typeof node ? node : node._nativeTag),
+        (tag = parent._children),
+        (index = tag.indexOf(node)),
+        0 <= index
+          ? (tag.splice(index, 1),
+            tag.push(node),
+            ReactNativePrivateInterface.UIManager.manageChildren(
+              parent._nativeTag,
+              [index],
+              [tag.length - 1],
+              [],
+              [],
+              []
+            ))
+          : (tag.push(node),
+            ReactNativePrivateInterface.UIManager.manageChildren(
+              parent._nativeTag,
+              [],
+              [],
+              [before],
+              [tag.length - 1],
+              []
+            ));
+  else if (4 !== tag && ((node = node.child), null !== node))
+    for (
+      insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
+      null !== node;
+
+    )
+      insertOrAppendPlacementNode(node, before, parent), (node = node.sibling);
+}
+var hostParent = null,
+  hostParentIsContainer = !1;
+function recursivelyTraverseDeletionEffects(
+  finishedRoot,
+  nearestMountedAncestor,
+  parent
+) {
+  for (parent = parent.child; null !== parent; )
+    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent),
+      (parent = parent.sibling);
+}
+function commitDeletionEffectsOnFiber(
+  finishedRoot,
+  nearestMountedAncestor,
+  deletedFiber
+) {
+  if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
+    try {
+      injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
+    } catch (err) {}
+  switch (deletedFiber.tag) {
     case 26:
-      recursivelyAccumulateSuspenseyCommit(fiber);
-      if (fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState)
-        throw Error(
-          "The current renderer does not support Resources. This error is likely caused by a bug in React. Please file an issue."
-        );
+    case 27:
+    case 5:
+      offscreenSubtreeWasHidden ||
+        safelyDetachRef(deletedFiber, nearestMountedAncestor);
+    case 6:
+      var prevHostParent = hostParent,
+        prevHostParentIsContainer = hostParentIsContainer;
+      hostParent = null;
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
+      hostParent = prevHostParent;
+      hostParentIsContainer = prevHostParentIsContainer;
+      null !== hostParent &&
+        (hostParentIsContainer
+          ? ((finishedRoot = hostParent),
+            recursivelyUncacheFiberNode(deletedFiber.stateNode),
+            ReactNativePrivateInterface.UIManager.manageChildren(
+              finishedRoot,
+              [],
+              [],
+              [],
+              [],
+              [0]
+            ))
+          : ((finishedRoot = hostParent),
+            (nearestMountedAncestor = deletedFiber.stateNode),
+            recursivelyUncacheFiberNode(nearestMountedAncestor),
+            (deletedFiber = finishedRoot._children),
+            (nearestMountedAncestor = deletedFiber.indexOf(
+              nearestMountedAncestor
+            )),
+            deletedFiber.splice(nearestMountedAncestor, 1),
+            ReactNativePrivateInterface.UIManager.manageChildren(
+              finishedRoot._nativeTag,
+              [],
+              [],
+              [],
+              [],
+              [nearestMountedAncestor]
+            )));
       break;
-    case 5:
-      recursivelyAccumulateSuspenseyCommit(fiber);
+    case 18:
+      null !== hostParent && shim$1();
       break;
-    case 3:
     case 4:
-      recursivelyAccumulateSuspenseyCommit(fiber);
-      break;
-    case 22:
-      if (null === fiber.memoizedState) {
-        var current = fiber.alternate;
-        null !== current && null !== current.memoizedState
-          ? ((current = suspenseyCommitFlag),
-            (suspenseyCommitFlag = 16777216),
-            recursivelyAccumulateSuspenseyCommit(fiber),
-            (suspenseyCommitFlag = current))
-          : recursivelyAccumulateSuspenseyCommit(fiber);
-      }
+      prevHostParent = hostParent;
+      prevHostParentIsContainer = hostParentIsContainer;
+      hostParent = deletedFiber.stateNode.containerInfo;
+      hostParentIsContainer = !0;
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
+      hostParent = prevHostParent;
+      hostParentIsContainer = prevHostParentIsContainer;
       break;
-    default:
-      recursivelyAccumulateSuspenseyCommit(fiber);
-  }
-}
-function detachAlternateSiblings(parentFiber) {
-  var previousFiber = parentFiber.alternate;
-  if (
-    null !== previousFiber &&
-    ((parentFiber = previousFiber.child), null !== parentFiber)
-  ) {
-    previousFiber.child = null;
-    do
-      (previousFiber = parentFiber.sibling),
-        (parentFiber.sibling = null),
-        (parentFiber = previousFiber);
-    while (null !== parentFiber);
-  }
-}
-function recursivelyTraversePassiveUnmountEffects(parentFiber) {
-  var deletions = parentFiber.deletions;
-  if (0 !== (parentFiber.flags & 16)) {
-    if (null !== deletions)
-      for (var i = 0; i < deletions.length; i++) {
-        var childToDelete = deletions[i];
-        nextEffect = childToDelete;
-        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
-          childToDelete,
-          parentFiber
-        );
-      }
-    detachAlternateSiblings(parentFiber);
-  }
-  if (parentFiber.subtreeFlags & 10256)
-    for (parentFiber = parentFiber.child; null !== parentFiber; )
-      commitPassiveUnmountOnFiber(parentFiber),
-        (parentFiber = parentFiber.sibling);
-}
-function commitPassiveUnmountOnFiber(finishedWork) {
-  switch (finishedWork.tag) {
     case 0:
     case 11:
+    case 14:
     case 15:
-      recursivelyTraversePassiveUnmountEffects(finishedWork);
-      finishedWork.flags & 2048 &&
-        commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
+      if (
+        !offscreenSubtreeWasHidden &&
+        ((prevHostParent = deletedFiber.updateQueue),
+        null !== prevHostParent &&
+          ((prevHostParent = prevHostParent.lastEffect),
+          null !== prevHostParent))
+      ) {
+        prevHostParentIsContainer = prevHostParent = prevHostParent.next;
+        do {
+          var tag = prevHostParentIsContainer.tag,
+            inst = prevHostParentIsContainer.inst,
+            destroy = inst.destroy;
+          void 0 !== destroy &&
+            (0 !== (tag & 2)
+              ? ((inst.destroy = void 0),
+                safelyCallDestroy(
+                  deletedFiber,
+                  nearestMountedAncestor,
+                  destroy
+                ))
+              : 0 !== (tag & 4) &&
+                ((inst.destroy = void 0),
+                safelyCallDestroy(
+                  deletedFiber,
+                  nearestMountedAncestor,
+                  destroy
+                )));
+          prevHostParentIsContainer = prevHostParentIsContainer.next;
+        } while (prevHostParentIsContainer !== prevHostParent);
+      }
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
+      break;
+    case 1:
+      if (
+        !offscreenSubtreeWasHidden &&
+        (safelyDetachRef(deletedFiber, nearestMountedAncestor),
+        (prevHostParent = deletedFiber.stateNode),
+        "function" === typeof prevHostParent.componentWillUnmount)
+      )
+        try {
+          (prevHostParent.props = deletedFiber.memoizedProps),
+            (prevHostParent.state = deletedFiber.memoizedState),
+            prevHostParent.componentWillUnmount();
+        } catch (error) {
+          captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
+        }
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
+      break;
+    case 21:
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
       break;
     case 22:
-      var instance = finishedWork.stateNode;
-      null !== finishedWork.memoizedState &&
-      instance._visibility & 4 &&
-      (null === finishedWork.return || 13 !== finishedWork.return.tag)
-        ? ((instance._visibility &= -5),
-          recursivelyTraverseDisconnectPassiveEffects(finishedWork))
-        : recursivelyTraversePassiveUnmountEffects(finishedWork);
+      safelyDetachRef(deletedFiber, nearestMountedAncestor);
+      deletedFiber.mode & 1
+        ? ((offscreenSubtreeWasHidden =
+            (prevHostParent = offscreenSubtreeWasHidden) ||
+            null !== deletedFiber.memoizedState),
+          recursivelyTraverseDeletionEffects(
+            finishedRoot,
+            nearestMountedAncestor,
+            deletedFiber
+          ),
+          (offscreenSubtreeWasHidden = prevHostParent))
+        : recursivelyTraverseDeletionEffects(
+            finishedRoot,
+            nearestMountedAncestor,
+            deletedFiber
+          );
       break;
     default:
-      recursivelyTraversePassiveUnmountEffects(finishedWork);
-  }
-}
-function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
-  var deletions = parentFiber.deletions;
-  if (0 !== (parentFiber.flags & 16)) {
-    if (null !== deletions)
-      for (var i = 0; i < deletions.length; i++) {
-        var childToDelete = deletions[i];
-        nextEffect = childToDelete;
-        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
-          childToDelete,
-          parentFiber
-        );
-      }
-    detachAlternateSiblings(parentFiber);
-  }
-  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
-    deletions = parentFiber;
-    switch (deletions.tag) {
-      case 0:
-      case 11:
-      case 15:
-        commitHookEffectListUnmount(8, deletions, deletions.return);
-        recursivelyTraverseDisconnectPassiveEffects(deletions);
-        break;
-      case 22:
-        i = deletions.stateNode;
-        i._visibility & 4 &&
-          ((i._visibility &= -5),
-          recursivelyTraverseDisconnectPassiveEffects(deletions));
-        break;
-      default:
-        recursivelyTraverseDisconnectPassiveEffects(deletions);
-    }
-    parentFiber = parentFiber.sibling;
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
   }
 }
-function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
-  deletedSubtreeRoot,
-  nearestMountedAncestor
-) {
-  for (; null !== nextEffect; ) {
-    var fiber = nextEffect;
-    switch (fiber.tag) {
-      case 0:
-      case 11:
-      case 15:
-        commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
-    }
-    var child = fiber.child;
-    if (null !== child) (child.return = fiber), (nextEffect = child);
-    else
-      a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
-        child = nextEffect;
-        var sibling = child.sibling,
-          returnFiber = child.return;
-        detachFiberAfterEffects(child);
-        if (child === fiber) {
-          nextEffect = null;
-          break a;
-        }
-        if (null !== sibling) {
-          sibling.return = returnFiber;
-          nextEffect = sibling;
-          break a;
-        }
-        nextEffect = returnFiber;
-      }
+function getRetryCache(finishedWork) {
+  switch (finishedWork.tag) {
+    case 13:
+    case 19:
+      var retryCache = finishedWork.stateNode;
+      null === retryCache &&
+        (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
+      return retryCache;
+    case 22:
+      return (
+        (finishedWork = finishedWork.stateNode),
+        (retryCache = finishedWork._retryCache),
+        null === retryCache &&
+          (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),
+        retryCache
+      );
+    default:
+      throw Error(
+        "Unexpected Suspense handler tag (" +
+          finishedWork.tag +
+          "). This is a bug in React."
+      );
   }
 }
-var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
-  ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher,
-  ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner,
-  ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig,
-  executionContext = 0,
-  workInProgressRoot = null,
-  workInProgress = null,
-  workInProgressRootRenderLanes = 0,
-  workInProgressSuspendedReason = 0,
-  workInProgressThrownValue = null,
-  workInProgressRootDidAttachPingListener = !1,
-  entangledRenderLanes = 0,
-  workInProgressRootExitStatus = 0,
-  workInProgressRootFatalError = null,
-  workInProgressRootSkippedLanes = 0,
-  workInProgressRootInterleavedUpdatedLanes = 0,
-  workInProgressRootPingedLanes = 0,
-  workInProgressDeferredLane = 0,
-  workInProgressRootConcurrentErrors = null,
-  workInProgressRootRecoverableErrors = null,
-  globalMostRecentFallbackTime = 0,
-  workInProgressRootRenderTargetTime = Infinity,
-  workInProgressTransitions = null,
-  hasUncaughtError = !1,
-  firstUncaughtError = null,
-  legacyErrorBoundariesThatAlreadyFailed = null,
-  rootDoesHavePassiveEffects = !1,
-  rootWithPendingPassiveEffects = null,
-  pendingPassiveEffectsLanes = 0,
-  nestedUpdateCount = 0,
-  rootWithNestedUpdates = null;
-function requestUpdateLane(fiber) {
-  if (0 === (fiber.mode & 1)) return 2;
-  if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)
-    return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
-  fiber = ReactCurrentBatchConfig$1.transition;
-  null !== fiber && fiber._callbacks.add(handleAsyncAction);
-  if (null !== fiber)
-    return (
-      0 === currentEventTransitionLane &&
-        (currentEventTransitionLane = claimNextTransitionLane()),
-      currentEventTransitionLane
-    );
-  fiber = currentUpdatePriority;
-  return 0 !== fiber ? fiber : 32;
-}
-function requestDeferredLane() {
-  0 === workInProgressDeferredLane &&
-    (workInProgressDeferredLane =
-      0 !== (workInProgressRootRenderLanes & 536870912)
-        ? 536870912
-        : claimNextTransitionLane());
-  var suspenseHandler = suspenseHandlerStackCursor.current;
-  null !== suspenseHandler && (suspenseHandler.flags |= 32);
-  return workInProgressDeferredLane;
+function attachSuspenseRetryListeners(finishedWork, wakeables) {
+  var retryCache = getRetryCache(finishedWork);
+  wakeables.forEach(function (wakeable) {
+    var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
+    retryCache.has(wakeable) ||
+      (retryCache.add(wakeable), wakeable.then(retry, retry));
+  });
 }
-function scheduleUpdateOnFiber(root, fiber, lane) {
-  if (
-    (root === workInProgressRoot && 2 === workInProgressSuspendedReason) ||
-    null !== root.cancelPendingCommit
-  )
-    prepareFreshStack(root, 0),
-      markRootSuspended(
-        root,
-        workInProgressRootRenderLanes,
-        workInProgressDeferredLane
-      );
-  markRootUpdated(root, lane);
-  if (0 === (executionContext & 2) || root !== workInProgressRoot)
-    root === workInProgressRoot &&
-      (0 === (executionContext & 2) &&
-        (workInProgressRootInterleavedUpdatedLanes |= lane),
-      4 === workInProgressRootExitStatus &&
-        markRootSuspended(
-          root,
-          workInProgressRootRenderLanes,
-          workInProgressDeferredLane
-        )),
-      ensureRootIsScheduled(root),
-      2 === lane &&
-        0 === executionContext &&
-        0 === (fiber.mode & 1) &&
-        ((workInProgressRootRenderTargetTime = now() + 500),
-        flushSyncWorkAcrossRoots_impl(!0));
+function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
+  var deletions = parentFiber.deletions;
+  if (null !== deletions)
+    for (var i = 0; i < deletions.length; i++) {
+      var childToDelete = deletions[i];
+      try {
+        var root = root$jscomp$0,
+          returnFiber = parentFiber,
+          parent = returnFiber;
+        a: for (; null !== parent; ) {
+          switch (parent.tag) {
+            case 27:
+            case 5:
+              hostParent = parent.stateNode;
+              hostParentIsContainer = !1;
+              break a;
+            case 3:
+              hostParent = parent.stateNode.containerInfo;
+              hostParentIsContainer = !0;
+              break a;
+            case 4:
+              hostParent = parent.stateNode.containerInfo;
+              hostParentIsContainer = !0;
+              break a;
+          }
+          parent = parent.return;
+        }
+        if (null === hostParent)
+          throw Error(
+            "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
+          );
+        commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);
+        hostParent = null;
+        hostParentIsContainer = !1;
+        var alternate = childToDelete.alternate;
+        null !== alternate && (alternate.return = null);
+        childToDelete.return = null;
+      } catch (error) {
+        captureCommitPhaseError(childToDelete, parentFiber, error);
+      }
+    }
+  if (parentFiber.subtreeFlags & 12854)
+    for (parentFiber = parentFiber.child; null !== parentFiber; )
+      commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),
+        (parentFiber = parentFiber.sibling);
 }
-function performConcurrentWorkOnRoot(root, didTimeout) {
-  if (0 !== (executionContext & 6))
-    throw Error("Should not already be working.");
-  var originalCallbackNode = root.callbackNode;
-  if (flushPassiveEffects() && root.callbackNode !== originalCallbackNode)
-    return null;
-  var lanes = getNextLanes(
-    root,
-    root === workInProgressRoot ? workInProgressRootRenderLanes : 0
-  );
-  if (0 === lanes) return null;
-  var exitStatus = (didTimeout =
-    0 === (lanes & 60) && 0 === (lanes & root.expiredLanes) && !didTimeout)
-    ? renderRootConcurrent(root, lanes)
-    : renderRootSync(root, lanes);
-  if (0 !== exitStatus) {
-    var renderWasConcurrent = didTimeout;
-    do {
-      if (6 === exitStatus) markRootSuspended(root, lanes, 0);
-      else {
-        didTimeout = root.current.alternate;
-        if (
-          renderWasConcurrent &&
-          !isRenderConsistentWithExternalStores(didTimeout)
-        ) {
-          exitStatus = renderRootSync(root, lanes);
-          renderWasConcurrent = !1;
-          continue;
+function commitMutationEffectsOnFiber(finishedWork, root) {
+  var current = finishedWork.alternate,
+    flags = finishedWork.flags;
+  switch (finishedWork.tag) {
+    case 0:
+    case 11:
+    case 14:
+    case 15:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      if (flags & 4) {
+        try {
+          commitHookEffectListUnmount(3, finishedWork, finishedWork.return),
+            commitHookEffectListMount(3, finishedWork);
+        } catch (error) {
+          captureCommitPhaseError(finishedWork, finishedWork.return, error);
         }
-        if (2 === exitStatus) {
-          renderWasConcurrent = lanes;
-          var errorRetryLanes = getLanesToRetrySynchronouslyOnError(
-            root,
-            renderWasConcurrent
+        try {
+          commitHookEffectListUnmount(5, finishedWork, finishedWork.return);
+        } catch (error$86) {
+          captureCommitPhaseError(finishedWork, finishedWork.return, error$86);
+        }
+      }
+      break;
+    case 1:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      flags & 512 &&
+        null !== current &&
+        safelyDetachRef(current, current.return);
+      flags & 64 &&
+        offscreenSubtreeIsHidden &&
+        ((finishedWork = finishedWork.updateQueue),
+        null !== finishedWork &&
+          ((flags = finishedWork.callbacks),
+          null !== flags &&
+            ((current = finishedWork.shared.hiddenCallbacks),
+            (finishedWork.shared.hiddenCallbacks =
+              null === current ? flags : current.concat(flags)))));
+      break;
+    case 26:
+    case 27:
+    case 5:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      flags & 512 &&
+        null !== current &&
+        safelyDetachRef(current, current.return);
+      if (flags & 4 && ((flags = finishedWork.stateNode), null != flags)) {
+        var newProps = finishedWork.memoizedProps;
+        current = null !== current ? current.memoizedProps : newProps;
+        finishedWork.updateQueue = null;
+        try {
+          var viewConfig = flags.viewConfig;
+          instanceProps.set(flags._nativeTag, newProps);
+          var updatePayload = diffProperties(
+            null,
+            current,
+            newProps,
+            viewConfig.validAttributes
           );
-          0 !== errorRetryLanes &&
-            ((lanes = errorRetryLanes),
-            (exitStatus = recoverFromConcurrentError(
-              root,
-              renderWasConcurrent,
-              errorRetryLanes
-            )));
+          null != updatePayload &&
+            ReactNativePrivateInterface.UIManager.updateView(
+              flags._nativeTag,
+              viewConfig.uiViewClassName,
+              updatePayload
+            );
+        } catch (error$89) {
+          captureCommitPhaseError(finishedWork, finishedWork.return, error$89);
         }
-        if (1 === exitStatus)
-          throw (
-            ((originalCallbackNode = workInProgressRootFatalError),
-            prepareFreshStack(root, 0),
-            markRootSuspended(root, lanes, 0),
-            ensureRootIsScheduled(root),
-            originalCallbackNode)
+      }
+      break;
+    case 6:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      if (flags & 4) {
+        if (null === finishedWork.stateNode)
+          throw Error(
+            "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
+          );
+        flags = finishedWork.stateNode;
+        current = finishedWork.memoizedProps;
+        try {
+          ReactNativePrivateInterface.UIManager.updateView(
+            flags,
+            "RCTRawText",
+            { text: current }
           );
-        root.finishedWork = didTimeout;
-        root.finishedLanes = lanes;
-        a: {
-          renderWasConcurrent = root;
-          switch (exitStatus) {
-            case 0:
-            case 1:
-              throw Error("Root did not complete. This is a bug in React.");
-            case 4:
-              if ((lanes & 4194176) === lanes) {
-                markRootSuspended(
-                  renderWasConcurrent,
-                  lanes,
-                  workInProgressDeferredLane
+        } catch (error$90) {
+          captureCommitPhaseError(finishedWork, finishedWork.return, error$90);
+        }
+      }
+      break;
+    case 3:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      break;
+    case 4:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      break;
+    case 13:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      finishedWork.child.flags & 8192 &&
+        ((current = null !== current && null !== current.memoizedState),
+        null === finishedWork.memoizedState ||
+          current ||
+          (globalMostRecentFallbackTime = now()));
+      flags & 4 &&
+        ((flags = finishedWork.updateQueue),
+        null !== flags &&
+          ((finishedWork.updateQueue = null),
+          attachSuspenseRetryListeners(finishedWork, flags)));
+      break;
+    case 22:
+      flags & 512 &&
+        null !== current &&
+        safelyDetachRef(current, current.return);
+      viewConfig = null !== finishedWork.memoizedState;
+      updatePayload = null !== current && null !== current.memoizedState;
+      if (finishedWork.mode & 1) {
+        var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
+          prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
+        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || viewConfig;
+        offscreenSubtreeWasHidden =
+          prevOffscreenSubtreeWasHidden || updatePayload;
+        recursivelyTraverseMutationEffects(root, finishedWork);
+        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
+        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
+      } else recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      root = finishedWork.stateNode;
+      root._current = finishedWork;
+      root._visibility &= -3;
+      root._visibility |= root._pendingVisibility & 2;
+      if (
+        flags & 8192 &&
+        ((root._visibility = viewConfig
+          ? root._visibility & -2
+          : root._visibility | 1),
+        viewConfig &&
+          ((root = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden),
+          null === current ||
+            updatePayload ||
+            root ||
+            (0 !== (finishedWork.mode & 1) &&
+              recursivelyTraverseDisappearLayoutEffects(finishedWork))),
+        null === finishedWork.memoizedProps ||
+          "manual" !== finishedWork.memoizedProps.mode)
+      )
+        a: for (current = null, root = finishedWork; ; ) {
+          if (5 === root.tag) {
+            if (null === current) {
+              current = root;
+              try {
+                if (((newProps = root.stateNode), viewConfig)) {
+                  var viewConfig$jscomp$0 = newProps.viewConfig;
+                  var updatePayload$jscomp$0 = diffProperties(
+                    null,
+                    emptyObject,
+                    { style: { display: "none" } },
+                    viewConfig$jscomp$0.validAttributes
+                  );
+                  ReactNativePrivateInterface.UIManager.updateView(
+                    newProps._nativeTag,
+                    viewConfig$jscomp$0.uiViewClassName,
+                    updatePayload$jscomp$0
+                  );
+                } else {
+                  var instance = root.stateNode,
+                    props = root.memoizedProps,
+                    viewConfig$jscomp$1 = instance.viewConfig,
+                    prevProps = assign({}, props, {
+                      style: [props.style, { display: "none" }]
+                    });
+                  var updatePayload$jscomp$1 = diffProperties(
+                    null,
+                    prevProps,
+                    props,
+                    viewConfig$jscomp$1.validAttributes
+                  );
+                  ReactNativePrivateInterface.UIManager.updateView(
+                    instance._nativeTag,
+                    viewConfig$jscomp$1.uiViewClassName,
+                    updatePayload$jscomp$1
+                  );
+                }
+              } catch (error) {
+                captureCommitPhaseError(
+                  finishedWork,
+                  finishedWork.return,
+                  error
                 );
-                break a;
               }
-              break;
-            case 2:
-            case 3:
-            case 5:
-              break;
-            default:
-              throw Error("Unknown root exit status.");
-          }
-          if (
-            (lanes & 62914560) === lanes &&
-            3 === exitStatus &&
-            ((exitStatus = globalMostRecentFallbackTime + 300 - now()),
-            10 < exitStatus)
+            }
+          } else if (6 === root.tag) {
+            if (null === current)
+              try {
+                throw Error("Not yet implemented.");
+              } catch (error$80) {
+                captureCommitPhaseError(
+                  finishedWork,
+                  finishedWork.return,
+                  error$80
+                );
+              }
+          } else if (
+            ((22 !== root.tag && 23 !== root.tag) ||
+              null === root.memoizedState ||
+              root === finishedWork) &&
+            null !== root.child
           ) {
-            markRootSuspended(
-              renderWasConcurrent,
-              lanes,
-              workInProgressDeferredLane
-            );
-            if (0 !== getNextLanes(renderWasConcurrent, 0)) break a;
-            renderWasConcurrent.timeoutHandle = scheduleTimeout(
-              commitRootWhenReady.bind(
-                null,
-                renderWasConcurrent,
-                didTimeout,
-                workInProgressRootRecoverableErrors,
-                workInProgressTransitions,
-                lanes,
-                workInProgressDeferredLane
-              ),
-              exitStatus
-            );
-            break a;
+            root.child.return = root;
+            root = root.child;
+            continue;
           }
-          commitRootWhenReady(
-            renderWasConcurrent,
-            didTimeout,
-            workInProgressRootRecoverableErrors,
-            workInProgressTransitions,
-            lanes,
-            workInProgressDeferredLane
-          );
+          if (root === finishedWork) break a;
+          for (; null === root.sibling; ) {
+            if (null === root.return || root.return === finishedWork) break a;
+            current === root && (current = null);
+            root = root.return;
+          }
+          current === root && (current = null);
+          root.sibling.return = root.return;
+          root = root.sibling;
         }
-      }
+      flags & 4 &&
+        ((flags = finishedWork.updateQueue),
+        null !== flags &&
+          ((current = flags.retryQueue),
+          null !== current &&
+            ((flags.retryQueue = null),
+            attachSuspenseRetryListeners(finishedWork, current))));
       break;
-    } while (1);
-  }
-  ensureRootIsScheduled(root);
-  scheduleTaskForRootDuringMicrotask(root, now());
-  root =
-    root.callbackNode === originalCallbackNode
-      ? performConcurrentWorkOnRoot.bind(null, root)
-      : null;
-  return root;
-}
-function recoverFromConcurrentError(
-  root,
-  originallyAttemptedLanes,
-  errorRetryLanes
-) {
-  var errorsFromFirstAttempt = workInProgressRootConcurrentErrors,
-    JSCompiler_inline_result;
-  (JSCompiler_inline_result = root.current.memoizedState.isDehydrated) &&
-    (prepareFreshStack(root, errorRetryLanes).flags |= 256);
-  errorRetryLanes = renderRootSync(root, errorRetryLanes);
-  if (2 !== errorRetryLanes) {
-    if (workInProgressRootDidAttachPingListener && !JSCompiler_inline_result)
-      return (
-        (root.errorRecoveryDisabledLanes |= originallyAttemptedLanes),
-        (workInProgressRootInterleavedUpdatedLanes |= originallyAttemptedLanes),
-        4
-      );
-    root = workInProgressRootRecoverableErrors;
-    workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
-    null !== root && queueRecoverableErrors(root);
-  }
-  return errorRetryLanes;
-}
-function queueRecoverableErrors(errors) {
-  null === workInProgressRootRecoverableErrors
-    ? (workInProgressRootRecoverableErrors = errors)
-    : workInProgressRootRecoverableErrors.push.apply(
-        workInProgressRootRecoverableErrors,
-        errors
-      );
-}
-function commitRootWhenReady(
-  root,
-  finishedWork,
-  recoverableErrors,
-  transitions,
-  lanes,
-  spawnedLane
-) {
-  0 === (lanes & 42) && accumulateSuspenseyCommitOnFiber(finishedWork);
-  commitRoot(root, recoverableErrors, transitions, spawnedLane);
+    case 19:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      flags & 4 &&
+        ((flags = finishedWork.updateQueue),
+        null !== flags &&
+          ((finishedWork.updateQueue = null),
+          attachSuspenseRetryListeners(finishedWork, flags)));
+      break;
+    case 21:
+      break;
+    default:
+      recursivelyTraverseMutationEffects(root, finishedWork),
+        commitReconciliationEffects(finishedWork);
+  }
 }
-function isRenderConsistentWithExternalStores(finishedWork) {
-  for (var node = finishedWork; ; ) {
-    if (node.flags & 16384) {
-      var updateQueue = node.updateQueue;
-      if (
-        null !== updateQueue &&
-        ((updateQueue = updateQueue.stores), null !== updateQueue)
-      )
-        for (var i = 0; i < updateQueue.length; i++) {
-          var check = updateQueue[i],
-            getSnapshot = check.getSnapshot;
-          check = check.value;
-          try {
-            if (!objectIs(getSnapshot(), check)) return !1;
-          } catch (error) {
-            return !1;
+function commitReconciliationEffects(finishedWork) {
+  var flags = finishedWork.flags;
+  if (flags & 2) {
+    try {
+      a: {
+        for (var parent = finishedWork.return; null !== parent; ) {
+          if (isHostParent(parent)) {
+            var JSCompiler_inline_result = parent;
+            break a;
           }
+          parent = parent.return;
         }
-    }
-    updateQueue = node.child;
-    if (node.subtreeFlags & 16384 && null !== updateQueue)
-      (updateQueue.return = node), (node = updateQueue);
-    else {
-      if (node === finishedWork) break;
-      for (; null === node.sibling; ) {
-        if (null === node.return || node.return === finishedWork) return !0;
-        node = node.return;
+        throw Error(
+          "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
+        );
       }
-      node.sibling.return = node.return;
-      node = node.sibling;
+      switch (JSCompiler_inline_result.tag) {
+        case 27:
+        case 5:
+          var parent$jscomp$0 = JSCompiler_inline_result.stateNode;
+          JSCompiler_inline_result.flags & 32 &&
+            (JSCompiler_inline_result.flags &= -33);
+          var before = getHostSibling(finishedWork);
+          insertOrAppendPlacementNode(finishedWork, before, parent$jscomp$0);
+          break;
+        case 3:
+        case 4:
+          var parent$81 = JSCompiler_inline_result.stateNode.containerInfo,
+            before$82 = getHostSibling(finishedWork);
+          insertOrAppendPlacementNodeIntoContainer(
+            finishedWork,
+            before$82,
+            parent$81
+          );
+          break;
+        default:
+          throw Error(
+            "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
+          );
+      }
+    } catch (error) {
+      captureCommitPhaseError(finishedWork, finishedWork.return, error);
     }
+    finishedWork.flags &= -3;
   }
-  return !0;
+  flags & 4096 && (finishedWork.flags &= -4097);
 }
-function markRootSuspended(root, suspendedLanes, spawnedLane) {
-  suspendedLanes &= ~workInProgressRootPingedLanes;
-  suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
-  root.suspendedLanes |= suspendedLanes;
-  root.pingedLanes &= ~suspendedLanes;
-  for (
-    var expirationTimes = root.expirationTimes, lanes = suspendedLanes;
-    0 < lanes;
-
-  ) {
-    var index$6 = 31 - clz32(lanes),
-      lane = 1 << index$6;
-    expirationTimes[index$6] = -1;
-    lanes &= ~lane;
-  }
-  0 !== spawnedLane &&
-    markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
+function recursivelyTraverseLayoutEffects(root, parentFiber) {
+  if (parentFiber.subtreeFlags & 8772)
+    for (parentFiber = parentFiber.child; null !== parentFiber; )
+      commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),
+        (parentFiber = parentFiber.sibling);
 }
-function resetWorkInProgressStack() {
-  if (null !== workInProgress) {
-    if (0 === workInProgressSuspendedReason)
-      var interruptedWork = workInProgress.return;
-    else
-      (interruptedWork = workInProgress),
-        resetContextDependencies(),
-        resetHooksOnUnwind(interruptedWork),
-        (thenableState$1 = null),
-        (thenableIndexCounter$1 = 0),
-        (interruptedWork = workInProgress);
-    for (; null !== interruptedWork; )
-      unwindInterruptedWork(interruptedWork.alternate, interruptedWork),
-        (interruptedWork = interruptedWork.return);
-    workInProgress = null;
+function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
+  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+    var finishedWork = parentFiber;
+    switch (finishedWork.tag) {
+      case 0:
+      case 11:
+      case 14:
+      case 15:
+        commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
+        recursivelyTraverseDisappearLayoutEffects(finishedWork);
+        break;
+      case 1:
+        safelyDetachRef(finishedWork, finishedWork.return);
+        var instance = finishedWork.stateNode;
+        if ("function" === typeof instance.componentWillUnmount) {
+          var current = finishedWork,
+            nearestMountedAncestor = finishedWork.return;
+          try {
+            var current$jscomp$0 = current;
+            instance.props = current$jscomp$0.memoizedProps;
+            instance.state = current$jscomp$0.memoizedState;
+            instance.componentWillUnmount();
+          } catch (error) {
+            captureCommitPhaseError(current, nearestMountedAncestor, error);
+          }
+        }
+        recursivelyTraverseDisappearLayoutEffects(finishedWork);
+        break;
+      case 26:
+      case 27:
+      case 5:
+        safelyDetachRef(finishedWork, finishedWork.return);
+        recursivelyTraverseDisappearLayoutEffects(finishedWork);
+        break;
+      case 22:
+        safelyDetachRef(finishedWork, finishedWork.return);
+        null === finishedWork.memoizedState &&
+          recursivelyTraverseDisappearLayoutEffects(finishedWork);
+        break;
+      default:
+        recursivelyTraverseDisappearLayoutEffects(finishedWork);
+    }
+    parentFiber = parentFiber.sibling;
   }
 }
-function prepareFreshStack(root, lanes) {
-  root.finishedWork = null;
-  root.finishedLanes = 0;
-  var timeoutHandle = root.timeoutHandle;
-  -1 !== timeoutHandle &&
-    ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle));
-  timeoutHandle = root.cancelPendingCommit;
-  null !== timeoutHandle &&
-    ((root.cancelPendingCommit = null), timeoutHandle());
-  resetWorkInProgressStack();
-  workInProgressRoot = root;
-  workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
-  workInProgressRootRenderLanes = lanes;
-  workInProgressSuspendedReason = 0;
-  workInProgressThrownValue = null;
-  workInProgressRootDidAttachPingListener = !1;
-  workInProgressRootExitStatus = 0;
-  workInProgressRootFatalError = null;
-  workInProgressDeferredLane =
-    workInProgressRootPingedLanes =
-    workInProgressRootInterleavedUpdatedLanes =
-    workInProgressRootSkippedLanes =
-      0;
-  workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors =
-    null;
-  0 !== (lanes & 8) && (lanes |= lanes & 32);
-  var allEntangledLanes = root.entangledLanes;
-  if (0 !== allEntangledLanes)
-    for (
-      root = root.entanglements, allEntangledLanes &= lanes;
-      0 < allEntangledLanes;
-
-    ) {
-      var index$4 = 31 - clz32(allEntangledLanes),
-        lane = 1 << index$4;
-      lanes |= root[index$4];
-      allEntangledLanes &= ~lane;
+function recursivelyTraverseReappearLayoutEffects(
+  finishedRoot$jscomp$0,
+  parentFiber,
+  includeWorkInProgressEffects
+) {
+  includeWorkInProgressEffects =
+    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
+  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+    var finishedRoot = finishedRoot$jscomp$0,
+      finishedWork = parentFiber,
+      flags = finishedWork.flags;
+    switch (finishedWork.tag) {
+      case 0:
+      case 11:
+      case 15:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+        commitHookLayoutEffects(finishedWork, 4);
+        break;
+      case 1:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+        var instance = finishedWork.stateNode;
+        if ("function" === typeof instance.componentDidMount)
+          try {
+            instance.componentDidMount();
+          } catch (error) {
+            captureCommitPhaseError(finishedWork, finishedWork.return, error);
+          }
+        finishedRoot = finishedWork.updateQueue;
+        if (null !== finishedRoot) {
+          var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
+          if (null !== hiddenCallbacks)
+            for (
+              finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0;
+              finishedRoot < hiddenCallbacks.length;
+              finishedRoot++
+            )
+              callCallback(hiddenCallbacks[finishedRoot], instance);
+        }
+        includeWorkInProgressEffects &&
+          flags & 64 &&
+          commitClassCallbacks(finishedWork);
+        safelyAttachRef(finishedWork, finishedWork.return);
+        break;
+      case 26:
+      case 27:
+      case 5:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+        safelyAttachRef(finishedWork, finishedWork.return);
+        break;
+      case 12:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+        break;
+      case 13:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+        break;
+      case 22:
+        null === finishedWork.memoizedState &&
+          recursivelyTraverseReappearLayoutEffects(
+            finishedRoot,
+            finishedWork,
+            includeWorkInProgressEffects
+          );
+        safelyAttachRef(finishedWork, finishedWork.return);
+        break;
+      default:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
     }
-  entangledRenderLanes = lanes;
-  finishQueueingConcurrentUpdates();
-  return timeoutHandle;
-}
-function handleThrow(root, thrownValue) {
-  currentlyRenderingFiber$1 = null;
-  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
-  ReactCurrentOwner.current = null;
-  thrownValue === SuspenseException
-    ? ((thrownValue = getSuspendedThenable()),
-      (root = suspenseHandlerStackCursor.current),
-      (workInProgressSuspendedReason =
-        (null !== root &&
-          ((workInProgressRootRenderLanes & 4194176) ===
-          workInProgressRootRenderLanes
-            ? null !== shellBoundary
-            : ((workInProgressRootRenderLanes & 62914560) !==
-                workInProgressRootRenderLanes &&
-                0 === (workInProgressRootRenderLanes & 536870912)) ||
-              root !== shellBoundary)) ||
-        0 !== (workInProgressRootSkippedLanes & 134217727) ||
-        0 !== (workInProgressRootInterleavedUpdatedLanes & 134217727)
-          ? 3
-          : 2))
-    : thrownValue === SuspenseyCommitException
-    ? ((thrownValue = getSuspendedThenable()),
-      (workInProgressSuspendedReason = 4))
-    : (workInProgressSuspendedReason =
-        thrownValue === SelectiveHydrationException
-          ? 8
-          : null !== thrownValue &&
-            "object" === typeof thrownValue &&
-            "function" === typeof thrownValue.then
-          ? 6
-          : 1);
-  workInProgressThrownValue = thrownValue;
-  null === workInProgress &&
-    ((workInProgressRootExitStatus = 1),
-    (workInProgressRootFatalError = thrownValue));
+    parentFiber = parentFiber.sibling;
+  }
 }
-function pushDispatcher() {
-  var prevDispatcher = ReactCurrentDispatcher.current;
-  ReactCurrentDispatcher.current = ContextOnlyDispatcher;
-  return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
+function commitHookPassiveMountEffects(finishedWork, hookFlags) {
+  try {
+    commitHookEffectListMount(hookFlags, finishedWork);
+  } catch (error) {
+    captureCommitPhaseError(finishedWork, finishedWork.return, error);
+  }
 }
-function renderDidSuspendDelayIfPossible() {
-  workInProgressRootExitStatus = 4;
-  (0 === (workInProgressRootSkippedLanes & 134217727) &&
-    0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||
-    null === workInProgressRoot ||
-    markRootSuspended(
-      workInProgressRoot,
-      workInProgressRootRenderLanes,
-      workInProgressDeferredLane
-    );
+function recursivelyTraversePassiveMountEffects(root, parentFiber) {
+  if (parentFiber.subtreeFlags & 10256)
+    for (parentFiber = parentFiber.child; null !== parentFiber; )
+      commitPassiveMountOnFiber(root, parentFiber),
+        (parentFiber = parentFiber.sibling);
 }
-function renderRootSync(root, lanes) {
-  var prevExecutionContext = executionContext;
-  executionContext |= 2;
-  var prevDispatcher = pushDispatcher();
-  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes)
-    (workInProgressTransitions = null), prepareFreshStack(root, lanes);
-  lanes = !1;
-  a: do
-    try {
-      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
-        var unitOfWork = workInProgress,
-          thrownValue = workInProgressThrownValue;
-        switch (workInProgressSuspendedReason) {
-          case 8:
-            resetWorkInProgressStack();
-            workInProgressRootExitStatus = 6;
-            break a;
-          case 3:
-          case 2:
-            lanes ||
-              null !== suspenseHandlerStackCursor.current ||
-              (lanes = !0);
-          default:
-            (workInProgressSuspendedReason = 0),
-              (workInProgressThrownValue = null),
-              throwAndUnwindWorkLoop(root, unitOfWork, thrownValue);
-        }
-      }
-      workLoopSync();
+function commitPassiveMountOnFiber(finishedRoot, finishedWork) {
+  var flags = finishedWork.flags;
+  switch (finishedWork.tag) {
+    case 0:
+    case 11:
+    case 15:
+      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
+      flags & 2048 && commitHookPassiveMountEffects(finishedWork, 9);
       break;
-    } catch (thrownValue$95) {
-      handleThrow(root, thrownValue$95);
-    }
-  while (1);
-  lanes && root.shellSuspendCounter++;
-  resetContextDependencies();
-  executionContext = prevExecutionContext;
-  ReactCurrentDispatcher.current = prevDispatcher;
-  if (null !== workInProgress)
-    throw Error(
-      "Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue."
-    );
-  workInProgressRoot = null;
-  workInProgressRootRenderLanes = 0;
-  finishQueueingConcurrentUpdates();
-  return workInProgressRootExitStatus;
-}
-function workLoopSync() {
-  for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
-}
-function renderRootConcurrent(root, lanes) {
-  var prevExecutionContext = executionContext;
-  executionContext |= 2;
-  var prevDispatcher = pushDispatcher();
-  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes)
-    (workInProgressTransitions = null),
-      (workInProgressRootRenderTargetTime = now() + 500),
-      prepareFreshStack(root, lanes);
-  a: do
-    try {
-      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
-        lanes = workInProgress;
-        var thrownValue = workInProgressThrownValue;
-        b: switch (workInProgressSuspendedReason) {
-          case 1:
-            workInProgressSuspendedReason = 0;
-            workInProgressThrownValue = null;
-            throwAndUnwindWorkLoop(root, lanes, thrownValue);
-            break;
-          case 2:
-            if (isThenableResolved(thrownValue)) {
-              workInProgressSuspendedReason = 0;
-              workInProgressThrownValue = null;
-              replaySuspendedUnitOfWork(lanes);
-              break;
-            }
-            lanes = function () {
-              2 === workInProgressSuspendedReason &&
-                workInProgressRoot === root &&
-                (workInProgressSuspendedReason = 7);
-              ensureRootIsScheduled(root);
-            };
-            thrownValue.then(lanes, lanes);
-            break a;
-          case 3:
-            workInProgressSuspendedReason = 7;
-            break a;
-          case 4:
-            workInProgressSuspendedReason = 5;
-            break a;
-          case 7:
-            isThenableResolved(thrownValue)
-              ? ((workInProgressSuspendedReason = 0),
-                (workInProgressThrownValue = null),
-                replaySuspendedUnitOfWork(lanes))
-              : ((workInProgressSuspendedReason = 0),
-                (workInProgressThrownValue = null),
-                throwAndUnwindWorkLoop(root, lanes, thrownValue));
-            break;
-          case 5:
-            switch (workInProgress.tag) {
-              case 5:
-              case 26:
-              case 27:
-                lanes = workInProgress;
-                workInProgressSuspendedReason = 0;
-                workInProgressThrownValue = null;
-                var sibling = lanes.sibling;
-                if (null !== sibling) workInProgress = sibling;
-                else {
-                  var returnFiber = lanes.return;
-                  null !== returnFiber
-                    ? ((workInProgress = returnFiber),
-                      completeUnitOfWork(returnFiber))
-                    : (workInProgress = null);
-                }
-                break b;
-            }
-            workInProgressSuspendedReason = 0;
-            workInProgressThrownValue = null;
-            throwAndUnwindWorkLoop(root, lanes, thrownValue);
-            break;
-          case 6:
-            workInProgressSuspendedReason = 0;
-            workInProgressThrownValue = null;
-            throwAndUnwindWorkLoop(root, lanes, thrownValue);
-            break;
-          case 8:
-            resetWorkInProgressStack();
-            workInProgressRootExitStatus = 6;
-            break a;
-          default:
-            throw Error("Unexpected SuspendedReason. This is a bug in React.");
-        }
+    case 3:
+      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
+      break;
+    case 23:
+      break;
+    case 22:
+      flags = finishedWork.stateNode;
+      null !== finishedWork.memoizedState
+        ? flags._visibility & 4
+          ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork)
+          : finishedWork.mode & 1 ||
+            ((flags._visibility |= 4),
+            recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork))
+        : flags._visibility & 4
+        ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork)
+        : ((flags._visibility |= 4),
+          recursivelyTraverseReconnectPassiveEffects(
+            finishedRoot,
+            finishedWork
+          ));
+      break;
+    case 24:
+      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
+      break;
+    default:
+      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
+  }
+}
+function recursivelyTraverseReconnectPassiveEffects(
+  finishedRoot$jscomp$0,
+  parentFiber
+) {
+  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+    var finishedRoot = finishedRoot$jscomp$0,
+      finishedWork = parentFiber;
+    switch (finishedWork.tag) {
+      case 0:
+      case 11:
+      case 15:
+        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork);
+        commitHookPassiveMountEffects(finishedWork, 8);
+        break;
+      case 23:
+        break;
+      case 22:
+        var instance = finishedWork.stateNode;
+        null !== finishedWork.memoizedState
+          ? instance._visibility & 4
+            ? recursivelyTraverseReconnectPassiveEffects(
+                finishedRoot,
+                finishedWork
+              )
+            : finishedWork.mode & 1 ||
+              ((instance._visibility |= 4),
+              recursivelyTraverseReconnectPassiveEffects(
+                finishedRoot,
+                finishedWork
+              ))
+          : ((instance._visibility |= 4),
+            recursivelyTraverseReconnectPassiveEffects(
+              finishedRoot,
+              finishedWork
+            ));
+        break;
+      case 24:
+        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork);
+        break;
+      default:
+        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork);
+    }
+    parentFiber = parentFiber.sibling;
+  }
+}
+var suspenseyCommitFlag = 8192;
+function recursivelyAccumulateSuspenseyCommit(parentFiber) {
+  if (parentFiber.subtreeFlags & suspenseyCommitFlag)
+    for (parentFiber = parentFiber.child; null !== parentFiber; )
+      accumulateSuspenseyCommitOnFiber(parentFiber),
+        (parentFiber = parentFiber.sibling);
+}
+function accumulateSuspenseyCommitOnFiber(fiber) {
+  switch (fiber.tag) {
+    case 26:
+      recursivelyAccumulateSuspenseyCommit(fiber);
+      if (fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState)
+        throw Error(
+          "The current renderer does not support Resources. This error is likely caused by a bug in React. Please file an issue."
+        );
+      break;
+    case 5:
+      recursivelyAccumulateSuspenseyCommit(fiber);
+      break;
+    case 3:
+    case 4:
+      recursivelyAccumulateSuspenseyCommit(fiber);
+      break;
+    case 22:
+      if (null === fiber.memoizedState) {
+        var current = fiber.alternate;
+        null !== current && null !== current.memoizedState
+          ? ((current = suspenseyCommitFlag),
+            (suspenseyCommitFlag = 16777216),
+            recursivelyAccumulateSuspenseyCommit(fiber),
+            (suspenseyCommitFlag = current))
+          : recursivelyAccumulateSuspenseyCommit(fiber);
       }
-      workLoopConcurrent();
       break;
-    } catch (thrownValue$97) {
-      handleThrow(root, thrownValue$97);
-    }
-  while (1);
-  resetContextDependencies();
-  ReactCurrentDispatcher.current = prevDispatcher;
-  executionContext = prevExecutionContext;
-  if (null !== workInProgress) return 0;
-  workInProgressRoot = null;
-  workInProgressRootRenderLanes = 0;
-  finishQueueingConcurrentUpdates();
-  return workInProgressRootExitStatus;
+    default:
+      recursivelyAccumulateSuspenseyCommit(fiber);
+  }
 }
-function workLoopConcurrent() {
-  for (; null !== workInProgress && !shouldYield(); )
-    performUnitOfWork(workInProgress);
+function detachAlternateSiblings(parentFiber) {
+  var previousFiber = parentFiber.alternate;
+  if (
+    null !== previousFiber &&
+    ((parentFiber = previousFiber.child), null !== parentFiber)
+  ) {
+    previousFiber.child = null;
+    do
+      (previousFiber = parentFiber.sibling),
+        (parentFiber.sibling = null),
+        (parentFiber = previousFiber);
+    while (null !== parentFiber);
+  }
 }
-function performUnitOfWork(unitOfWork) {
-  var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
-  unitOfWork.memoizedProps = unitOfWork.pendingProps;
-  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
-  ReactCurrentOwner.current = null;
+function recursivelyTraversePassiveUnmountEffects(parentFiber) {
+  var deletions = parentFiber.deletions;
+  if (0 !== (parentFiber.flags & 16)) {
+    if (null !== deletions)
+      for (var i = 0; i < deletions.length; i++) {
+        var childToDelete = deletions[i];
+        nextEffect = childToDelete;
+        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
+          childToDelete,
+          parentFiber
+        );
+      }
+    detachAlternateSiblings(parentFiber);
+  }
+  if (parentFiber.subtreeFlags & 10256)
+    for (parentFiber = parentFiber.child; null !== parentFiber; )
+      commitPassiveUnmountOnFiber(parentFiber),
+        (parentFiber = parentFiber.sibling);
 }
-function replaySuspendedUnitOfWork(unitOfWork) {
-  var current = unitOfWork.alternate;
-  switch (unitOfWork.tag) {
-    case 2:
-      unitOfWork.tag = 0;
-    case 15:
+function commitPassiveUnmountOnFiber(finishedWork) {
+  switch (finishedWork.tag) {
     case 0:
-      var Component = unitOfWork.type,
-        unresolvedProps = unitOfWork.pendingProps;
-      unresolvedProps =
-        unitOfWork.elementType === Component
-          ? unresolvedProps
-          : resolveDefaultProps(Component, unresolvedProps);
-      var context = isContextProvider(Component)
-        ? previousContext
-        : contextStackCursor$1.current;
-      context = getMaskedContext(unitOfWork, context);
-      current = replayFunctionComponent(
-        current,
-        unitOfWork,
-        unresolvedProps,
-        Component,
-        context,
-        workInProgressRootRenderLanes
-      );
-      break;
     case 11:
-      Component = unitOfWork.type.render;
-      unresolvedProps = unitOfWork.pendingProps;
-      unresolvedProps =
-        unitOfWork.elementType === Component
-          ? unresolvedProps
-          : resolveDefaultProps(Component, unresolvedProps);
-      current = replayFunctionComponent(
-        current,
-        unitOfWork,
-        unresolvedProps,
-        Component,
-        unitOfWork.ref,
-        workInProgressRootRenderLanes
-      );
+    case 15:
+      recursivelyTraversePassiveUnmountEffects(finishedWork);
+      finishedWork.flags & 2048 &&
+        commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
+      break;
+    case 22:
+      var instance = finishedWork.stateNode;
+      null !== finishedWork.memoizedState &&
+      instance._visibility & 4 &&
+      (null === finishedWork.return || 13 !== finishedWork.return.tag)
+        ? ((instance._visibility &= -5),
+          recursivelyTraverseDisconnectPassiveEffects(finishedWork))
+        : recursivelyTraversePassiveUnmountEffects(finishedWork);
       break;
-    case 5:
-      resetHooksOnUnwind(unitOfWork);
     default:
-      unwindInterruptedWork(current, unitOfWork),
-        (unitOfWork = workInProgress =
-          resetWorkInProgress(unitOfWork, entangledRenderLanes)),
-        (current = beginWork(current, unitOfWork, entangledRenderLanes));
+      recursivelyTraversePassiveUnmountEffects(finishedWork);
   }
-  unitOfWork.memoizedProps = unitOfWork.pendingProps;
-  null === current
-    ? completeUnitOfWork(unitOfWork)
-    : (workInProgress = current);
-  ReactCurrentOwner.current = null;
 }
-function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue) {
-  resetContextDependencies();
-  resetHooksOnUnwind(unitOfWork);
-  thenableState$1 = null;
-  thenableIndexCounter$1 = 0;
-  var returnFiber = unitOfWork.return;
-  try {
-    if (
-      throwException(
-        root,
-        returnFiber,
-        unitOfWork,
-        thrownValue,
-        workInProgressRootRenderLanes
-      )
-    ) {
-      workInProgressRootExitStatus = 1;
-      workInProgressRootFatalError = thrownValue;
-      workInProgress = null;
-      return;
+function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
+  var deletions = parentFiber.deletions;
+  if (0 !== (parentFiber.flags & 16)) {
+    if (null !== deletions)
+      for (var i = 0; i < deletions.length; i++) {
+        var childToDelete = deletions[i];
+        nextEffect = childToDelete;
+        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
+          childToDelete,
+          parentFiber
+        );
+      }
+    detachAlternateSiblings(parentFiber);
+  }
+  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+    deletions = parentFiber;
+    switch (deletions.tag) {
+      case 0:
+      case 11:
+      case 15:
+        commitHookEffectListUnmount(8, deletions, deletions.return);
+        recursivelyTraverseDisconnectPassiveEffects(deletions);
+        break;
+      case 22:
+        i = deletions.stateNode;
+        i._visibility & 4 &&
+          ((i._visibility &= -5),
+          recursivelyTraverseDisconnectPassiveEffects(deletions));
+        break;
+      default:
+        recursivelyTraverseDisconnectPassiveEffects(deletions);
+    }
+    parentFiber = parentFiber.sibling;
+  }
+}
+function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
+  deletedSubtreeRoot,
+  nearestMountedAncestor
+) {
+  for (; null !== nextEffect; ) {
+    var fiber = nextEffect;
+    switch (fiber.tag) {
+      case 0:
+      case 11:
+      case 15:
+        commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
     }
-  } catch (error) {
-    if (null !== returnFiber) throw ((workInProgress = returnFiber), error);
-    workInProgressRootExitStatus = 1;
-    workInProgressRootFatalError = thrownValue;
-    workInProgress = null;
-    return;
-  }
-  if (unitOfWork.flags & 32768)
-    a: {
-      root = unitOfWork;
-      do {
-        unitOfWork = unwindWork(root.alternate, root);
-        if (null !== unitOfWork) {
-          unitOfWork.flags &= 32767;
-          workInProgress = unitOfWork;
+    var child = fiber.child;
+    if (null !== child) (child.return = fiber), (nextEffect = child);
+    else
+      a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
+        child = nextEffect;
+        var sibling = child.sibling,
+          returnFiber = child.return;
+        detachFiberAfterEffects(child);
+        if (child === fiber) {
+          nextEffect = null;
           break a;
         }
-        root = root.return;
-        null !== root &&
-          ((root.flags |= 32768),
-          (root.subtreeFlags = 0),
-          (root.deletions = null));
-        workInProgress = root;
-      } while (null !== root);
-      workInProgressRootExitStatus = 6;
-      workInProgress = null;
-    }
-  else completeUnitOfWork(unitOfWork);
+        if (null !== sibling) {
+          sibling.return = returnFiber;
+          nextEffect = sibling;
+          break a;
+        }
+        nextEffect = returnFiber;
+      }
+  }
 }
-function completeUnitOfWork(unitOfWork) {
-  var completedWork = unitOfWork;
-  do {
-    unitOfWork = completedWork.return;
-    var next = completeWork(
-      completedWork.alternate,
-      completedWork,
-      entangledRenderLanes
-    );
-    if (null !== next) {
-      workInProgress = next;
-      return;
-    }
-    completedWork = completedWork.sibling;
-    if (null !== completedWork) {
-      workInProgress = completedWork;
-      return;
+var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
+  ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher,
+  ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner,
+  ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig,
+  executionContext = 0,
+  workInProgressRoot = null,
+  workInProgress = null,
+  workInProgressRootRenderLanes = 0,
+  workInProgressSuspendedReason = 0,
+  workInProgressThrownValue = null,
+  workInProgressRootDidAttachPingListener = !1,
+  entangledRenderLanes = 0,
+  workInProgressRootExitStatus = 0,
+  workInProgressRootFatalError = null,
+  workInProgressRootSkippedLanes = 0,
+  workInProgressRootInterleavedUpdatedLanes = 0,
+  workInProgressRootPingedLanes = 0,
+  workInProgressDeferredLane = 0,
+  workInProgressRootConcurrentErrors = null,
+  workInProgressRootRecoverableErrors = null,
+  workInProgressRootDidIncludeRecursiveRenderUpdate = !1,
+  globalMostRecentFallbackTime = 0,
+  workInProgressRootRenderTargetTime = Infinity,
+  workInProgressTransitions = null,
+  hasUncaughtError = !1,
+  firstUncaughtError = null,
+  legacyErrorBoundariesThatAlreadyFailed = null,
+  rootDoesHavePassiveEffects = !1,
+  rootWithPendingPassiveEffects = null,
+  pendingPassiveEffectsLanes = 0,
+  nestedUpdateCount = 0,
+  rootWithNestedUpdates = null;
+function requestUpdateLane(fiber) {
+  if (0 === (fiber.mode & 1)) return 2;
+  if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)
+    return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
+  fiber = ReactCurrentBatchConfig$1.transition;
+  if (null !== fiber) {
+    if (!fiber._callbacks) {
+      fiber._callbacks = new Set();
     }
-    workInProgress = completedWork = unitOfWork;
-  } while (null !== completedWork);
-  0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
+    fiber._callbacks.add(handleAsyncAction);
+  }
+  if (null !== fiber)
+    return (
+      0 === currentEventTransitionLane &&
+        (currentEventTransitionLane = claimNextTransitionLane()),
+      currentEventTransitionLane
+    );
+  fiber = currentUpdatePriority;
+  return 0 !== fiber ? fiber : 32;
+}
+function requestDeferredLane() {
+  0 === workInProgressDeferredLane &&
+    (workInProgressDeferredLane =
+      0 !== (workInProgressRootRenderLanes & 536870912)
+        ? 536870912
+        : claimNextTransitionLane());
+  var suspenseHandler = suspenseHandlerStackCursor.current;
+  null !== suspenseHandler && (suspenseHandler.flags |= 32);
+  return workInProgressDeferredLane;
+}
+function scheduleUpdateOnFiber(root, fiber, lane) {
+  if (
+    (root === workInProgressRoot && 2 === workInProgressSuspendedReason) ||
+    null !== root.cancelPendingCommit
+  )
+    prepareFreshStack(root, 0),
+      markRootSuspended(
+        root,
+        workInProgressRootRenderLanes,
+        workInProgressDeferredLane
+      );
+  markRootUpdated$1(root, lane);
+  if (0 === (executionContext & 2) || root !== workInProgressRoot)
+    root === workInProgressRoot &&
+      (0 === (executionContext & 2) &&
+        (workInProgressRootInterleavedUpdatedLanes |= lane),
+      4 === workInProgressRootExitStatus &&
+        markRootSuspended(
+          root,
+          workInProgressRootRenderLanes,
+          workInProgressDeferredLane
+        )),
+      ensureRootIsScheduled(root),
+      2 === lane &&
+        0 === executionContext &&
+        0 === (fiber.mode & 1) &&
+        ((workInProgressRootRenderTargetTime = now() + 500),
+        flushSyncWorkAcrossRoots_impl(!0));
+}
+function performConcurrentWorkOnRoot(root, didTimeout) {
+  if (0 !== (executionContext & 6))
+    throw Error("Should not already be working.");
+  var originalCallbackNode = root.callbackNode;
+  if (flushPassiveEffects() && root.callbackNode !== originalCallbackNode)
+    return null;
+  var lanes = getNextLanes(
+    root,
+    root === workInProgressRoot ? workInProgressRootRenderLanes : 0
+  );
+  if (0 === lanes) return null;
+  var exitStatus = (didTimeout =
+    0 === (lanes & 60) && 0 === (lanes & root.expiredLanes) && !didTimeout)
+    ? renderRootConcurrent(root, lanes)
+    : renderRootSync(root, lanes);
+  if (0 !== exitStatus) {
+    var renderWasConcurrent = didTimeout;
+    do {
+      if (6 === exitStatus) markRootSuspended(root, lanes, 0);
+      else {
+        didTimeout = root.current.alternate;
+        if (
+          renderWasConcurrent &&
+          !isRenderConsistentWithExternalStores(didTimeout)
+        ) {
+          exitStatus = renderRootSync(root, lanes);
+          renderWasConcurrent = !1;
+          continue;
+        }
+        if (2 === exitStatus) {
+          renderWasConcurrent = lanes;
+          var errorRetryLanes = getLanesToRetrySynchronouslyOnError(
+            root,
+            renderWasConcurrent
+          );
+          0 !== errorRetryLanes &&
+            ((lanes = errorRetryLanes),
+            (exitStatus = recoverFromConcurrentError(
+              root,
+              renderWasConcurrent,
+              errorRetryLanes
+            )));
+        }
+        if (1 === exitStatus)
+          throw (
+            ((originalCallbackNode = workInProgressRootFatalError),
+            prepareFreshStack(root, 0),
+            markRootSuspended(root, lanes, 0),
+            ensureRootIsScheduled(root),
+            originalCallbackNode)
+          );
+        root.finishedWork = didTimeout;
+        root.finishedLanes = lanes;
+        a: {
+          renderWasConcurrent = root;
+          switch (exitStatus) {
+            case 0:
+            case 1:
+              throw Error("Root did not complete. This is a bug in React.");
+            case 4:
+              if ((lanes & 4194176) === lanes) {
+                markRootSuspended(
+                  renderWasConcurrent,
+                  lanes,
+                  workInProgressDeferredLane
+                );
+                break a;
+              }
+              break;
+            case 2:
+            case 3:
+            case 5:
+              break;
+            default:
+              throw Error("Unknown root exit status.");
+          }
+          if (
+            (lanes & 62914560) === lanes &&
+            3 === exitStatus &&
+            ((exitStatus = globalMostRecentFallbackTime + 300 - now()),
+            10 < exitStatus)
+          ) {
+            markRootSuspended(
+              renderWasConcurrent,
+              lanes,
+              workInProgressDeferredLane
+            );
+            if (0 !== getNextLanes(renderWasConcurrent, 0)) break a;
+            renderWasConcurrent.timeoutHandle = scheduleTimeout(
+              commitRootWhenReady.bind(
+                null,
+                renderWasConcurrent,
+                didTimeout,
+                workInProgressRootRecoverableErrors,
+                workInProgressTransitions,
+                workInProgressRootDidIncludeRecursiveRenderUpdate,
+                lanes,
+                workInProgressDeferredLane
+              ),
+              exitStatus
+            );
+            break a;
+          }
+          commitRootWhenReady(
+            renderWasConcurrent,
+            didTimeout,
+            workInProgressRootRecoverableErrors,
+            workInProgressTransitions,
+            workInProgressRootDidIncludeRecursiveRenderUpdate,
+            lanes,
+            workInProgressDeferredLane
+          );
+        }
+      }
+      break;
+    } while (1);
+  }
+  ensureRootIsScheduled(root);
+  scheduleTaskForRootDuringMicrotask(root, now());
+  root =
+    root.callbackNode === originalCallbackNode
+      ? performConcurrentWorkOnRoot.bind(null, root)
+      : null;
+  return root;
 }
-function commitRoot(root, recoverableErrors, transitions, spawnedLane) {
-  var previousUpdateLanePriority = currentUpdatePriority,
-    prevTransition = ReactCurrentBatchConfig.transition;
-  try {
-    (ReactCurrentBatchConfig.transition = null),
-      (currentUpdatePriority = 2),
-      commitRootImpl(
-        root,
-        recoverableErrors,
-        transitions,
-        previousUpdateLanePriority,
-        spawnedLane
+function recoverFromConcurrentError(
+  root,
+  originallyAttemptedLanes,
+  errorRetryLanes
+) {
+  var errorsFromFirstAttempt = workInProgressRootConcurrentErrors,
+    JSCompiler_inline_result;
+  (JSCompiler_inline_result = root.current.memoizedState.isDehydrated) &&
+    (prepareFreshStack(root, errorRetryLanes).flags |= 256);
+  errorRetryLanes = renderRootSync(root, errorRetryLanes);
+  if (2 !== errorRetryLanes) {
+    if (workInProgressRootDidAttachPingListener && !JSCompiler_inline_result)
+      return (
+        (root.errorRecoveryDisabledLanes |= originallyAttemptedLanes),
+        (workInProgressRootInterleavedUpdatedLanes |= originallyAttemptedLanes),
+        4
       );
-  } finally {
-    (ReactCurrentBatchConfig.transition = prevTransition),
-      (currentUpdatePriority = previousUpdateLanePriority);
+    root = workInProgressRootRecoverableErrors;
+    workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
+    null !== root && queueRecoverableErrors(root);
   }
-  return null;
+  return errorRetryLanes;
 }
-function commitRootImpl(
+function queueRecoverableErrors(errors) {
+  null === workInProgressRootRecoverableErrors
+    ? (workInProgressRootRecoverableErrors = errors)
+    : workInProgressRootRecoverableErrors.push.apply(
+        workInProgressRootRecoverableErrors,
+        errors
+      );
+}
+function commitRootWhenReady(
   root,
+  finishedWork,
   recoverableErrors,
   transitions,
-  renderPriorityLevel,
+  didIncludeRenderPhaseUpdate,
+  lanes,
   spawnedLane
 ) {
-  do flushPassiveEffects();
-  while (null !== rootWithPendingPassiveEffects);
-  if (0 !== (executionContext & 6))
-    throw Error("Should not already be working.");
-  var finishedWork = root.finishedWork;
-  transitions = root.finishedLanes;
-  if (null === finishedWork) return null;
-  root.finishedWork = null;
-  root.finishedLanes = 0;
-  if (finishedWork === root.current)
-    throw Error(
-      "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
-    );
-  root.callbackNode = null;
-  root.callbackPriority = 0;
-  root.cancelPendingCommit = null;
-  var remainingLanes = finishedWork.lanes | finishedWork.childLanes;
-  remainingLanes |= concurrentlyUpdatedLanes;
-  markRootFinished(root, remainingLanes, spawnedLane);
-  root === workInProgressRoot &&
-    ((workInProgress = workInProgressRoot = null),
-    (workInProgressRootRenderLanes = 0));
-  (0 === (finishedWork.subtreeFlags & 10256) &&
-    0 === (finishedWork.flags & 10256)) ||
-    rootDoesHavePassiveEffects ||
-    ((rootDoesHavePassiveEffects = !0),
-    scheduleCallback(NormalPriority, function () {
-      flushPassiveEffects();
-      return null;
-    }));
-  spawnedLane = 0 !== (finishedWork.flags & 15990);
-  if (0 !== (finishedWork.subtreeFlags & 15990) || spawnedLane) {
-    spawnedLane = ReactCurrentBatchConfig.transition;
-    ReactCurrentBatchConfig.transition = null;
-    remainingLanes = currentUpdatePriority;
-    currentUpdatePriority = 2;
-    var prevExecutionContext = executionContext;
-    executionContext |= 4;
-    ReactCurrentOwner.current = null;
-    commitBeforeMutationEffects(root, finishedWork);
-    commitMutationEffectsOnFiber(finishedWork, root);
-    root.current = finishedWork;
-    commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);
-    requestPaint();
-    executionContext = prevExecutionContext;
-    currentUpdatePriority = remainingLanes;
-    ReactCurrentBatchConfig.transition = spawnedLane;
-  } else root.current = finishedWork;
-  rootDoesHavePassiveEffects &&
-    ((rootDoesHavePassiveEffects = !1),
-    (rootWithPendingPassiveEffects = root),
-    (pendingPassiveEffectsLanes = transitions));
-  remainingLanes = root.pendingLanes;
-  0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
-  onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
-  ensureRootIsScheduled(root);
-  if (null !== recoverableErrors)
-    for (
-      renderPriorityLevel = root.onRecoverableError, finishedWork = 0;
-      finishedWork < recoverableErrors.length;
-      finishedWork++
-    )
-      (spawnedLane = recoverableErrors[finishedWork]),
-        (remainingLanes = {
-          digest: spawnedLane.digest,
-          componentStack: spawnedLane.stack
-        }),
-        renderPriorityLevel(spawnedLane.value, remainingLanes);
-  if (hasUncaughtError)
-    throw (
-      ((hasUncaughtError = !1),
-      (root = firstUncaughtError),
-      (firstUncaughtError = null),
-      root)
-    );
-  0 !== (pendingPassiveEffectsLanes & 3) &&
-    0 !== root.tag &&
-    flushPassiveEffects();
-  remainingLanes = root.pendingLanes;
-  0 !== (transitions & 4194218) && 0 !== (remainingLanes & 42)
-    ? root === rootWithNestedUpdates
-      ? nestedUpdateCount++
-      : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root))
-    : (nestedUpdateCount = 0);
-  flushSyncWorkAcrossRoots_impl(!1);
-  return null;
+  0 === (lanes & 42) && accumulateSuspenseyCommitOnFiber(finishedWork);
+  commitRoot(
+    root,
+    recoverableErrors,
+    transitions,
+    didIncludeRenderPhaseUpdate,
+    spawnedLane
+  );
 }
-function flushPassiveEffects() {
-  if (null !== rootWithPendingPassiveEffects) {
-    var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes),
-      prevTransition = ReactCurrentBatchConfig.transition,
-      previousPriority = currentUpdatePriority;
-    try {
-      ReactCurrentBatchConfig.transition = null;
-      currentUpdatePriority = 32 > renderPriority ? 32 : renderPriority;
-      if (null === rootWithPendingPassiveEffects)
-        var JSCompiler_inline_result = !1;
-      else {
-        renderPriority = rootWithPendingPassiveEffects;
-        rootWithPendingPassiveEffects = null;
-        pendingPassiveEffectsLanes = 0;
-        if (0 !== (executionContext & 6))
-          throw Error("Cannot flush passive effects while already rendering.");
-        var prevExecutionContext = executionContext;
-        executionContext |= 4;
-        commitPassiveUnmountOnFiber(renderPriority.current);
-        commitPassiveMountOnFiber(renderPriority, renderPriority.current);
-        executionContext = prevExecutionContext;
-        flushSyncWorkAcrossRoots_impl(!1);
-        if (
-          injectedHook &&
-          "function" === typeof injectedHook.onPostCommitFiberRoot
-        )
+function isRenderConsistentWithExternalStores(finishedWork) {
+  for (var node = finishedWork; ; ) {
+    if (node.flags & 16384) {
+      var updateQueue = node.updateQueue;
+      if (
+        null !== updateQueue &&
+        ((updateQueue = updateQueue.stores), null !== updateQueue)
+      )
+        for (var i = 0; i < updateQueue.length; i++) {
+          var check = updateQueue[i],
+            getSnapshot = check.getSnapshot;
+          check = check.value;
           try {
-            injectedHook.onPostCommitFiberRoot(rendererID, renderPriority);
-          } catch (err) {}
-        JSCompiler_inline_result = !0;
+            if (!objectIs(getSnapshot(), check)) return !1;
+          } catch (error) {
+            return !1;
+          }
+        }
+    }
+    updateQueue = node.child;
+    if (node.subtreeFlags & 16384 && null !== updateQueue)
+      (updateQueue.return = node), (node = updateQueue);
+    else {
+      if (node === finishedWork) break;
+      for (; null === node.sibling; ) {
+        if (null === node.return || node.return === finishedWork) return !0;
+        node = node.return;
       }
-      return JSCompiler_inline_result;
-    } finally {
-      (currentUpdatePriority = previousPriority),
-        (ReactCurrentBatchConfig.transition = prevTransition);
+      node.sibling.return = node.return;
+      node = node.sibling;
     }
   }
-  return !1;
-}
-function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
-  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
-  sourceFiber = createRootErrorUpdate(rootFiber, sourceFiber, 2);
-  rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
-  null !== rootFiber &&
-    (markRootUpdated(rootFiber, 2), ensureRootIsScheduled(rootFiber));
+  return !0;
 }
-function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
-  if (3 === sourceFiber.tag)
-    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
-  else
-    for (; null !== nearestMountedAncestor; ) {
-      if (3 === nearestMountedAncestor.tag) {
-        captureCommitPhaseErrorOnRoot(
-          nearestMountedAncestor,
-          sourceFiber,
-          error
-        );
-        break;
-      } else if (1 === nearestMountedAncestor.tag) {
-        var instance = nearestMountedAncestor.stateNode;
-        if (
-          "function" ===
-            typeof nearestMountedAncestor.type.getDerivedStateFromError ||
-          ("function" === typeof instance.componentDidCatch &&
-            (null === legacyErrorBoundariesThatAlreadyFailed ||
-              !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
-        ) {
-          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
-          sourceFiber = createClassErrorUpdate(
-            nearestMountedAncestor,
-            sourceFiber,
-            2
-          );
-          nearestMountedAncestor = enqueueUpdate(
-            nearestMountedAncestor,
-            sourceFiber,
-            2
-          );
-          null !== nearestMountedAncestor &&
-            (markRootUpdated(nearestMountedAncestor, 2),
-            ensureRootIsScheduled(nearestMountedAncestor));
-          break;
-        }
-      }
-      nearestMountedAncestor = nearestMountedAncestor.return;
-    }
+function markRootSuspended(root, suspendedLanes, spawnedLane) {
+  suspendedLanes &= ~workInProgressRootPingedLanes;
+  suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
+  root.suspendedLanes |= suspendedLanes;
+  root.pingedLanes &= ~suspendedLanes;
+  for (
+    var expirationTimes = root.expirationTimes, lanes = suspendedLanes;
+    0 < lanes;
+
+  ) {
+    var index$6 = 31 - clz32(lanes),
+      lane = 1 << index$6;
+    expirationTimes[index$6] = -1;
+    lanes &= ~lane;
+  }
+  0 !== spawnedLane &&
+    markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
 }
-function attachPingListener(root, wakeable, lanes) {
-  var pingCache = root.pingCache;
-  if (null === pingCache) {
-    pingCache = root.pingCache = new PossiblyWeakMap();
-    var threadIDs = new Set();
-    pingCache.set(wakeable, threadIDs);
-  } else
-    (threadIDs = pingCache.get(wakeable)),
-      void 0 === threadIDs &&
-        ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs));
-  threadIDs.has(lanes) ||
-    ((workInProgressRootDidAttachPingListener = !0),
-    threadIDs.add(lanes),
-    (root = pingSuspendedRoot.bind(null, root, wakeable, lanes)),
-    wakeable.then(root, root));
+function resetWorkInProgressStack() {
+  if (null !== workInProgress) {
+    if (0 === workInProgressSuspendedReason)
+      var interruptedWork = workInProgress.return;
+    else
+      (interruptedWork = workInProgress),
+        resetContextDependencies(),
+        resetHooksOnUnwind(interruptedWork),
+        (thenableState$1 = null),
+        (thenableIndexCounter$1 = 0),
+        (interruptedWork = workInProgress);
+    for (; null !== interruptedWork; )
+      unwindInterruptedWork(interruptedWork.alternate, interruptedWork),
+        (interruptedWork = interruptedWork.return);
+    workInProgress = null;
+  }
 }
-function pingSuspendedRoot(root, wakeable, pingedLanes) {
-  var pingCache = root.pingCache;
-  null !== pingCache && pingCache.delete(wakeable);
-  root.pingedLanes |= root.suspendedLanes & pingedLanes;
-  workInProgressRoot === root &&
-    (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&
-    (4 === workInProgressRootExitStatus ||
-    (3 === workInProgressRootExitStatus &&
-      (workInProgressRootRenderLanes & 62914560) ===
-        workInProgressRootRenderLanes &&
-      300 > now() - globalMostRecentFallbackTime)
-      ? 0 === (executionContext & 2) && prepareFreshStack(root, 0)
-      : (workInProgressRootPingedLanes |= pingedLanes));
-  ensureRootIsScheduled(root);
+function prepareFreshStack(root, lanes) {
+  root.finishedWork = null;
+  root.finishedLanes = 0;
+  var timeoutHandle = root.timeoutHandle;
+  -1 !== timeoutHandle &&
+    ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle));
+  timeoutHandle = root.cancelPendingCommit;
+  null !== timeoutHandle &&
+    ((root.cancelPendingCommit = null), timeoutHandle());
+  resetWorkInProgressStack();
+  workInProgressRoot = root;
+  workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
+  workInProgressRootRenderLanes = lanes;
+  workInProgressSuspendedReason = 0;
+  workInProgressThrownValue = null;
+  workInProgressRootDidAttachPingListener = !1;
+  workInProgressRootExitStatus = 0;
+  workInProgressRootFatalError = null;
+  workInProgressDeferredLane =
+    workInProgressRootPingedLanes =
+    workInProgressRootInterleavedUpdatedLanes =
+    workInProgressRootSkippedLanes =
+      0;
+  workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors =
+    null;
+  workInProgressRootDidIncludeRecursiveRenderUpdate = !1;
+  0 !== (lanes & 8) && (lanes |= lanes & 32);
+  var allEntangledLanes = root.entangledLanes;
+  if (0 !== allEntangledLanes)
+    for (
+      root = root.entanglements, allEntangledLanes &= lanes;
+      0 < allEntangledLanes;
+
+    ) {
+      var index$4 = 31 - clz32(allEntangledLanes),
+        lane = 1 << index$4;
+      lanes |= root[index$4];
+      allEntangledLanes &= ~lane;
+    }
+  entangledRenderLanes = lanes;
+  finishQueueingConcurrentUpdates();
+  return timeoutHandle;
 }
-function retryTimedOutBoundary(boundaryFiber, retryLane) {
-  0 === retryLane &&
-    (retryLane = 0 === (boundaryFiber.mode & 1) ? 2 : claimNextRetryLane());
-  boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
-  null !== boundaryFiber &&
-    (markRootUpdated(boundaryFiber, retryLane),
-    ensureRootIsScheduled(boundaryFiber));
+function handleThrow(root, thrownValue) {
+  currentlyRenderingFiber$1 = null;
+  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
+  ReactCurrentOwner.current = null;
+  thrownValue === SuspenseException
+    ? ((thrownValue = getSuspendedThenable()),
+      (root = suspenseHandlerStackCursor.current),
+      (workInProgressSuspendedReason =
+        (null !== root &&
+          ((workInProgressRootRenderLanes & 4194176) ===
+          workInProgressRootRenderLanes
+            ? null !== shellBoundary
+            : ((workInProgressRootRenderLanes & 62914560) !==
+                workInProgressRootRenderLanes &&
+                0 === (workInProgressRootRenderLanes & 536870912)) ||
+              root !== shellBoundary)) ||
+        0 !== (workInProgressRootSkippedLanes & 134217727) ||
+        0 !== (workInProgressRootInterleavedUpdatedLanes & 134217727)
+          ? 3
+          : 2))
+    : thrownValue === SuspenseyCommitException
+    ? ((thrownValue = getSuspendedThenable()),
+      (workInProgressSuspendedReason = 4))
+    : (workInProgressSuspendedReason =
+        thrownValue === SelectiveHydrationException
+          ? 8
+          : null !== thrownValue &&
+            "object" === typeof thrownValue &&
+            "function" === typeof thrownValue.then
+          ? 6
+          : 1);
+  workInProgressThrownValue = thrownValue;
+  null === workInProgress &&
+    ((workInProgressRootExitStatus = 1),
+    (workInProgressRootFatalError = thrownValue));
 }
-function retryDehydratedSuspenseBoundary(boundaryFiber) {
-  var suspenseState = boundaryFiber.memoizedState,
-    retryLane = 0;
-  null !== suspenseState && (retryLane = suspenseState.retryLane);
-  retryTimedOutBoundary(boundaryFiber, retryLane);
+function pushDispatcher() {
+  var prevDispatcher = ReactCurrentDispatcher.current;
+  ReactCurrentDispatcher.current = ContextOnlyDispatcher;
+  return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
 }
-function resolveRetryWakeable(boundaryFiber, wakeable) {
-  var retryLane = 0;
-  switch (boundaryFiber.tag) {
-    case 13:
-      var retryCache = boundaryFiber.stateNode;
-      var suspenseState = boundaryFiber.memoizedState;
-      null !== suspenseState && (retryLane = suspenseState.retryLane);
-      break;
-    case 19:
-      retryCache = boundaryFiber.stateNode;
-      break;
-    case 22:
-      retryCache = boundaryFiber.stateNode._retryCache;
-      break;
-    default:
-      throw Error(
-        "Pinged unknown suspense boundary type. This is probably a bug in React."
-      );
-  }
-  null !== retryCache && retryCache.delete(wakeable);
-  retryTimedOutBoundary(boundaryFiber, retryLane);
+function renderDidSuspendDelayIfPossible() {
+  workInProgressRootExitStatus = 4;
+  (0 === (workInProgressRootSkippedLanes & 134217727) &&
+    0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||
+    null === workInProgressRoot ||
+    markRootSuspended(
+      workInProgressRoot,
+      workInProgressRootRenderLanes,
+      workInProgressDeferredLane
+    );
 }
-var beginWork;
-beginWork = function (current, workInProgress, renderLanes) {
-  if (null !== current)
-    if (
-      current.memoizedProps !== workInProgress.pendingProps ||
-      didPerformWorkStackCursor.current
-    )
-      didReceiveUpdate = !0;
-    else {
-      if (
-        0 === (current.lanes & renderLanes) &&
-        0 === (workInProgress.flags & 128)
-      )
-        return (
-          (didReceiveUpdate = !1),
-          attemptEarlyBailoutIfNoScheduledUpdate(
-            current,
-            workInProgress,
-            renderLanes
-          )
-        );
-      didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;
-    }
-  else didReceiveUpdate = !1;
-  workInProgress.lanes = 0;
-  switch (workInProgress.tag) {
-    case 2:
-      var Component = workInProgress.type;
-      resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress);
-      current = workInProgress.pendingProps;
-      var context = getMaskedContext(
-        workInProgress,
-        contextStackCursor$1.current
-      );
-      prepareToReadContext(workInProgress, renderLanes);
-      context = renderWithHooks(
-        null,
-        workInProgress,
-        Component,
-        current,
-        context,
-        renderLanes
-      );
-      workInProgress.flags |= 1;
-      if (
-        "object" === typeof context &&
-        null !== context &&
-        "function" === typeof context.render &&
-        void 0 === context.$$typeof
-      ) {
-        workInProgress.tag = 1;
-        workInProgress.memoizedState = null;
-        workInProgress.updateQueue = null;
-        if (isContextProvider(Component)) {
-          var hasContext = !0;
-          pushContextProvider(workInProgress);
-        } else hasContext = !1;
-        workInProgress.memoizedState =
-          null !== context.state && void 0 !== context.state
-            ? context.state
-            : null;
-        initializeUpdateQueue(workInProgress);
-        context.updater = classComponentUpdater;
-        workInProgress.stateNode = context;
-        context._reactInternals = workInProgress;
-        mountClassInstance(workInProgress, Component, current, renderLanes);
-        workInProgress = finishClassComponent(
-          null,
-          workInProgress,
-          Component,
-          !0,
-          hasContext,
-          renderLanes
-        );
-      } else
-        (workInProgress.tag = 0),
-          reconcileChildren(null, workInProgress, context, renderLanes),
-          (workInProgress = workInProgress.child);
-      return workInProgress;
-    case 16:
-      Component = workInProgress.elementType;
-      a: {
-        resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress);
-        current = workInProgress.pendingProps;
-        context = Component._init;
-        Component = context(Component._payload);
-        workInProgress.type = Component;
-        context = workInProgress.tag = resolveLazyComponentTag(Component);
-        current = resolveDefaultProps(Component, current);
-        switch (context) {
-          case 0:
-            workInProgress = updateFunctionComponent(
-              null,
-              workInProgress,
-              Component,
-              current,
-              renderLanes
-            );
+function renderRootSync(root, lanes) {
+  var prevExecutionContext = executionContext;
+  executionContext |= 2;
+  var prevDispatcher = pushDispatcher();
+  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes)
+    (workInProgressTransitions = null), prepareFreshStack(root, lanes);
+  lanes = !1;
+  a: do
+    try {
+      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
+        var unitOfWork = workInProgress,
+          thrownValue = workInProgressThrownValue;
+        switch (workInProgressSuspendedReason) {
+          case 8:
+            resetWorkInProgressStack();
+            workInProgressRootExitStatus = 6;
             break a;
+          case 3:
+          case 2:
+            lanes ||
+              null !== suspenseHandlerStackCursor.current ||
+              (lanes = !0);
+          default:
+            (workInProgressSuspendedReason = 0),
+              (workInProgressThrownValue = null),
+              throwAndUnwindWorkLoop(root, unitOfWork, thrownValue);
+        }
+      }
+      workLoopSync();
+      break;
+    } catch (thrownValue$94) {
+      handleThrow(root, thrownValue$94);
+    }
+  while (1);
+  lanes && root.shellSuspendCounter++;
+  resetContextDependencies();
+  executionContext = prevExecutionContext;
+  ReactCurrentDispatcher.current = prevDispatcher;
+  if (null !== workInProgress)
+    throw Error(
+      "Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue."
+    );
+  workInProgressRoot = null;
+  workInProgressRootRenderLanes = 0;
+  finishQueueingConcurrentUpdates();
+  return workInProgressRootExitStatus;
+}
+function workLoopSync() {
+  for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
+}
+function renderRootConcurrent(root, lanes) {
+  var prevExecutionContext = executionContext;
+  executionContext |= 2;
+  var prevDispatcher = pushDispatcher();
+  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes)
+    (workInProgressTransitions = null),
+      (workInProgressRootRenderTargetTime = now() + 500),
+      prepareFreshStack(root, lanes);
+  a: do
+    try {
+      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
+        lanes = workInProgress;
+        var thrownValue = workInProgressThrownValue;
+        b: switch (workInProgressSuspendedReason) {
           case 1:
-            workInProgress = updateClassComponent(
-              null,
-              workInProgress,
-              Component,
-              current,
-              renderLanes
-            );
+            workInProgressSuspendedReason = 0;
+            workInProgressThrownValue = null;
+            throwAndUnwindWorkLoop(root, lanes, thrownValue);
+            break;
+          case 2:
+            if (isThenableResolved(thrownValue)) {
+              workInProgressSuspendedReason = 0;
+              workInProgressThrownValue = null;
+              replaySuspendedUnitOfWork(lanes);
+              break;
+            }
+            lanes = function () {
+              2 === workInProgressSuspendedReason &&
+                workInProgressRoot === root &&
+                (workInProgressSuspendedReason = 7);
+              ensureRootIsScheduled(root);
+            };
+            thrownValue.then(lanes, lanes);
             break a;
-          case 11:
-            workInProgress = updateForwardRef(
-              null,
-              workInProgress,
-              Component,
-              current,
-              renderLanes
-            );
+          case 3:
+            workInProgressSuspendedReason = 7;
             break a;
-          case 14:
-            workInProgress = updateMemoComponent(
-              null,
-              workInProgress,
-              Component,
-              resolveDefaultProps(Component.type, current),
-              renderLanes
-            );
+          case 4:
+            workInProgressSuspendedReason = 5;
+            break a;
+          case 7:
+            isThenableResolved(thrownValue)
+              ? ((workInProgressSuspendedReason = 0),
+                (workInProgressThrownValue = null),
+                replaySuspendedUnitOfWork(lanes))
+              : ((workInProgressSuspendedReason = 0),
+                (workInProgressThrownValue = null),
+                throwAndUnwindWorkLoop(root, lanes, thrownValue));
+            break;
+          case 5:
+            switch (workInProgress.tag) {
+              case 5:
+              case 26:
+              case 27:
+                lanes = workInProgress;
+                workInProgressSuspendedReason = 0;
+                workInProgressThrownValue = null;
+                var sibling = lanes.sibling;
+                if (null !== sibling) workInProgress = sibling;
+                else {
+                  var returnFiber = lanes.return;
+                  null !== returnFiber
+                    ? ((workInProgress = returnFiber),
+                      completeUnitOfWork(returnFiber))
+                    : (workInProgress = null);
+                }
+                break b;
+            }
+            workInProgressSuspendedReason = 0;
+            workInProgressThrownValue = null;
+            throwAndUnwindWorkLoop(root, lanes, thrownValue);
+            break;
+          case 6:
+            workInProgressSuspendedReason = 0;
+            workInProgressThrownValue = null;
+            throwAndUnwindWorkLoop(root, lanes, thrownValue);
+            break;
+          case 8:
+            resetWorkInProgressStack();
+            workInProgressRootExitStatus = 6;
             break a;
+          default:
+            throw Error("Unexpected SuspendedReason. This is a bug in React.");
         }
-        throw Error(
-          "Element type is invalid. Received a promise that resolves to: " +
-            Component +
-            ". Lazy element type must resolve to a class or function."
-        );
       }
-      return workInProgress;
+      workLoopConcurrent();
+      break;
+    } catch (thrownValue$96) {
+      handleThrow(root, thrownValue$96);
+    }
+  while (1);
+  resetContextDependencies();
+  ReactCurrentDispatcher.current = prevDispatcher;
+  executionContext = prevExecutionContext;
+  if (null !== workInProgress) return 0;
+  workInProgressRoot = null;
+  workInProgressRootRenderLanes = 0;
+  finishQueueingConcurrentUpdates();
+  return workInProgressRootExitStatus;
+}
+function workLoopConcurrent() {
+  for (; null !== workInProgress && !shouldYield(); )
+    performUnitOfWork(workInProgress);
+}
+function performUnitOfWork(unitOfWork) {
+  var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
+  unitOfWork.memoizedProps = unitOfWork.pendingProps;
+  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);
+  ReactCurrentOwner.current = null;
+}
+function replaySuspendedUnitOfWork(unitOfWork) {
+  var current = unitOfWork.alternate;
+  switch (unitOfWork.tag) {
+    case 2:
+      unitOfWork.tag = 0;
+    case 15:
     case 0:
-      return (
-        (Component = workInProgress.type),
-        (context = workInProgress.pendingProps),
-        (context =
-          workInProgress.elementType === Component
-            ? context
-            : resolveDefaultProps(Component, context)),
-        updateFunctionComponent(
-          current,
-          workInProgress,
-          Component,
-          context,
-          renderLanes
-        )
-      );
-    case 1:
-      return (
-        (Component = workInProgress.type),
-        (context = workInProgress.pendingProps),
-        (context =
-          workInProgress.elementType === Component
-            ? context
-            : resolveDefaultProps(Component, context)),
-        updateClassComponent(
-          current,
-          workInProgress,
-          Component,
-          context,
-          renderLanes
-        )
-      );
-    case 3:
-      pushHostRootContext(workInProgress);
-      if (null === current)
-        throw Error("Should have a current fiber. This is a bug in React.");
-      context = workInProgress.pendingProps;
-      Component = workInProgress.memoizedState.element;
-      cloneUpdateQueue(current, workInProgress);
-      processUpdateQueue(workInProgress, context, null, renderLanes);
-      context = workInProgress.memoizedState.element;
-      context === Component
-        ? (workInProgress = bailoutOnAlreadyFinishedWork(
-            current,
-            workInProgress,
-            renderLanes
-          ))
-        : (reconcileChildren(current, workInProgress, context, renderLanes),
-          (workInProgress = workInProgress.child));
-      return workInProgress;
-    case 26:
-    case 27:
-    case 5:
-      return (
-        pushHostContext(workInProgress),
-        (Component = workInProgress.pendingProps.children),
-        markRef$1(current, workInProgress),
-        reconcileChildren(current, workInProgress, Component, renderLanes),
-        workInProgress.child
-      );
-    case 6:
-      return null;
-    case 13:
-      return updateSuspenseComponent(current, workInProgress, renderLanes);
-    case 4:
-      return (
-        pushHostContainer(
-          workInProgress,
-          workInProgress.stateNode.containerInfo
-        ),
-        (Component = workInProgress.pendingProps),
-        null === current
-          ? (workInProgress.child = reconcileChildFibers(
-              workInProgress,
-              null,
-              Component,
-              renderLanes
-            ))
-          : reconcileChildren(current, workInProgress, Component, renderLanes),
-        workInProgress.child
-      );
-    case 11:
-      return (
-        (Component = workInProgress.type),
-        (context = workInProgress.pendingProps),
-        (context =
-          workInProgress.elementType === Component
-            ? context
-            : resolveDefaultProps(Component, context)),
-        updateForwardRef(
-          current,
-          workInProgress,
-          Component,
-          context,
-          renderLanes
-        )
-      );
-    case 7:
-      return (
-        reconcileChildren(
-          current,
-          workInProgress,
-          workInProgress.pendingProps,
-          renderLanes
-        ),
-        workInProgress.child
+      var Component = unitOfWork.type,
+        unresolvedProps = unitOfWork.pendingProps;
+      unresolvedProps =
+        unitOfWork.elementType === Component
+          ? unresolvedProps
+          : resolveDefaultProps(Component, unresolvedProps);
+      current = replayFunctionComponent(
+        current,
+        unitOfWork,
+        unresolvedProps,
+        Component,
+        void 0,
+        workInProgressRootRenderLanes
       );
-    case 8:
-      return (
-        reconcileChildren(
-          current,
-          workInProgress,
-          workInProgress.pendingProps.children,
-          renderLanes
-        ),
-        workInProgress.child
+      break;
+    case 11:
+      Component = unitOfWork.type.render;
+      unresolvedProps = unitOfWork.pendingProps;
+      unresolvedProps =
+        unitOfWork.elementType === Component
+          ? unresolvedProps
+          : resolveDefaultProps(Component, unresolvedProps);
+      current = replayFunctionComponent(
+        current,
+        unitOfWork,
+        unresolvedProps,
+        Component,
+        unitOfWork.ref,
+        workInProgressRootRenderLanes
       );
-    case 12:
-      return (
-        reconcileChildren(
-          current,
-          workInProgress,
-          workInProgress.pendingProps.children,
-          renderLanes
-        ),
-        workInProgress.child
+      break;
+    case 5:
+      resetHooksOnUnwind(unitOfWork);
+    default:
+      unwindInterruptedWork(current, unitOfWork),
+        (unitOfWork = workInProgress =
+          resetWorkInProgress(unitOfWork, entangledRenderLanes)),
+        (current = beginWork(current, unitOfWork, entangledRenderLanes));
+  }
+  unitOfWork.memoizedProps = unitOfWork.pendingProps;
+  null === current
+    ? completeUnitOfWork(unitOfWork)
+    : (workInProgress = current);
+  ReactCurrentOwner.current = null;
+}
+function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue) {
+  resetContextDependencies();
+  resetHooksOnUnwind(unitOfWork);
+  thenableState$1 = null;
+  thenableIndexCounter$1 = 0;
+  var returnFiber = unitOfWork.return;
+  try {
+    if (
+      throwException(
+        root,
+        returnFiber,
+        unitOfWork,
+        thrownValue,
+        workInProgressRootRenderLanes
+      )
+    ) {
+      workInProgressRootExitStatus = 1;
+      workInProgressRootFatalError = thrownValue;
+      workInProgress = null;
+      return;
+    }
+  } catch (error) {
+    if (null !== returnFiber) throw ((workInProgress = returnFiber), error);
+    workInProgressRootExitStatus = 1;
+    workInProgressRootFatalError = thrownValue;
+    workInProgress = null;
+    return;
+  }
+  if (unitOfWork.flags & 32768)
+    a: {
+      root = unitOfWork;
+      do {
+        unitOfWork = unwindWork(root.alternate, root);
+        if (null !== unitOfWork) {
+          unitOfWork.flags &= 32767;
+          workInProgress = unitOfWork;
+          break a;
+        }
+        root = root.return;
+        null !== root &&
+          ((root.flags |= 32768),
+          (root.subtreeFlags = 0),
+          (root.deletions = null));
+        workInProgress = root;
+      } while (null !== root);
+      workInProgressRootExitStatus = 6;
+      workInProgress = null;
+    }
+  else completeUnitOfWork(unitOfWork);
+}
+function completeUnitOfWork(unitOfWork) {
+  var completedWork = unitOfWork;
+  do {
+    unitOfWork = completedWork.return;
+    var next = completeWork(
+      completedWork.alternate,
+      completedWork,
+      entangledRenderLanes
+    );
+    if (null !== next) {
+      workInProgress = next;
+      return;
+    }
+    completedWork = completedWork.sibling;
+    if (null !== completedWork) {
+      workInProgress = completedWork;
+      return;
+    }
+    workInProgress = completedWork = unitOfWork;
+  } while (null !== completedWork);
+  0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
+}
+function commitRoot(
+  root,
+  recoverableErrors,
+  transitions,
+  didIncludeRenderPhaseUpdate,
+  spawnedLane
+) {
+  var previousUpdateLanePriority = currentUpdatePriority,
+    prevTransition = ReactCurrentBatchConfig.transition;
+  try {
+    (ReactCurrentBatchConfig.transition = null),
+      (currentUpdatePriority = 2),
+      commitRootImpl(
+        root,
+        recoverableErrors,
+        transitions,
+        didIncludeRenderPhaseUpdate,
+        previousUpdateLanePriority,
+        spawnedLane
       );
-    case 10:
-      a: {
-        Component = workInProgress.type._context;
-        context = workInProgress.pendingProps;
-        hasContext = workInProgress.memoizedProps;
-        var newValue = context.value;
-        push(valueCursor, Component._currentValue);
-        Component._currentValue = newValue;
-        if (null !== hasContext)
-          if (objectIs(hasContext.value, newValue)) {
-            if (
-              hasContext.children === context.children &&
-              !didPerformWorkStackCursor.current
-            ) {
-              workInProgress = bailoutOnAlreadyFinishedWork(
-                current,
-                workInProgress,
-                renderLanes
-              );
-              break a;
-            }
-          } else
-            for (
-              hasContext = workInProgress.child,
-                null !== hasContext && (hasContext.return = workInProgress);
-              null !== hasContext;
-
-            ) {
-              var list = hasContext.dependencies;
-              if (null !== list) {
-                newValue = hasContext.child;
-                for (
-                  var dependency = list.firstContext;
-                  null !== dependency;
-
-                ) {
-                  if (dependency.context === Component) {
-                    if (1 === hasContext.tag) {
-                      dependency = createUpdate(renderLanes & -renderLanes);
-                      dependency.tag = 2;
-                      var updateQueue = hasContext.updateQueue;
-                      if (null !== updateQueue) {
-                        updateQueue = updateQueue.shared;
-                        var pending = updateQueue.pending;
-                        null === pending
-                          ? (dependency.next = dependency)
-                          : ((dependency.next = pending.next),
-                            (pending.next = dependency));
-                        updateQueue.pending = dependency;
-                      }
-                    }
-                    hasContext.lanes |= renderLanes;
-                    dependency = hasContext.alternate;
-                    null !== dependency && (dependency.lanes |= renderLanes);
-                    scheduleContextWorkOnParentPath(
-                      hasContext.return,
-                      renderLanes,
-                      workInProgress
-                    );
-                    list.lanes |= renderLanes;
-                    break;
-                  }
-                  dependency = dependency.next;
-                }
-              } else if (10 === hasContext.tag)
-                newValue =
-                  hasContext.type === workInProgress.type
-                    ? null
-                    : hasContext.child;
-              else if (18 === hasContext.tag) {
-                newValue = hasContext.return;
-                if (null === newValue)
-                  throw Error(
-                    "We just came from a parent so we must have had a parent. This is a bug in React."
-                  );
-                newValue.lanes |= renderLanes;
-                list = newValue.alternate;
-                null !== list && (list.lanes |= renderLanes);
-                scheduleContextWorkOnParentPath(
-                  newValue,
-                  renderLanes,
-                  workInProgress
-                );
-                newValue = hasContext.sibling;
-              } else newValue = hasContext.child;
-              if (null !== newValue) newValue.return = hasContext;
-              else
-                for (newValue = hasContext; null !== newValue; ) {
-                  if (newValue === workInProgress) {
-                    newValue = null;
-                    break;
-                  }
-                  hasContext = newValue.sibling;
-                  if (null !== hasContext) {
-                    hasContext.return = newValue.return;
-                    newValue = hasContext;
-                    break;
-                  }
-                  newValue = newValue.return;
-                }
-              hasContext = newValue;
-            }
-        reconcileChildren(
-          current,
-          workInProgress,
-          context.children,
-          renderLanes
+  } finally {
+    (ReactCurrentBatchConfig.transition = prevTransition),
+      (currentUpdatePriority = previousUpdateLanePriority);
+  }
+  return null;
+}
+function commitRootImpl(
+  root,
+  recoverableErrors,
+  transitions,
+  didIncludeRenderPhaseUpdate,
+  renderPriorityLevel,
+  spawnedLane
+) {
+  do flushPassiveEffects();
+  while (null !== rootWithPendingPassiveEffects);
+  if (0 !== (executionContext & 6))
+    throw Error("Should not already be working.");
+  didIncludeRenderPhaseUpdate = root.finishedWork;
+  transitions = root.finishedLanes;
+  if (null === didIncludeRenderPhaseUpdate) return null;
+  root.finishedWork = null;
+  root.finishedLanes = 0;
+  if (didIncludeRenderPhaseUpdate === root.current)
+    throw Error(
+      "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
+    );
+  root.callbackNode = null;
+  root.callbackPriority = 0;
+  root.cancelPendingCommit = null;
+  var remainingLanes =
+    didIncludeRenderPhaseUpdate.lanes | didIncludeRenderPhaseUpdate.childLanes;
+  remainingLanes |= concurrentlyUpdatedLanes;
+  markRootFinished(root, remainingLanes, spawnedLane);
+  root === workInProgressRoot &&
+    ((workInProgress = workInProgressRoot = null),
+    (workInProgressRootRenderLanes = 0));
+  (0 === (didIncludeRenderPhaseUpdate.subtreeFlags & 10256) &&
+    0 === (didIncludeRenderPhaseUpdate.flags & 10256)) ||
+    rootDoesHavePassiveEffects ||
+    ((rootDoesHavePassiveEffects = !0),
+    scheduleCallback(NormalPriority, function () {
+      flushPassiveEffects();
+      return null;
+    }));
+  spawnedLane = 0 !== (didIncludeRenderPhaseUpdate.flags & 15990);
+  if (0 !== (didIncludeRenderPhaseUpdate.subtreeFlags & 15990) || spawnedLane) {
+    spawnedLane = ReactCurrentBatchConfig.transition;
+    ReactCurrentBatchConfig.transition = null;
+    remainingLanes = currentUpdatePriority;
+    currentUpdatePriority = 2;
+    var prevExecutionContext = executionContext;
+    executionContext |= 4;
+    ReactCurrentOwner.current = null;
+    commitBeforeMutationEffects(root, didIncludeRenderPhaseUpdate);
+    commitMutationEffectsOnFiber(didIncludeRenderPhaseUpdate, root);
+    root.current = didIncludeRenderPhaseUpdate;
+    commitLayoutEffectOnFiber(
+      root,
+      didIncludeRenderPhaseUpdate.alternate,
+      didIncludeRenderPhaseUpdate
+    );
+    requestPaint();
+    executionContext = prevExecutionContext;
+    currentUpdatePriority = remainingLanes;
+    ReactCurrentBatchConfig.transition = spawnedLane;
+  } else root.current = didIncludeRenderPhaseUpdate;
+  rootDoesHavePassiveEffects &&
+    ((rootDoesHavePassiveEffects = !1),
+    (rootWithPendingPassiveEffects = root),
+    (pendingPassiveEffectsLanes = transitions));
+  remainingLanes = root.pendingLanes;
+  0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
+  onCommitRoot(didIncludeRenderPhaseUpdate.stateNode, renderPriorityLevel);
+  ensureRootIsScheduled(root);
+  if (null !== recoverableErrors)
+    for (
+      renderPriorityLevel = root.onRecoverableError,
+        didIncludeRenderPhaseUpdate = 0;
+      didIncludeRenderPhaseUpdate < recoverableErrors.length;
+      didIncludeRenderPhaseUpdate++
+    )
+      (spawnedLane = recoverableErrors[didIncludeRenderPhaseUpdate]),
+        (remainingLanes = {
+          digest: spawnedLane.digest,
+          componentStack: spawnedLane.stack
+        }),
+        renderPriorityLevel(spawnedLane.value, remainingLanes);
+  if (hasUncaughtError)
+    throw (
+      ((hasUncaughtError = !1),
+      (root = firstUncaughtError),
+      (firstUncaughtError = null),
+      root)
+    );
+  0 !== (pendingPassiveEffectsLanes & 3) &&
+    0 !== root.tag &&
+    flushPassiveEffects();
+  remainingLanes = root.pendingLanes;
+  0 !== (transitions & 4194218) && 0 !== (remainingLanes & 42)
+    ? root === rootWithNestedUpdates
+      ? nestedUpdateCount++
+      : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root))
+    : (nestedUpdateCount = 0);
+  flushSyncWorkAcrossRoots_impl(!1);
+  return null;
+}
+function flushPassiveEffects() {
+  if (null !== rootWithPendingPassiveEffects) {
+    var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes),
+      prevTransition = ReactCurrentBatchConfig.transition,
+      previousPriority = currentUpdatePriority;
+    try {
+      ReactCurrentBatchConfig.transition = null;
+      currentUpdatePriority = 32 > renderPriority ? 32 : renderPriority;
+      if (null === rootWithPendingPassiveEffects)
+        var JSCompiler_inline_result = !1;
+      else {
+        renderPriority = rootWithPendingPassiveEffects;
+        rootWithPendingPassiveEffects = null;
+        pendingPassiveEffectsLanes = 0;
+        if (0 !== (executionContext & 6))
+          throw Error("Cannot flush passive effects while already rendering.");
+        var prevExecutionContext = executionContext;
+        executionContext |= 4;
+        commitPassiveUnmountOnFiber(renderPriority.current);
+        commitPassiveMountOnFiber(renderPriority, renderPriority.current);
+        executionContext = prevExecutionContext;
+        flushSyncWorkAcrossRoots_impl(!1);
+        if (
+          injectedHook &&
+          "function" === typeof injectedHook.onPostCommitFiberRoot
+        )
+          try {
+            injectedHook.onPostCommitFiberRoot(rendererID, renderPriority);
+          } catch (err) {}
+        JSCompiler_inline_result = !0;
+      }
+      return JSCompiler_inline_result;
+    } finally {
+      (currentUpdatePriority = previousPriority),
+        (ReactCurrentBatchConfig.transition = prevTransition);
+    }
+  }
+  return !1;
+}
+function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
+  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
+  sourceFiber = createRootErrorUpdate(rootFiber, sourceFiber, 2);
+  rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
+  null !== rootFiber &&
+    (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
+}
+function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
+  if (3 === sourceFiber.tag)
+    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
+  else
+    for (; null !== nearestMountedAncestor; ) {
+      if (3 === nearestMountedAncestor.tag) {
+        captureCommitPhaseErrorOnRoot(
+          nearestMountedAncestor,
+          sourceFiber,
+          error
         );
-        workInProgress = workInProgress.child;
+        break;
+      } else if (1 === nearestMountedAncestor.tag) {
+        var instance = nearestMountedAncestor.stateNode;
+        if (
+          "function" ===
+            typeof nearestMountedAncestor.type.getDerivedStateFromError ||
+          ("function" === typeof instance.componentDidCatch &&
+            (null === legacyErrorBoundariesThatAlreadyFailed ||
+              !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
+        ) {
+          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
+          sourceFiber = createClassErrorUpdate(
+            nearestMountedAncestor,
+            sourceFiber,
+            2
+          );
+          nearestMountedAncestor = enqueueUpdate(
+            nearestMountedAncestor,
+            sourceFiber,
+            2
+          );
+          null !== nearestMountedAncestor &&
+            (markRootUpdated$1(nearestMountedAncestor, 2),
+            ensureRootIsScheduled(nearestMountedAncestor));
+          break;
+        }
       }
-      return workInProgress;
-    case 9:
-      return (
-        (context = workInProgress.type),
-        (Component = workInProgress.pendingProps.children),
-        prepareToReadContext(workInProgress, renderLanes),
-        (context = readContext(context)),
-        (Component = Component(context)),
-        (workInProgress.flags |= 1),
-        reconcileChildren(current, workInProgress, Component, renderLanes),
-        workInProgress.child
-      );
-    case 14:
-      return (
-        (Component = workInProgress.type),
-        (context = resolveDefaultProps(Component, workInProgress.pendingProps)),
-        (context = resolveDefaultProps(Component.type, context)),
-        updateMemoComponent(
-          current,
-          workInProgress,
-          Component,
-          context,
-          renderLanes
-        )
-      );
-    case 15:
-      return updateSimpleMemoComponent(
-        current,
-        workInProgress,
-        workInProgress.type,
-        workInProgress.pendingProps,
-        renderLanes
-      );
-    case 17:
-      return (
-        (Component = workInProgress.type),
-        (context = workInProgress.pendingProps),
-        (context =
-          workInProgress.elementType === Component
-            ? context
-            : resolveDefaultProps(Component, context)),
-        resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress),
-        (workInProgress.tag = 1),
-        isContextProvider(Component)
-          ? ((current = !0), pushContextProvider(workInProgress))
-          : (current = !1),
-        prepareToReadContext(workInProgress, renderLanes),
-        constructClassInstance(workInProgress, Component, context),
-        mountClassInstance(workInProgress, Component, context, renderLanes),
-        finishClassComponent(
-          null,
-          workInProgress,
-          Component,
-          !0,
-          current,
-          renderLanes
-        )
-      );
+      nearestMountedAncestor = nearestMountedAncestor.return;
+    }
+}
+function attachPingListener(root, wakeable, lanes) {
+  var pingCache = root.pingCache;
+  if (null === pingCache) {
+    pingCache = root.pingCache = new PossiblyWeakMap();
+    var threadIDs = new Set();
+    pingCache.set(wakeable, threadIDs);
+  } else
+    (threadIDs = pingCache.get(wakeable)),
+      void 0 === threadIDs &&
+        ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs));
+  threadIDs.has(lanes) ||
+    ((workInProgressRootDidAttachPingListener = !0),
+    threadIDs.add(lanes),
+    (root = pingSuspendedRoot.bind(null, root, wakeable, lanes)),
+    wakeable.then(root, root));
+}
+function pingSuspendedRoot(root, wakeable, pingedLanes) {
+  var pingCache = root.pingCache;
+  null !== pingCache && pingCache.delete(wakeable);
+  root.pingedLanes |= root.suspendedLanes & pingedLanes;
+  workInProgressRoot === root &&
+    (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&
+    (4 === workInProgressRootExitStatus ||
+    (3 === workInProgressRootExitStatus &&
+      (workInProgressRootRenderLanes & 62914560) ===
+        workInProgressRootRenderLanes &&
+      300 > now() - globalMostRecentFallbackTime)
+      ? 0 === (executionContext & 2) && prepareFreshStack(root, 0)
+      : (workInProgressRootPingedLanes |= pingedLanes));
+  ensureRootIsScheduled(root);
+}
+function retryTimedOutBoundary(boundaryFiber, retryLane) {
+  0 === retryLane &&
+    (retryLane = 0 === (boundaryFiber.mode & 1) ? 2 : claimNextRetryLane());
+  boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
+  null !== boundaryFiber &&
+    (markRootUpdated$1(boundaryFiber, retryLane),
+    ensureRootIsScheduled(boundaryFiber));
+}
+function retryDehydratedSuspenseBoundary(boundaryFiber) {
+  var suspenseState = boundaryFiber.memoizedState,
+    retryLane = 0;
+  null !== suspenseState && (retryLane = suspenseState.retryLane);
+  retryTimedOutBoundary(boundaryFiber, retryLane);
+}
+function resolveRetryWakeable(boundaryFiber, wakeable) {
+  var retryLane = 0;
+  switch (boundaryFiber.tag) {
+    case 13:
+      var retryCache = boundaryFiber.stateNode;
+      var suspenseState = boundaryFiber.memoizedState;
+      null !== suspenseState && (retryLane = suspenseState.retryLane);
+      break;
     case 19:
-      return updateSuspenseListComponent(current, workInProgress, renderLanes);
+      retryCache = boundaryFiber.stateNode;
+      break;
     case 22:
-      return updateOffscreenComponent(current, workInProgress, renderLanes);
+      retryCache = boundaryFiber.stateNode._retryCache;
+      break;
+    default:
+      throw Error(
+        "Pinged unknown suspense boundary type. This is probably a bug in React."
+      );
   }
-  throw Error(
-    "Unknown unit of work tag (" +
-      workInProgress.tag +
-      "). This error is likely caused by a bug in React. Please file an issue."
-  );
-};
+  null !== retryCache && retryCache.delete(wakeable);
+  retryTimedOutBoundary(boundaryFiber, retryLane);
+}
 function scheduleCallback(priorityLevel, callback) {
   return scheduleCallback$2(priorityLevel, callback);
 }
@@ -9320,6 +9008,7 @@ function createFiberFromTypeAndProps(
             case REACT_CONTEXT_TYPE:
               fiberTag = 9;
               break a;
+            case REACT_CONSUMER_TYPE:
             case REACT_FORWARD_REF_TYPE:
               fiberTag = 11;
               break a;
@@ -9473,63 +9162,19 @@ function findHostInstance(component) {
   return null === component ? null : getPublicInstance(component.stateNode);
 }
 function updateContainer(element, container, parentComponent, callback) {
-  var current = container.current,
-    lane = requestUpdateLane(current);
-  a: if (parentComponent) {
-    parentComponent = parentComponent._reactInternals;
-    b: {
-      if (
-        getNearestMountedFiber(parentComponent) !== parentComponent ||
-        1 !== parentComponent.tag
-      )
-        throw Error(
-          "Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue."
-        );
-      var JSCompiler_inline_result = parentComponent;
-      do {
-        switch (JSCompiler_inline_result.tag) {
-          case 3:
-            JSCompiler_inline_result =
-              JSCompiler_inline_result.stateNode.context;
-            break b;
-          case 1:
-            if (isContextProvider(JSCompiler_inline_result.type)) {
-              JSCompiler_inline_result =
-                JSCompiler_inline_result.stateNode
-                  .__reactInternalMemoizedMergedChildContext;
-              break b;
-            }
-        }
-        JSCompiler_inline_result = JSCompiler_inline_result.return;
-      } while (null !== JSCompiler_inline_result);
-      throw Error(
-        "Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue."
-      );
-    }
-    if (1 === parentComponent.tag) {
-      var Component = parentComponent.type;
-      if (isContextProvider(Component)) {
-        parentComponent = processChildContext(
-          parentComponent,
-          Component,
-          JSCompiler_inline_result
-        );
-        break a;
-      }
-    }
-    parentComponent = JSCompiler_inline_result;
-  } else parentComponent = emptyContextObject;
+  parentComponent = container.current;
+  var lane = requestUpdateLane(parentComponent);
   null === container.context
-    ? (container.context = parentComponent)
-    : (container.pendingContext = parentComponent);
+    ? (container.context = emptyContextObject)
+    : (container.pendingContext = emptyContextObject);
   container = createUpdate(lane);
   container.payload = { element: element };
   callback = void 0 === callback ? null : callback;
   null !== callback && (container.callback = callback);
-  element = enqueueUpdate(current, container, lane);
+  element = enqueueUpdate(parentComponent, container, lane);
   null !== element &&
-    (scheduleUpdateOnFiber(element, current, lane),
-    entangleTransitions(element, current, lane));
+    (scheduleUpdateOnFiber(element, parentComponent, lane),
+    entangleTransitions(element, parentComponent, lane));
   return lane;
 }
 function emptyFindFiberByHostInstance() {
@@ -9584,10 +9229,10 @@ batchedUpdatesImpl = function (fn, a) {
   }
 };
 var roots = new Map(),
-  devToolsConfig$jscomp$inline_1114 = {
+  devToolsConfig$jscomp$inline_1100 = {
     findFiberByHostInstance: getInstanceFromTag,
     bundleType: 0,
-    version: "18.3.0-canary-03d6f7cf0-20240209",
+    version: "18.3.0-canary-9372c6311-20240315",
     rendererPackageName: "react-native-renderer",
     rendererConfig: {
       getInspectorDataForInstance: getInspectorDataForInstance,
@@ -9603,11 +9248,11 @@ var roots = new Map(),
       }.bind(null, findNodeHandle)
     }
   };
-var internals$jscomp$inline_1353 = {
-  bundleType: devToolsConfig$jscomp$inline_1114.bundleType,
-  version: devToolsConfig$jscomp$inline_1114.version,
-  rendererPackageName: devToolsConfig$jscomp$inline_1114.rendererPackageName,
-  rendererConfig: devToolsConfig$jscomp$inline_1114.rendererConfig,
+var internals$jscomp$inline_1342 = {
+  bundleType: devToolsConfig$jscomp$inline_1100.bundleType,
+  version: devToolsConfig$jscomp$inline_1100.version,
+  rendererPackageName: devToolsConfig$jscomp$inline_1100.rendererPackageName,
+  rendererConfig: devToolsConfig$jscomp$inline_1100.rendererConfig,
   overrideHookState: null,
   overrideHookStateDeletePath: null,
   overrideHookStateRenamePath: null,
@@ -9623,26 +9268,26 @@ var internals$jscomp$inline_1353 = {
     return null === fiber ? null : fiber.stateNode;
   },
   findFiberByHostInstance:
-    devToolsConfig$jscomp$inline_1114.findFiberByHostInstance ||
+    devToolsConfig$jscomp$inline_1100.findFiberByHostInstance ||
     emptyFindFiberByHostInstance,
   findHostInstancesForRefresh: null,
   scheduleRefresh: null,
   scheduleRoot: null,
   setRefreshHandler: null,
   getCurrentFiber: null,
-  reconcilerVersion: "18.3.0-canary-03d6f7cf0-20240209"
+  reconcilerVersion: "18.3.0-canary-9372c6311-20240315"
 };
 if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
-  var hook$jscomp$inline_1354 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
+  var hook$jscomp$inline_1343 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
   if (
-    !hook$jscomp$inline_1354.isDisabled &&
-    hook$jscomp$inline_1354.supportsFiber
+    !hook$jscomp$inline_1343.isDisabled &&
+    hook$jscomp$inline_1343.supportsFiber
   )
     try {
-      (rendererID = hook$jscomp$inline_1354.inject(
-        internals$jscomp$inline_1353
+      (rendererID = hook$jscomp$inline_1343.inject(
+        internals$jscomp$inline_1342
       )),
-        (injectedHook = hook$jscomp$inline_1354);
+        (injectedHook = hook$jscomp$inline_1343);
     } catch (err) {}
 }
 exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = {
diff --git a/node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-profiling.js b/node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-profiling.js
index c67b0c4..0ccf11c 100644
--- a/node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-profiling.js
+++ b/node_modules/react-native/Libraries/Renderer/implementations/ReactNativeRenderer-profiling.js
@@ -8,7 +8,7 @@
  * @nolint
  * @providesModule ReactNativeRenderer-profiling
  * @preventMunge
- * @generated SignedSource<<5df973db061e36edfd192d75fab51c36>>
+ * @generated SignedSource<<7ad664bd0b8a14a802c352b7131a3eb2>>
  */
 
 "use strict";
@@ -19,69 +19,26 @@
 require("react-native/Libraries/ReactPrivate/ReactNativePrivateInitializeCore");
 var ReactNativePrivateInterface = require("react-native/Libraries/ReactPrivate/ReactNativePrivateInterface"),
   React = require("react"),
-  Scheduler = require("scheduler");
-function invokeGuardedCallbackImpl(name, func, context) {
-  var funcArgs = Array.prototype.slice.call(arguments, 3);
-  try {
-    func.apply(context, funcArgs);
-  } catch (error) {
-    this.onError(error);
-  }
-}
-var hasError = !1,
+  Scheduler = require("scheduler"),
+  isArrayImpl = Array.isArray,
+  hasError = !1,
   caughtError = null,
-  hasRethrowError = !1,
-  rethrowError = null,
-  reporter = {
-    onError: function (error) {
-      hasError = !0;
-      caughtError = error;
-    }
-  };
-function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
-  hasError = !1;
-  caughtError = null;
-  invokeGuardedCallbackImpl.apply(reporter, arguments);
-}
-function invokeGuardedCallbackAndCatchFirstError(
-  name,
-  func,
-  context,
-  a,
-  b,
-  c,
-  d,
-  e,
-  f
-) {
-  invokeGuardedCallback.apply(this, arguments);
-  if (hasError) {
-    if (hasError) {
-      var error = caughtError;
-      hasError = !1;
-      caughtError = null;
-    } else
-      throw Error(
-        "clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue."
-      );
-    hasRethrowError || ((hasRethrowError = !0), (rethrowError = error));
-  }
-}
-var isArrayImpl = Array.isArray,
   getFiberCurrentPropsFromNode$1 = null,
   getInstanceFromNode = null,
   getNodeFromInstance = null;
 function executeDispatch(event, listener, inst) {
-  var type = event.type || "unknown-event";
   event.currentTarget = getNodeFromInstance(inst);
-  invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event);
+  try {
+    listener(event);
+  } catch (error) {
+    hasError || ((hasError = !0), (caughtError = error));
+  }
   event.currentTarget = null;
 }
 function executeDirectDispatch(event) {
   var dispatchListener = event._dispatchListeners,
     dispatchInstance = event._dispatchInstances;
-  if (isArrayImpl(dispatchListener))
-    throw Error("executeDirectDispatch(...): Invalid `event`.");
+  if (isArrayImpl(dispatchListener)) throw Error("Invalid `event`.");
   event.currentTarget = dispatchListener
     ? getNodeFromInstance(dispatchInstance)
     : null;
@@ -340,9 +297,7 @@ var instrumentationCallback,
   };
 function accumulate(current, next) {
   if (null == next)
-    throw Error(
-      "accumulate(...): Accumulated items must not be null or undefined."
-    );
+    throw Error("Accumulated items must not be null or undefined.");
   return null == current
     ? next
     : isArrayImpl(current)
@@ -353,9 +308,7 @@ function accumulate(current, next) {
 }
 function accumulateInto(current, next) {
   if (null == next)
-    throw Error(
-      "accumulateInto(...): Accumulated items must not be null or undefined."
-    );
+    throw Error("Accumulated items must not be null or undefined.");
   if (null == current) return next;
   if (isArrayImpl(current)) {
     if (isArrayImpl(next)) return current.push.apply(current, next), current;
@@ -944,7 +897,7 @@ eventPluginOrder = Array.prototype.slice.call([
   "ReactNativeBridgeEventPlugin"
 ]);
 recomputePluginOrdering();
-var injectedNamesToPlugins$jscomp$inline_253 = {
+var injectedNamesToPlugins$jscomp$inline_249 = {
     ResponderEventPlugin: ResponderEventPlugin,
     ReactNativeBridgeEventPlugin: {
       eventTypes: {},
@@ -990,32 +943,32 @@ var injectedNamesToPlugins$jscomp$inline_253 = {
       }
     }
   },
-  isOrderingDirty$jscomp$inline_254 = !1,
-  pluginName$jscomp$inline_255;
-for (pluginName$jscomp$inline_255 in injectedNamesToPlugins$jscomp$inline_253)
+  isOrderingDirty$jscomp$inline_250 = !1,
+  pluginName$jscomp$inline_251;
+for (pluginName$jscomp$inline_251 in injectedNamesToPlugins$jscomp$inline_249)
   if (
-    injectedNamesToPlugins$jscomp$inline_253.hasOwnProperty(
-      pluginName$jscomp$inline_255
+    injectedNamesToPlugins$jscomp$inline_249.hasOwnProperty(
+      pluginName$jscomp$inline_251
     )
   ) {
-    var pluginModule$jscomp$inline_256 =
-      injectedNamesToPlugins$jscomp$inline_253[pluginName$jscomp$inline_255];
+    var pluginModule$jscomp$inline_252 =
+      injectedNamesToPlugins$jscomp$inline_249[pluginName$jscomp$inline_251];
     if (
-      !namesToPlugins.hasOwnProperty(pluginName$jscomp$inline_255) ||
-      namesToPlugins[pluginName$jscomp$inline_255] !==
-        pluginModule$jscomp$inline_256
+      !namesToPlugins.hasOwnProperty(pluginName$jscomp$inline_251) ||
+      namesToPlugins[pluginName$jscomp$inline_251] !==
+        pluginModule$jscomp$inline_252
     ) {
-      if (namesToPlugins[pluginName$jscomp$inline_255])
+      if (namesToPlugins[pluginName$jscomp$inline_251])
         throw Error(
           "EventPluginRegistry: Cannot inject two different event plugins using the same name, `" +
-            (pluginName$jscomp$inline_255 + "`.")
+            (pluginName$jscomp$inline_251 + "`.")
         );
-      namesToPlugins[pluginName$jscomp$inline_255] =
-        pluginModule$jscomp$inline_256;
-      isOrderingDirty$jscomp$inline_254 = !0;
+      namesToPlugins[pluginName$jscomp$inline_251] =
+        pluginModule$jscomp$inline_252;
+      isOrderingDirty$jscomp$inline_250 = !0;
     }
   }
-isOrderingDirty$jscomp$inline_254 && recomputePluginOrdering();
+isOrderingDirty$jscomp$inline_250 && recomputePluginOrdering();
 var instanceCache = new Map(),
   instanceProps = new Map();
 function getInstanceFromTag(tag) {
@@ -1091,11 +1044,11 @@ function _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam) {
         throw Error(
           "processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented."
         );
-      if (hasRethrowError)
+      if (hasError)
         throw (
-          ((JSCompiler_inline_result = rethrowError),
-          (hasRethrowError = !1),
-          (rethrowError = null),
+          ((JSCompiler_inline_result = caughtError),
+          (hasError = !1),
+          (caughtError = null),
           JSCompiler_inline_result)
         );
     }
@@ -1169,6 +1122,7 @@ var ReactSharedInternals =
   REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
   REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
   REACT_PROVIDER_TYPE = Symbol.for("react.provider"),
+  REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
   REACT_CONTEXT_TYPE = Symbol.for("react.context"),
   REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
   REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
@@ -1189,115 +1143,7 @@ function getIteratorFn(maybeIterable) {
     maybeIterable["@@iterator"];
   return "function" === typeof maybeIterable ? maybeIterable : null;
 }
-var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
-function getComponentNameFromType(type) {
-  if (null == type) return null;
-  if ("function" === typeof type)
-    return type.$$typeof === REACT_CLIENT_REFERENCE
-      ? null
-      : type.displayName || type.name || null;
-  if ("string" === typeof type) return type;
-  switch (type) {
-    case REACT_FRAGMENT_TYPE:
-      return "Fragment";
-    case REACT_PORTAL_TYPE:
-      return "Portal";
-    case REACT_PROFILER_TYPE:
-      return "Profiler";
-    case REACT_STRICT_MODE_TYPE:
-      return "StrictMode";
-    case REACT_SUSPENSE_TYPE:
-      return "Suspense";
-    case REACT_SUSPENSE_LIST_TYPE:
-      return "SuspenseList";
-  }
-  if ("object" === typeof type)
-    switch (type.$$typeof) {
-      case REACT_CONTEXT_TYPE:
-        return (type.displayName || "Context") + ".Consumer";
-      case REACT_PROVIDER_TYPE:
-        return (type._context.displayName || "Context") + ".Provider";
-      case REACT_FORWARD_REF_TYPE:
-        var innerType = type.render;
-        type = type.displayName;
-        type ||
-          ((type = innerType.displayName || innerType.name || ""),
-          (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));
-        return type;
-      case REACT_MEMO_TYPE:
-        return (
-          (innerType = type.displayName || null),
-          null !== innerType
-            ? innerType
-            : getComponentNameFromType(type.type) || "Memo"
-        );
-      case REACT_LAZY_TYPE:
-        innerType = type._payload;
-        type = type._init;
-        try {
-          return getComponentNameFromType(type(innerType));
-        } catch (x) {}
-    }
-  return null;
-}
-function getComponentNameFromFiber(fiber) {
-  var type = fiber.type;
-  switch (fiber.tag) {
-    case 24:
-      return "Cache";
-    case 9:
-      return (type.displayName || "Context") + ".Consumer";
-    case 10:
-      return (type._context.displayName || "Context") + ".Provider";
-    case 18:
-      return "DehydratedFragment";
-    case 11:
-      return (
-        (fiber = type.render),
-        (fiber = fiber.displayName || fiber.name || ""),
-        type.displayName ||
-          ("" !== fiber ? "ForwardRef(" + fiber + ")" : "ForwardRef")
-      );
-    case 7:
-      return "Fragment";
-    case 26:
-    case 27:
-    case 5:
-      return type;
-    case 4:
-      return "Portal";
-    case 3:
-      return "Root";
-    case 6:
-      return "Text";
-    case 16:
-      return getComponentNameFromType(type);
-    case 8:
-      return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
-    case 22:
-      return "Offscreen";
-    case 12:
-      return "Profiler";
-    case 21:
-      return "Scope";
-    case 13:
-      return "Suspense";
-    case 19:
-      return "SuspenseList";
-    case 25:
-      return "TracingMarker";
-    case 1:
-    case 0:
-    case 17:
-    case 2:
-    case 14:
-    case 15:
-      if ("function" === typeof type)
-        return type.displayName || type.name || null;
-      if ("string" === typeof type) return type;
-  }
-  return null;
-}
+Symbol.for("react.client.reference");
 function getNearestMountedFiber(fiber) {
   var node = fiber,
     nearestMounted = fiber;
@@ -1887,7 +1733,7 @@ function createLaneMap(initial) {
   for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
   return laneMap;
 }
-function markRootUpdated(root, updateLane) {
+function markRootUpdated$1(root, updateLane) {
   root.pendingLanes |= updateLane;
   268435456 !== updateLane &&
     ((root.suspendedLanes = 0), (root.pingedLanes = 0));
@@ -2028,18 +1874,7 @@ function getPublicInstance(instance) {
     : instance;
 }
 var scheduleTimeout = setTimeout,
-  cancelTimeout = clearTimeout;
-function describeComponentFrame(name, ownerName) {
-  var sourceInfo = "";
-  ownerName && (sourceInfo = " (created by " + ownerName + ")");
-  return "\n    in " + (name || "Unknown") + sourceInfo;
-}
-function describeFunctionComponentFrame(fn) {
-  return fn
-    ? describeComponentFrame(fn.displayName || fn.name || null, null)
-    : "";
-}
-var hasOwnProperty = Object.prototype.hasOwnProperty,
+  cancelTimeout = clearTimeout,
   valueStack = [],
   index = -1;
 function createCursor(defaultValue) {
@@ -2054,89 +1889,7 @@ function push(cursor, value) {
   valueStack[index] = cursor.current;
   cursor.current = value;
 }
-var emptyContextObject = {},
-  contextStackCursor$1 = createCursor(emptyContextObject),
-  didPerformWorkStackCursor = createCursor(!1),
-  previousContext = emptyContextObject;
-function getMaskedContext(workInProgress, unmaskedContext) {
-  var contextTypes = workInProgress.type.contextTypes;
-  if (!contextTypes) return emptyContextObject;
-  var instance = workInProgress.stateNode;
-  if (
-    instance &&
-    instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext
-  )
-    return instance.__reactInternalMemoizedMaskedChildContext;
-  var context = {},
-    key;
-  for (key in contextTypes) context[key] = unmaskedContext[key];
-  instance &&
-    ((workInProgress = workInProgress.stateNode),
-    (workInProgress.__reactInternalMemoizedUnmaskedChildContext =
-      unmaskedContext),
-    (workInProgress.__reactInternalMemoizedMaskedChildContext = context));
-  return context;
-}
-function isContextProvider(type) {
-  type = type.childContextTypes;
-  return null !== type && void 0 !== type;
-}
-function popContext() {
-  pop(didPerformWorkStackCursor);
-  pop(contextStackCursor$1);
-}
-function pushTopLevelContextObject(fiber, context, didChange) {
-  if (contextStackCursor$1.current !== emptyContextObject)
-    throw Error(
-      "Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue."
-    );
-  push(contextStackCursor$1, context);
-  push(didPerformWorkStackCursor, didChange);
-}
-function processChildContext(fiber, type, parentContext) {
-  var instance = fiber.stateNode;
-  type = type.childContextTypes;
-  if ("function" !== typeof instance.getChildContext) return parentContext;
-  instance = instance.getChildContext();
-  for (var contextKey in instance)
-    if (!(contextKey in type))
-      throw Error(
-        (getComponentNameFromFiber(fiber) || "Unknown") +
-          '.getChildContext(): key "' +
-          contextKey +
-          '" is not defined in childContextTypes.'
-      );
-  return assign({}, parentContext, instance);
-}
-function pushContextProvider(workInProgress) {
-  workInProgress =
-    ((workInProgress = workInProgress.stateNode) &&
-      workInProgress.__reactInternalMemoizedMergedChildContext) ||
-    emptyContextObject;
-  previousContext = contextStackCursor$1.current;
-  push(contextStackCursor$1, workInProgress);
-  push(didPerformWorkStackCursor, didPerformWorkStackCursor.current);
-  return !0;
-}
-function invalidateContextProvider(workInProgress, type, didChange) {
-  var instance = workInProgress.stateNode;
-  if (!instance)
-    throw Error(
-      "Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue."
-    );
-  didChange
-    ? ((workInProgress = processChildContext(
-        workInProgress,
-        type,
-        previousContext
-      )),
-      (instance.__reactInternalMemoizedMergedChildContext = workInProgress),
-      pop(didPerformWorkStackCursor),
-      pop(contextStackCursor$1),
-      push(contextStackCursor$1, workInProgress))
-    : pop(didPerformWorkStackCursor);
-  push(didPerformWorkStackCursor, didChange);
-}
+var emptyContextObject = {};
 function is(x, y) {
   return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
 }
@@ -2345,6 +2098,7 @@ function flushSyncWorkAcrossRoots_impl(onlyLegacy) {
                       workInProgressRootRenderLanes$13,
                       workInProgressRootRecoverableErrors,
                       workInProgressTransitions,
+                      workInProgressRootDidIncludeRecursiveRenderUpdate,
                       workInProgressDeferredLane
                     ));
               }
@@ -2699,6 +2453,7 @@ function commitCallbacks(updateQueue, context) {
     )
       callCallback(callbacks[updateQueue], context);
 }
+var hasOwnProperty = Object.prototype.hasOwnProperty;
 function shallowEqual(objA, objB) {
   if (objectIs(objA, objB)) return !0;
   if (
@@ -2721,6 +2476,16 @@ function shallowEqual(objA, objB) {
   }
   return !0;
 }
+function describeComponentFrame(name, ownerName) {
+  var sourceInfo = "";
+  ownerName && (sourceInfo = " (created by " + ownerName + ")");
+  return "\n    in " + (name || "Unknown") + sourceInfo;
+}
+function describeFunctionComponentFrame(fn) {
+  return fn
+    ? describeComponentFrame(fn.displayName || fn.name || null, null)
+    : "";
+}
 function describeFiber(fiber) {
   switch (fiber.tag) {
     case 26:
@@ -2809,16 +2574,16 @@ function trackUsedThenable(thenableState, thenable, index) {
             }
           }
         );
-        switch (thenable.status) {
-          case "fulfilled":
-            return thenable.value;
-          case "rejected":
-            throw (
-              ((thenableState = thenable.reason),
-              checkIfUseWrappedInAsyncCatch(thenableState),
-              thenableState)
-            );
-        }
+      }
+      switch (thenable.status) {
+        case "fulfilled":
+          return thenable.value;
+        case "rejected":
+          throw (
+            ((thenableState = thenable.reason),
+            checkIfUseWrappedInAsyncCatch(thenableState),
+            thenableState)
+          );
       }
       suspendedThenable = thenable;
       throw SuspenseException;
@@ -2848,56 +2613,54 @@ function unwrapThenable(thenable) {
   null === thenableState$1 && (thenableState$1 = []);
   return trackUsedThenable(thenableState$1, thenable, index);
 }
-function coerceRef(returnFiber, current, element) {
-  returnFiber = element.ref;
-  if (
-    null !== returnFiber &&
-    "function" !== typeof returnFiber &&
-    "object" !== typeof returnFiber
-  ) {
-    if (element._owner) {
-      element = element._owner;
-      if (element) {
-        if (1 !== element.tag)
-          throw Error(
-            "Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref"
-          );
-        var inst = element.stateNode;
-      }
-      if (!inst)
-        throw Error(
-          "Missing owner for string ref " +
-            returnFiber +
-            ". This error is likely caused by a bug in React. Please file an issue."
-        );
-      var resolvedInst = inst,
-        stringRef = "" + returnFiber;
-      if (
-        null !== current &&
-        null !== current.ref &&
-        "function" === typeof current.ref &&
-        current.ref._stringRef === stringRef
-      )
-        return current.ref;
-      current = function (value) {
-        var refs = resolvedInst.refs;
-        null === value ? delete refs[stringRef] : (refs[stringRef] = value);
-      };
-      current._stringRef = stringRef;
-      return current;
-    }
-    if ("string" !== typeof returnFiber)
-      throw Error(
-        "Expected ref to be a function, a string, an object returned by React.createRef(), or null."
-      );
-    if (!element._owner)
-      throw Error(
-        "Element ref was specified as a string (" +
-          returnFiber +
-          ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information."
-      );
+function convertStringRefToCallbackRef(
+  returnFiber,
+  current,
+  element,
+  mixedRef
+) {
+  function ref(value) {
+    var refs = inst.refs;
+    null === value ? delete refs[stringRef] : (refs[stringRef] = value);
   }
-  return returnFiber;
+  var stringRef = "" + mixedRef;
+  returnFiber = element._owner;
+  if (!returnFiber)
+    throw Error(
+      "Element ref was specified as a string (" +
+        stringRef +
+        ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://react.dev/link/refs-must-have-owner for more information."
+    );
+  if (1 !== returnFiber.tag)
+    throw Error(
+      "Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://react.dev/link/strict-mode-string-ref"
+    );
+  var inst = returnFiber.stateNode;
+  if (!inst)
+    throw Error(
+      "Missing owner for string ref " +
+        stringRef +
+        ". This error is likely caused by a bug in React. Please file an issue."
+    );
+  if (
+    null !== current &&
+    null !== current.ref &&
+    "function" === typeof current.ref &&
+    current.ref._stringRef === stringRef
+  )
+    return current.ref;
+  ref._stringRef = stringRef;
+  return ref;
+}
+function coerceRef(returnFiber, current, workInProgress, element) {
+  var mixedRef = element.ref;
+  returnFiber =
+    "string" === typeof mixedRef ||
+    "number" === typeof mixedRef ||
+    "boolean" === typeof mixedRef
+      ? convertStringRefToCallbackRef(returnFiber, current, element, mixedRef)
+      : mixedRef;
+  workInProgress.ref = returnFiber;
 }
 function throwOnInvalidObjectType(returnFiber, newChild) {
   returnFiber = Object.prototype.toString.call(newChild);
@@ -2929,13 +2692,13 @@ function createChildReconciler(shouldTrackSideEffects) {
         (currentFirstChild = currentFirstChild.sibling);
     return null;
   }
-  function mapRemainingChildren(returnFiber, currentFirstChild) {
-    for (returnFiber = new Map(); null !== currentFirstChild; )
+  function mapRemainingChildren(currentFirstChild) {
+    for (var existingChildren = new Map(); null !== currentFirstChild; )
       null !== currentFirstChild.key
-        ? returnFiber.set(currentFirstChild.key, currentFirstChild)
-        : returnFiber.set(currentFirstChild.index, currentFirstChild),
+        ? existingChildren.set(currentFirstChild.key, currentFirstChild)
+        : existingChildren.set(currentFirstChild.index, currentFirstChild),
         (currentFirstChild = currentFirstChild.sibling);
-    return returnFiber;
+    return existingChildren;
   }
   function useFiber(fiber, pendingProps) {
     fiber = createWorkInProgress(fiber, pendingProps);
@@ -2995,7 +2758,7 @@ function createChildReconciler(shouldTrackSideEffects) {
     )
       return (
         (lanes = useFiber(current, element.props)),
-        (lanes.ref = coerceRef(returnFiber, current, element)),
+        coerceRef(returnFiber, current, lanes, element),
         (lanes.return = returnFiber),
         lanes
       );
@@ -3007,7 +2770,7 @@ function createChildReconciler(shouldTrackSideEffects) {
       returnFiber.mode,
       lanes
     );
-    lanes.ref = coerceRef(returnFiber, current, element);
+    coerceRef(returnFiber, current, lanes, element);
     lanes.return = returnFiber;
     return lanes;
   }
@@ -3069,7 +2832,7 @@ function createChildReconciler(shouldTrackSideEffects) {
               returnFiber.mode,
               lanes
             )),
-            (lanes.ref = coerceRef(returnFiber, null, newChild)),
+            coerceRef(returnFiber, null, lanes, newChild),
             (lanes.return = returnFiber),
             lanes
           );
@@ -3103,7 +2866,7 @@ function createChildReconciler(shouldTrackSideEffects) {
       if (newChild.$$typeof === REACT_CONTEXT_TYPE)
         return createChild(
           returnFiber,
-          readContextDuringReconcilation(returnFiber, newChild, lanes),
+          readContextDuringReconciliation(returnFiber, newChild, lanes),
           lanes
         );
       throwOnInvalidObjectType(returnFiber, newChild);
@@ -3150,7 +2913,7 @@ function createChildReconciler(shouldTrackSideEffects) {
         return updateSlot(
           returnFiber,
           oldFiber,
-          readContextDuringReconcilation(returnFiber, newChild, lanes),
+          readContextDuringReconciliation(returnFiber, newChild, lanes),
           lanes
         );
       throwOnInvalidObjectType(returnFiber, newChild);
@@ -3218,7 +2981,7 @@ function createChildReconciler(shouldTrackSideEffects) {
           existingChildren,
           returnFiber,
           newIdx,
-          readContextDuringReconcilation(returnFiber, newChild, lanes),
+          readContextDuringReconciliation(returnFiber, newChild, lanes),
           lanes
         );
       throwOnInvalidObjectType(returnFiber, newChild);
@@ -3284,7 +3047,7 @@ function createChildReconciler(shouldTrackSideEffects) {
       return resultingFirstChild;
     }
     for (
-      oldFiber = mapRemainingChildren(returnFiber, oldFiber);
+      oldFiber = mapRemainingChildren(oldFiber);
       newIdx < newChildren.length;
       newIdx++
     )
@@ -3372,7 +3135,7 @@ function createChildReconciler(shouldTrackSideEffects) {
       return iteratorFn;
     }
     for (
-      oldFiber = mapRemainingChildren(returnFiber, oldFiber);
+      oldFiber = mapRemainingChildren(oldFiber);
       !step.done;
       newIdx++, step = newChildrenIterable.next()
     )
@@ -3434,11 +3197,7 @@ function createChildReconciler(shouldTrackSideEffects) {
                 ) {
                   deleteRemainingChildren(returnFiber, child.sibling);
                   currentFirstChild = useFiber(child, newChild.props);
-                  currentFirstChild.ref = coerceRef(
-                    returnFiber,
-                    child,
-                    newChild
-                  );
+                  coerceRef(returnFiber, child, currentFirstChild, newChild);
                   currentFirstChild.return = returnFiber;
                   returnFiber = currentFirstChild;
                   break a;
@@ -3465,11 +3224,7 @@ function createChildReconciler(shouldTrackSideEffects) {
                   returnFiber.mode,
                   lanes
                 )),
-                (lanes.ref = coerceRef(
-                  returnFiber,
-                  currentFirstChild,
-                  newChild
-                )),
+                coerceRef(returnFiber, currentFirstChild, lanes, newChild),
                 (lanes.return = returnFiber),
                 (returnFiber = lanes));
           }
@@ -3515,7 +3270,7 @@ function createChildReconciler(shouldTrackSideEffects) {
         case REACT_LAZY_TYPE:
           return (
             (child = newChild._init),
-            reconcileChildFibers(
+            reconcileChildFibersImpl(
               returnFiber,
               currentFirstChild,
               child(newChild._payload),
@@ -3548,7 +3303,7 @@ function createChildReconciler(shouldTrackSideEffects) {
         return reconcileChildFibersImpl(
           returnFiber,
           currentFirstChild,
-          readContextDuringReconcilation(returnFiber, newChild, lanes),
+          readContextDuringReconciliation(returnFiber, newChild, lanes),
           lanes
         );
       throwOnInvalidObjectType(returnFiber, newChild);
@@ -3572,12 +3327,7 @@ function createChildReconciler(shouldTrackSideEffects) {
         placeSingleChild(returnFiber))
       : deleteRemainingChildren(returnFiber, currentFirstChild);
   }
-  function reconcileChildFibers(
-    returnFiber,
-    currentFirstChild,
-    newChild,
-    lanes
-  ) {
+  return function (returnFiber, currentFirstChild, newChild, lanes) {
     thenableIndexCounter$1 = 0;
     returnFiber = reconcileChildFibersImpl(
       returnFiber,
@@ -3587,8 +3337,7 @@ function createChildReconciler(shouldTrackSideEffects) {
     );
     thenableState$1 = null;
     return returnFiber;
-  }
-  return reconcileChildFibers;
+  };
 }
 var reconcileChildFibers = createChildReconciler(!0),
   mountChildFibers = createChildReconciler(!1),
@@ -3681,7 +3430,7 @@ var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher,
   globalClientIdCounter = 0;
 function throwInvalidHookError() {
   throw Error(
-    "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem."
+    "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
   );
 }
 function areHookInputsEqual(nextDeps, prevDeps) {
@@ -4632,30 +4381,17 @@ function checkShouldComponentUpdate(
     : !0;
 }
 function constructClassInstance(workInProgress, ctor, props) {
-  var isLegacyContextConsumer = !1,
-    unmaskedContext = emptyContextObject;
-  var context = ctor.contextType;
-  "object" === typeof context && null !== context
-    ? (context = readContext(context))
-    : ((unmaskedContext = isContextProvider(ctor)
-        ? previousContext
-        : contextStackCursor$1.current),
-      (isLegacyContextConsumer = ctor.contextTypes),
-      (context = (isLegacyContextConsumer =
-        null !== isLegacyContextConsumer && void 0 !== isLegacyContextConsumer)
-        ? getMaskedContext(workInProgress, unmaskedContext)
-        : emptyContextObject));
+  var context = emptyContextObject,
+    contextType = ctor.contextType;
+  "object" === typeof contextType &&
+    null !== contextType &&
+    (context = readContext(contextType));
   ctor = new ctor(props, context);
   workInProgress.memoizedState =
     null !== ctor.state && void 0 !== ctor.state ? ctor.state : null;
   ctor.updater = classComponentUpdater;
   workInProgress.stateNode = ctor;
   ctor._reactInternals = workInProgress;
-  isLegacyContextConsumer &&
-    ((workInProgress = workInProgress.stateNode),
-    (workInProgress.__reactInternalMemoizedUnmaskedChildContext =
-      unmaskedContext),
-    (workInProgress.__reactInternalMemoizedMaskedChildContext = context));
   return ctor;
 }
 function callComponentWillReceiveProps(
@@ -4679,12 +4415,10 @@ function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {
   instance.refs = {};
   initializeUpdateQueue(workInProgress);
   var contextType = ctor.contextType;
-  "object" === typeof contextType && null !== contextType
-    ? (instance.context = readContext(contextType))
-    : ((contextType = isContextProvider(ctor)
-        ? previousContext
-        : contextStackCursor$1.current),
-      (instance.context = getMaskedContext(workInProgress, contextType)));
+  instance.context =
+    "object" === typeof contextType && null !== contextType
+      ? readContext(contextType)
+      : emptyContextObject;
   instance.state = workInProgress.memoizedState;
   contextType = ctor.getDerivedStateFromProps;
   "function" === typeof contextType &&
@@ -4706,12 +4440,23 @@ function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {
   "function" === typeof instance.componentDidMount &&
     (workInProgress.flags |= 4194308);
 }
+var CapturedStacks = new WeakMap();
 function createCapturedValueAtFiber(value, source) {
+  if ("object" === typeof value && null !== value) {
+    var stack = CapturedStacks.get(value);
+    "string" !== typeof stack &&
+      ((stack = getStackByFiberInDevAndProd(source)),
+      CapturedStacks.set(value, stack));
+  } else stack = getStackByFiberInDevAndProd(source);
+  return { value: value, source: source, stack: stack, digest: null };
+}
+function createCapturedValueFromError(value, digest, stack) {
+  "string" === typeof stack && CapturedStacks.set(value, stack);
   return {
     value: value,
-    source: source,
-    stack: getStackByFiberInDevAndProd(source),
-    digest: null
+    source: null,
+    stack: null != stack ? stack : null,
+    digest: null != digest ? digest : null
   };
 }
 if (
@@ -5058,7 +4803,7 @@ function updateOffscreenComponent(current, workInProgress, renderLanes) {
     nextChildren = nextProps.children,
     nextIsDetached = 0 !== (workInProgress.stateNode._pendingVisibility & 2),
     prevState = null !== current ? current.memoizedState : null;
-  markRef$1(current, workInProgress);
+  markRef(current, workInProgress);
   if ("hidden" === nextProps.mode || nextIsDetached) {
     if (0 !== (workInProgress.flags & 128)) {
       renderLanes =
@@ -5112,13 +4857,20 @@ function deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes) {
   pushOffscreenSuspenseHandler(workInProgress);
   return null;
 }
-function markRef$1(current, workInProgress) {
+function markRef(current, workInProgress) {
   var ref = workInProgress.ref;
-  if (
-    (null === current && null !== ref) ||
-    (null !== current && current.ref !== ref)
-  )
-    (workInProgress.flags |= 512), (workInProgress.flags |= 2097152);
+  if (null === ref)
+    null !== current &&
+      null !== current.ref &&
+      (workInProgress.flags |= 2097664);
+  else {
+    if ("function" !== typeof ref && "object" !== typeof ref)
+      throw Error(
+        "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
+      );
+    if (null === current || current.ref !== ref)
+      workInProgress.flags |= 2097664;
+  }
 }
 function updateFunctionComponent(
   current,
@@ -5127,17 +4879,13 @@ function updateFunctionComponent(
   nextProps,
   renderLanes
 ) {
-  var context = isContextProvider(Component)
-    ? previousContext
-    : contextStackCursor$1.current;
-  context = getMaskedContext(workInProgress, context);
   prepareToReadContext(workInProgress, renderLanes);
   Component = renderWithHooks(
     current,
     workInProgress,
     Component,
     nextProps,
-    context,
+    void 0,
     renderLanes
   );
   if (null !== current && !didReceiveUpdate)
@@ -5181,10 +4929,6 @@ function updateClassComponent(
   nextProps,
   renderLanes
 ) {
-  if (isContextProvider(Component)) {
-    var hasContext = !0;
-    pushContextProvider(workInProgress);
-  } else hasContext = !1;
   prepareToReadContext(workInProgress, renderLanes);
   if (null === workInProgress.stateNode)
     resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress),
@@ -5196,36 +4940,30 @@ function updateClassComponent(
       oldProps = workInProgress.memoizedProps;
     instance.props = oldProps;
     var oldContext = instance.context,
-      contextType = Component.contextType;
-    "object" === typeof contextType && null !== contextType
-      ? (contextType = readContext(contextType))
-      : ((contextType = isContextProvider(Component)
-          ? previousContext
-          : contextStackCursor$1.current),
-        (contextType = getMaskedContext(workInProgress, contextType)));
-    var getDerivedStateFromProps = Component.getDerivedStateFromProps,
-      hasNewLifecycles =
-        "function" === typeof getDerivedStateFromProps ||
-        "function" === typeof instance.getSnapshotBeforeUpdate;
-    hasNewLifecycles ||
+      contextType = Component.contextType,
+      nextContext = emptyContextObject;
+    "object" === typeof contextType &&
+      null !== contextType &&
+      (nextContext = readContext(contextType));
+    var getDerivedStateFromProps = Component.getDerivedStateFromProps;
+    (contextType =
+      "function" === typeof getDerivedStateFromProps ||
+      "function" === typeof instance.getSnapshotBeforeUpdate) ||
       ("function" !== typeof instance.UNSAFE_componentWillReceiveProps &&
         "function" !== typeof instance.componentWillReceiveProps) ||
-      ((oldProps !== nextProps || oldContext !== contextType) &&
+      ((oldProps !== nextProps || oldContext !== nextContext) &&
         callComponentWillReceiveProps(
           workInProgress,
           instance,
           nextProps,
-          contextType
+          nextContext
         ));
     hasForceUpdate = !1;
     var oldState = workInProgress.memoizedState;
     instance.state = oldState;
     processUpdateQueue(workInProgress, nextProps, instance, renderLanes);
     oldContext = workInProgress.memoizedState;
-    oldProps !== nextProps ||
-    oldState !== oldContext ||
-    didPerformWorkStackCursor.current ||
-    hasForceUpdate
+    oldProps !== nextProps || oldState !== oldContext || hasForceUpdate
       ? ("function" === typeof getDerivedStateFromProps &&
           (applyDerivedStateFromProps(
             workInProgress,
@@ -5243,9 +4981,9 @@ function updateClassComponent(
             nextProps,
             oldState,
             oldContext,
-            contextType
+            nextContext
           ))
-          ? (hasNewLifecycles ||
+          ? (contextType ||
               ("function" !== typeof instance.UNSAFE_componentWillMount &&
                 "function" !== typeof instance.componentWillMount) ||
               ("function" === typeof instance.componentWillMount &&
@@ -5260,7 +4998,7 @@ function updateClassComponent(
             (workInProgress.memoizedState = oldContext)),
         (instance.props = nextProps),
         (instance.state = oldContext),
-        (instance.context = contextType),
+        (instance.context = nextContext),
         (nextProps = oldProps))
       : ("function" === typeof instance.componentDidMount &&
           (workInProgress.flags |= 4194308),
@@ -5268,48 +5006,46 @@ function updateClassComponent(
   } else {
     instance = workInProgress.stateNode;
     cloneUpdateQueue(current, workInProgress);
-    oldProps = workInProgress.memoizedProps;
+    nextContext = workInProgress.memoizedProps;
     contextType =
       workInProgress.type === workInProgress.elementType
-        ? oldProps
-        : resolveDefaultProps(workInProgress.type, oldProps);
+        ? nextContext
+        : resolveDefaultProps(workInProgress.type, nextContext);
     instance.props = contextType;
-    hasNewLifecycles = workInProgress.pendingProps;
-    oldState = instance.context;
+    getDerivedStateFromProps = workInProgress.pendingProps;
+    var oldContext$jscomp$0 = instance.context;
     oldContext = Component.contextType;
-    "object" === typeof oldContext && null !== oldContext
-      ? (oldContext = readContext(oldContext))
-      : ((oldContext = isContextProvider(Component)
-          ? previousContext
-          : contextStackCursor$1.current),
-        (oldContext = getMaskedContext(workInProgress, oldContext)));
-    var getDerivedStateFromProps$jscomp$0 = Component.getDerivedStateFromProps;
-    (getDerivedStateFromProps =
-      "function" === typeof getDerivedStateFromProps$jscomp$0 ||
+    oldProps = emptyContextObject;
+    "object" === typeof oldContext &&
+      null !== oldContext &&
+      (oldProps = readContext(oldContext));
+    oldState = Component.getDerivedStateFromProps;
+    (oldContext =
+      "function" === typeof oldState ||
       "function" === typeof instance.getSnapshotBeforeUpdate) ||
       ("function" !== typeof instance.UNSAFE_componentWillReceiveProps &&
         "function" !== typeof instance.componentWillReceiveProps) ||
-      ((oldProps !== hasNewLifecycles || oldState !== oldContext) &&
+      ((nextContext !== getDerivedStateFromProps ||
+        oldContext$jscomp$0 !== oldProps) &&
         callComponentWillReceiveProps(
           workInProgress,
           instance,
           nextProps,
-          oldContext
+          oldProps
         ));
     hasForceUpdate = !1;
-    oldState = workInProgress.memoizedState;
-    instance.state = oldState;
+    oldContext$jscomp$0 = workInProgress.memoizedState;
+    instance.state = oldContext$jscomp$0;
     processUpdateQueue(workInProgress, nextProps, instance, renderLanes);
     var newState = workInProgress.memoizedState;
-    oldProps !== hasNewLifecycles ||
-    oldState !== newState ||
-    didPerformWorkStackCursor.current ||
+    nextContext !== getDerivedStateFromProps ||
+    oldContext$jscomp$0 !== newState ||
     hasForceUpdate
-      ? ("function" === typeof getDerivedStateFromProps$jscomp$0 &&
+      ? ("function" === typeof oldState &&
           (applyDerivedStateFromProps(
             workInProgress,
             Component,
-            getDerivedStateFromProps$jscomp$0,
+            oldState,
             nextProps
           ),
           (newState = workInProgress.memoizedState)),
@@ -5320,47 +5056,47 @@ function updateClassComponent(
             Component,
             contextType,
             nextProps,
-            oldState,
+            oldContext$jscomp$0,
             newState,
-            oldContext
+            oldProps
           ) ||
           !1)
-          ? (getDerivedStateFromProps ||
+          ? (oldContext ||
               ("function" !== typeof instance.UNSAFE_componentWillUpdate &&
                 "function" !== typeof instance.componentWillUpdate) ||
               ("function" === typeof instance.componentWillUpdate &&
-                instance.componentWillUpdate(nextProps, newState, oldContext),
+                instance.componentWillUpdate(nextProps, newState, oldProps),
               "function" === typeof instance.UNSAFE_componentWillUpdate &&
                 instance.UNSAFE_componentWillUpdate(
                   nextProps,
                   newState,
-                  oldContext
+                  oldProps
                 )),
             "function" === typeof instance.componentDidUpdate &&
               (workInProgress.flags |= 4),
             "function" === typeof instance.getSnapshotBeforeUpdate &&
               (workInProgress.flags |= 1024))
           : ("function" !== typeof instance.componentDidUpdate ||
-              (oldProps === current.memoizedProps &&
-                oldState === current.memoizedState) ||
+              (nextContext === current.memoizedProps &&
+                oldContext$jscomp$0 === current.memoizedState) ||
               (workInProgress.flags |= 4),
             "function" !== typeof instance.getSnapshotBeforeUpdate ||
-              (oldProps === current.memoizedProps &&
-                oldState === current.memoizedState) ||
+              (nextContext === current.memoizedProps &&
+                oldContext$jscomp$0 === current.memoizedState) ||
               (workInProgress.flags |= 1024),
             (workInProgress.memoizedProps = nextProps),
             (workInProgress.memoizedState = newState)),
         (instance.props = nextProps),
         (instance.state = newState),
-        (instance.context = oldContext),
+        (instance.context = oldProps),
         (nextProps = contextType))
       : ("function" !== typeof instance.componentDidUpdate ||
-          (oldProps === current.memoizedProps &&
-            oldState === current.memoizedState) ||
+          (nextContext === current.memoizedProps &&
+            oldContext$jscomp$0 === current.memoizedState) ||
           (workInProgress.flags |= 4),
         "function" !== typeof instance.getSnapshotBeforeUpdate ||
-          (oldProps === current.memoizedProps &&
-            oldState === current.memoizedState) ||
+          (nextContext === current.memoizedProps &&
+            oldContext$jscomp$0 === current.memoizedState) ||
           (workInProgress.flags |= 1024),
         (nextProps = !1));
   }
@@ -5369,7 +5105,7 @@ function updateClassComponent(
     workInProgress,
     Component,
     nextProps,
-    hasContext,
+    !1,
     renderLanes
   );
 }
@@ -5381,26 +5117,18 @@ function finishClassComponent(
   hasContext,
   renderLanes
 ) {
-  markRef$1(current, workInProgress);
-  var didCaptureError = 0 !== (workInProgress.flags & 128);
-  if (!shouldUpdate && !didCaptureError)
-    return (
-      hasContext && invalidateContextProvider(workInProgress, Component, !1),
-      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
-    );
+  markRef(current, workInProgress);
+  hasContext = 0 !== (workInProgress.flags & 128);
+  if (!shouldUpdate && !hasContext)
+    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
   shouldUpdate = workInProgress.stateNode;
   ReactCurrentOwner$1.current = workInProgress;
-  if (
-    didCaptureError &&
-    "function" !== typeof Component.getDerivedStateFromError
-  ) {
-    var nextChildren = null;
-    profilerStartTime = -1;
-  } else nextChildren = shouldUpdate.render();
+  hasContext && "function" !== typeof Component.getDerivedStateFromError
+    ? ((Component = null), (profilerStartTime = -1))
+    : (Component = shouldUpdate.render());
   workInProgress.flags |= 1;
-  null !== current && didCaptureError
-    ? ((didCaptureError = nextChildren),
-      (workInProgress.child = reconcileChildFibers(
+  null !== current && hasContext
+    ? ((workInProgress.child = reconcileChildFibers(
         workInProgress,
         current.child,
         null,
@@ -5409,26 +5137,13 @@ function finishClassComponent(
       (workInProgress.child = reconcileChildFibers(
         workInProgress,
         null,
-        didCaptureError,
+        Component,
         renderLanes
       )))
-    : reconcileChildren(current, workInProgress, nextChildren, renderLanes);
+    : reconcileChildren(current, workInProgress, Component, renderLanes);
   workInProgress.memoizedState = shouldUpdate.state;
-  hasContext && invalidateContextProvider(workInProgress, Component, !0);
   return workInProgress.child;
 }
-function pushHostRootContext(workInProgress) {
-  var root = workInProgress.stateNode;
-  root.pendingContext
-    ? pushTopLevelContextObject(
-        workInProgress,
-        root.pendingContext,
-        root.pendingContext !== root.context
-      )
-    : root.context &&
-      pushTopLevelContextObject(workInProgress, root.context, !1);
-  pushHostContainer(workInProgress, root.containerInfo);
-}
 var SUSPENDED_MARKER = { dehydrated: null, treeContext: null, retryLane: 0 };
 function mountSuspenseOffscreenState(renderLanes) {
   return { baseLanes: renderLanes, cachePool: null };
@@ -5632,18 +5347,16 @@ function updateDehydratedSuspenseComponent(
       return (
         pushPrimaryTreeSuspenseHandler(workInProgress),
         (workInProgress.flags &= -257),
+        (didPrimaryChildrenDefer = createCapturedValueFromError(
+          Error(
+            "There was an error while hydrating this Suspense boundary. Switched to client rendering."
+          )
+        )),
         retrySuspenseComponentWithoutHydrating(
           current,
           workInProgress,
           renderLanes,
-          {
-            value: Error(
-              "There was an error while hydrating this Suspense boundary. Switched to client rendering."
-            ),
-            source: null,
-            stack: null,
-            digest: null
-          }
+          didPrimaryChildrenDefer
         )
       );
     if (null !== workInProgress.memoizedState)
@@ -5700,17 +5413,16 @@ function updateDehydratedSuspenseComponent(
         "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."
       )),
       (suspenseState.digest = didPrimaryChildrenDefer),
+      (didPrimaryChildrenDefer = createCapturedValueFromError(
+        suspenseState,
+        didPrimaryChildrenDefer,
+        void 0
+      )),
       retrySuspenseComponentWithoutHydrating(
         current,
         workInProgress,
         renderLanes,
-        {
-          value: suspenseState,
-          source: null,
-          stack: null,
-          digest:
-            null != didPrimaryChildrenDefer ? didPrimaryChildrenDefer : null
-        }
+        didPrimaryChildrenDefer
       )
     );
   didPrimaryChildrenDefer = 0 !== (renderLanes & current.childLanes);
@@ -5941,36 +5653,32 @@ function attemptEarlyBailoutIfNoScheduledUpdate(
 ) {
   switch (workInProgress.tag) {
     case 3:
-      pushHostRootContext(workInProgress);
+      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
       break;
     case 27:
     case 5:
       pushHostContext(workInProgress);
       break;
-    case 1:
-      isContextProvider(workInProgress.type) &&
-        pushContextProvider(workInProgress);
-      break;
     case 4:
       pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
       break;
     case 10:
-      var context = workInProgress.type._context,
-        nextValue = workInProgress.memoizedProps.value;
+      var newValue = workInProgress.memoizedProps.value,
+        context = workInProgress.type._context;
       push(valueCursor, context._currentValue);
-      context._currentValue = nextValue;
+      context._currentValue = newValue;
       break;
     case 12:
       0 !== (renderLanes & workInProgress.childLanes) &&
         (workInProgress.flags |= 4);
-      context = workInProgress.stateNode;
-      context.effectDuration = 0;
-      context.passiveEffectDuration = 0;
+      newValue = workInProgress.stateNode;
+      newValue.effectDuration = 0;
+      newValue.passiveEffectDuration = 0;
       break;
     case 13:
-      context = workInProgress.memoizedState;
-      if (null !== context) {
-        if (null !== context.dehydrated)
+      newValue = workInProgress.memoizedState;
+      if (null !== newValue) {
+        if (null !== newValue.dehydrated)
           return (
             pushPrimaryTreeSuspenseHandler(workInProgress),
             (workInProgress.flags |= 128),
@@ -5989,9 +5697,9 @@ function attemptEarlyBailoutIfNoScheduledUpdate(
       pushPrimaryTreeSuspenseHandler(workInProgress);
       break;
     case 19:
-      context = 0 !== (renderLanes & workInProgress.childLanes);
+      newValue = 0 !== (renderLanes & workInProgress.childLanes);
       if (0 !== (current.flags & 128)) {
-        if (context)
+        if (newValue)
           return updateSuspenseListComponent(
             current,
             workInProgress,
@@ -5999,13 +5707,13 @@ function attemptEarlyBailoutIfNoScheduledUpdate(
           );
         workInProgress.flags |= 128;
       }
-      nextValue = workInProgress.memoizedState;
-      null !== nextValue &&
-        ((nextValue.rendering = null),
-        (nextValue.tail = null),
-        (nextValue.lastEffect = null));
+      context = workInProgress.memoizedState;
+      null !== context &&
+        ((context.rendering = null),
+        (context.tail = null),
+        (context.lastEffect = null));
       push(suspenseStackCursor, suspenseStackCursor.current);
-      if (context) break;
+      if (newValue) break;
       else return null;
     case 22:
     case 23:
@@ -6016,3637 +5724,3608 @@ function attemptEarlyBailoutIfNoScheduledUpdate(
   }
   return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
 }
-var valueCursor = createCursor(null),
-  currentlyRenderingFiber = null,
-  lastContextDependency = null,
-  lastFullyObservedContext = null;
-function resetContextDependencies() {
-  lastFullyObservedContext =
-    lastContextDependency =
-    currentlyRenderingFiber =
-      null;
-}
-function popProvider(context) {
-  context._currentValue = valueCursor.current;
-  pop(valueCursor);
-}
-function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {
-  for (; null !== parent; ) {
-    var alternate = parent.alternate;
-    (parent.childLanes & renderLanes) !== renderLanes
-      ? ((parent.childLanes |= renderLanes),
-        null !== alternate && (alternate.childLanes |= renderLanes))
-      : null !== alternate &&
-        (alternate.childLanes & renderLanes) !== renderLanes &&
-        (alternate.childLanes |= renderLanes);
-    if (parent === propagationRoot) break;
-    parent = parent.return;
-  }
-}
-function prepareToReadContext(workInProgress, renderLanes) {
-  currentlyRenderingFiber = workInProgress;
-  lastFullyObservedContext = lastContextDependency = null;
-  workInProgress = workInProgress.dependencies;
-  null !== workInProgress &&
-    null !== workInProgress.firstContext &&
-    (0 !== (workInProgress.lanes & renderLanes) && (didReceiveUpdate = !0),
-    (workInProgress.firstContext = null));
-}
-function readContext(context) {
-  return readContextForConsumer(currentlyRenderingFiber, context);
-}
-function readContextDuringReconcilation(consumer, context, renderLanes) {
-  null === currentlyRenderingFiber &&
-    prepareToReadContext(consumer, renderLanes);
-  return readContextForConsumer(consumer, context);
-}
-function readContextForConsumer(consumer, context) {
-  var value = context._currentValue;
-  if (lastFullyObservedContext !== context)
-    if (
-      ((context = { context: context, memoizedValue: value, next: null }),
-      null === lastContextDependency)
-    ) {
-      if (null === consumer)
-        throw Error(
-          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
+function beginWork(current, workInProgress, renderLanes) {
+  if (null !== current)
+    if (current.memoizedProps !== workInProgress.pendingProps)
+      didReceiveUpdate = !0;
+    else {
+      if (
+        0 === (current.lanes & renderLanes) &&
+        0 === (workInProgress.flags & 128)
+      )
+        return (
+          (didReceiveUpdate = !1),
+          attemptEarlyBailoutIfNoScheduledUpdate(
+            current,
+            workInProgress,
+            renderLanes
+          )
         );
-      lastContextDependency = context;
-      consumer.dependencies = { lanes: 0, firstContext: context };
-    } else lastContextDependency = lastContextDependency.next = context;
-  return value;
-}
-var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
-function handleAsyncAction() {}
-function scheduleRetryEffect(workInProgress, retryQueue) {
-  null !== retryQueue
-    ? (workInProgress.flags |= 4)
-    : workInProgress.flags & 16384 &&
-      ((retryQueue =
-        22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),
-      (workInProgress.lanes |= retryQueue));
-}
-function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
-  switch (renderState.tailMode) {
-    case "hidden":
-      hasRenderedATailFallback = renderState.tail;
-      for (var lastTailNode = null; null !== hasRenderedATailFallback; )
-        null !== hasRenderedATailFallback.alternate &&
-          (lastTailNode = hasRenderedATailFallback),
-          (hasRenderedATailFallback = hasRenderedATailFallback.sibling);
-      null === lastTailNode
-        ? (renderState.tail = null)
-        : (lastTailNode.sibling = null);
-      break;
-    case "collapsed":
-      lastTailNode = renderState.tail;
-      for (var lastTailNode$64 = null; null !== lastTailNode; )
-        null !== lastTailNode.alternate && (lastTailNode$64 = lastTailNode),
-          (lastTailNode = lastTailNode.sibling);
-      null === lastTailNode$64
-        ? hasRenderedATailFallback || null === renderState.tail
-          ? (renderState.tail = null)
-          : (renderState.tail.sibling = null)
-        : (lastTailNode$64.sibling = null);
-  }
-}
-function bubbleProperties(completedWork) {
-  var didBailout =
-      null !== completedWork.alternate &&
-      completedWork.alternate.child === completedWork.child,
-    newChildLanes = 0,
-    subtreeFlags = 0;
-  if (didBailout)
-    if (0 !== (completedWork.mode & 2)) {
-      for (
-        var treeBaseDuration$66 = completedWork.selfBaseDuration,
-          child$67 = completedWork.child;
-        null !== child$67;
-
-      )
-        (newChildLanes |= child$67.lanes | child$67.childLanes),
-          (subtreeFlags |= child$67.subtreeFlags & 31457280),
-          (subtreeFlags |= child$67.flags & 31457280),
-          (treeBaseDuration$66 += child$67.treeBaseDuration),
-          (child$67 = child$67.sibling);
-      completedWork.treeBaseDuration = treeBaseDuration$66;
-    } else
-      for (
-        treeBaseDuration$66 = completedWork.child;
-        null !== treeBaseDuration$66;
-
-      )
-        (newChildLanes |=
-          treeBaseDuration$66.lanes | treeBaseDuration$66.childLanes),
-          (subtreeFlags |= treeBaseDuration$66.subtreeFlags & 31457280),
-          (subtreeFlags |= treeBaseDuration$66.flags & 31457280),
-          (treeBaseDuration$66.return = completedWork),
-          (treeBaseDuration$66 = treeBaseDuration$66.sibling);
-  else if (0 !== (completedWork.mode & 2)) {
-    treeBaseDuration$66 = completedWork.actualDuration;
-    child$67 = completedWork.selfBaseDuration;
-    for (var child = completedWork.child; null !== child; )
-      (newChildLanes |= child.lanes | child.childLanes),
-        (subtreeFlags |= child.subtreeFlags),
-        (subtreeFlags |= child.flags),
-        (treeBaseDuration$66 += child.actualDuration),
-        (child$67 += child.treeBaseDuration),
-        (child = child.sibling);
-    completedWork.actualDuration = treeBaseDuration$66;
-    completedWork.treeBaseDuration = child$67;
-  } else
-    for (
-      treeBaseDuration$66 = completedWork.child;
-      null !== treeBaseDuration$66;
-
-    )
-      (newChildLanes |=
-        treeBaseDuration$66.lanes | treeBaseDuration$66.childLanes),
-        (subtreeFlags |= treeBaseDuration$66.subtreeFlags),
-        (subtreeFlags |= treeBaseDuration$66.flags),
-        (treeBaseDuration$66.return = completedWork),
-        (treeBaseDuration$66 = treeBaseDuration$66.sibling);
-  completedWork.subtreeFlags |= subtreeFlags;
-  completedWork.childLanes = newChildLanes;
-  return didBailout;
-}
-function completeWork(current, workInProgress, renderLanes) {
-  var newProps = workInProgress.pendingProps;
+      didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;
+    }
+  else didReceiveUpdate = !1;
+  workInProgress.lanes = 0;
   switch (workInProgress.tag) {
     case 2:
+      var Component = workInProgress.type;
+      resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress);
+      current = workInProgress.pendingProps;
+      prepareToReadContext(workInProgress, renderLanes);
+      var value = renderWithHooks(
+        null,
+        workInProgress,
+        Component,
+        current,
+        void 0,
+        renderLanes
+      );
+      workInProgress.flags |= 1;
+      "object" === typeof value &&
+      null !== value &&
+      "function" === typeof value.render &&
+      void 0 === value.$$typeof
+        ? ((workInProgress.tag = 1),
+          (workInProgress.memoizedState = null),
+          (workInProgress.updateQueue = null),
+          (workInProgress.memoizedState =
+            null !== value.state && void 0 !== value.state
+              ? value.state
+              : null),
+          initializeUpdateQueue(workInProgress),
+          (value.updater = classComponentUpdater),
+          (workInProgress.stateNode = value),
+          (value._reactInternals = workInProgress),
+          mountClassInstance(workInProgress, Component, current, renderLanes),
+          (workInProgress = finishClassComponent(
+            null,
+            workInProgress,
+            Component,
+            !0,
+            !1,
+            renderLanes
+          )))
+        : ((workInProgress.tag = 0),
+          reconcileChildren(null, workInProgress, value, renderLanes),
+          (workInProgress = workInProgress.child));
+      return workInProgress;
     case 16:
-    case 15:
+      Component = workInProgress.elementType;
+      a: {
+        resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress);
+        current = workInProgress.pendingProps;
+        value = Component._init;
+        Component = value(Component._payload);
+        workInProgress.type = Component;
+        value = workInProgress.tag = resolveLazyComponentTag(Component);
+        current = resolveDefaultProps(Component, current);
+        switch (value) {
+          case 0:
+            workInProgress = updateFunctionComponent(
+              null,
+              workInProgress,
+              Component,
+              current,
+              renderLanes
+            );
+            break a;
+          case 1:
+            workInProgress = updateClassComponent(
+              null,
+              workInProgress,
+              Component,
+              current,
+              renderLanes
+            );
+            break a;
+          case 11:
+            workInProgress = updateForwardRef(
+              null,
+              workInProgress,
+              Component,
+              current,
+              renderLanes
+            );
+            break a;
+          case 14:
+            workInProgress = updateMemoComponent(
+              null,
+              workInProgress,
+              Component,
+              resolveDefaultProps(Component.type, current),
+              renderLanes
+            );
+            break a;
+        }
+        throw Error(
+          "Element type is invalid. Received a promise that resolves to: " +
+            Component +
+            ". Lazy element type must resolve to a class or function."
+        );
+      }
+      return workInProgress;
     case 0:
-    case 11:
-    case 7:
-    case 8:
-    case 12:
-    case 9:
-    case 14:
-      return bubbleProperties(workInProgress), null;
-    case 1:
       return (
-        isContextProvider(workInProgress.type) && popContext(),
-        bubbleProperties(workInProgress),
-        null
+        (Component = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === Component
+            ? value
+            : resolveDefaultProps(Component, value)),
+        updateFunctionComponent(
+          current,
+          workInProgress,
+          Component,
+          value,
+          renderLanes
+        )
       );
-    case 3:
+    case 1:
       return (
-        (renderLanes = workInProgress.stateNode),
-        popHostContainer(),
-        pop(didPerformWorkStackCursor),
-        pop(contextStackCursor$1),
-        renderLanes.pendingContext &&
-          ((renderLanes.context = renderLanes.pendingContext),
-          (renderLanes.pendingContext = null)),
-        (null !== current && null !== current.child) ||
-          null === current ||
-          (current.memoizedState.isDehydrated &&
-            0 === (workInProgress.flags & 256)) ||
-          ((workInProgress.flags |= 1024),
-          null !== hydrationErrors &&
-            (queueRecoverableErrors(hydrationErrors),
-            (hydrationErrors = null))),
-        bubbleProperties(workInProgress),
-        null
+        (Component = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === Component
+            ? value
+            : resolveDefaultProps(Component, value)),
+        updateClassComponent(
+          current,
+          workInProgress,
+          Component,
+          value,
+          renderLanes
+        )
       );
+    case 3:
+      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
+      if (null === current)
+        throw Error("Should have a current fiber. This is a bug in React.");
+      value = workInProgress.pendingProps;
+      Component = workInProgress.memoizedState.element;
+      cloneUpdateQueue(current, workInProgress);
+      processUpdateQueue(workInProgress, value, null, renderLanes);
+      value = workInProgress.memoizedState.element;
+      value === Component
+        ? (workInProgress = bailoutOnAlreadyFinishedWork(
+            current,
+            workInProgress,
+            renderLanes
+          ))
+        : (reconcileChildren(current, workInProgress, value, renderLanes),
+          (workInProgress = workInProgress.child));
+      return workInProgress;
     case 26:
     case 27:
     case 5:
-      popHostContext(workInProgress);
-      var type = workInProgress.type;
-      if (null !== current && null != workInProgress.stateNode)
-        current.memoizedProps !== newProps && (workInProgress.flags |= 4),
-          current.ref !== workInProgress.ref &&
-            (workInProgress.flags |= 2097664);
-      else {
-        if (!newProps) {
-          if (null === workInProgress.stateNode)
-            throw Error(
-              "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
-            );
-          bubbleProperties(workInProgress);
-          return null;
-        }
-        current = rootInstanceStackCursor.current;
-        renderLanes = allocateTag();
-        type = getViewConfigForType(type);
-        var updatePayload = diffProperties(
-          null,
-          emptyObject,
-          newProps,
-          type.validAttributes
-        );
-        ReactNativePrivateInterface.UIManager.createView(
-          renderLanes,
-          type.uiViewClassName,
-          current,
-          updatePayload
-        );
-        current = new ReactNativeFiberHostComponent(
-          renderLanes,
-          type,
-          workInProgress
-        );
-        instanceCache.set(renderLanes, workInProgress);
-        instanceProps.set(renderLanes, newProps);
-        a: for (renderLanes = workInProgress.child; null !== renderLanes; ) {
-          if (5 === renderLanes.tag || 6 === renderLanes.tag)
-            current._children.push(renderLanes.stateNode);
-          else if (4 !== renderLanes.tag && null !== renderLanes.child) {
-            renderLanes.child.return = renderLanes;
-            renderLanes = renderLanes.child;
-            continue;
-          }
-          if (renderLanes === workInProgress) break a;
-          for (; null === renderLanes.sibling; ) {
-            if (
-              null === renderLanes.return ||
-              renderLanes.return === workInProgress
-            )
-              break a;
-            renderLanes = renderLanes.return;
-          }
-          renderLanes.sibling.return = renderLanes.return;
-          renderLanes = renderLanes.sibling;
-        }
-        workInProgress.stateNode = current;
-        finalizeInitialChildren(current) && (workInProgress.flags |= 4);
-        null !== workInProgress.ref && (workInProgress.flags |= 2097664);
-      }
-      bubbleProperties(workInProgress);
-      workInProgress.flags &= -16777217;
-      return null;
+      return (
+        pushHostContext(workInProgress),
+        (Component = workInProgress.pendingProps.children),
+        markRef(current, workInProgress),
+        reconcileChildren(current, workInProgress, Component, renderLanes),
+        workInProgress.child
+      );
     case 6:
-      if (current && null != workInProgress.stateNode)
-        current.memoizedProps !== newProps && (workInProgress.flags |= 4);
-      else {
-        if ("string" !== typeof newProps && null === workInProgress.stateNode)
-          throw Error(
-            "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
-          );
-        renderLanes = rootInstanceStackCursor.current;
-        if (!contextStackCursor.current.isInAParentText)
-          throw Error(
-            "Text strings must be rendered within a <Text> component."
-          );
-        current = allocateTag();
-        ReactNativePrivateInterface.UIManager.createView(
-          current,
-          "RCTRawText",
-          renderLanes,
-          { text: newProps }
-        );
-        instanceCache.set(current, workInProgress);
-        workInProgress.stateNode = current;
-      }
-      bubbleProperties(workInProgress);
       return null;
     case 13:
-      popSuspenseHandler(workInProgress);
-      newProps = workInProgress.memoizedState;
-      if (
-        null === current ||
-        (null !== current.memoizedState &&
-          null !== current.memoizedState.dehydrated)
-      ) {
-        if (null !== newProps && null !== newProps.dehydrated) {
-          if (null === current) {
-            throw Error(
-              "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
-            );
-            throw Error(
-              "Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
-            );
-          }
-          0 === (workInProgress.flags & 128) &&
-            (workInProgress.memoizedState = null);
-          workInProgress.flags |= 4;
-          bubbleProperties(workInProgress);
-          0 !== (workInProgress.mode & 2) &&
-            null !== newProps &&
-            ((type = workInProgress.child),
-            null !== type &&
-              (workInProgress.treeBaseDuration -= type.treeBaseDuration));
-          type = !1;
-        } else
-          null !== hydrationErrors &&
-            (queueRecoverableErrors(hydrationErrors), (hydrationErrors = null)),
-            (type = !0);
-        if (!type) return workInProgress.flags & 256 ? workInProgress : null;
-      }
-      if (0 !== (workInProgress.flags & 128))
-        return (
-          (workInProgress.lanes = renderLanes),
-          0 !== (workInProgress.mode & 2) &&
-            transferActualDuration(workInProgress),
-          workInProgress
-        );
-      renderLanes = null !== newProps;
-      renderLanes !== (null !== current && null !== current.memoizedState) &&
-        renderLanes &&
-        (workInProgress.child.flags |= 8192);
-      scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
-      bubbleProperties(workInProgress);
-      0 !== (workInProgress.mode & 2) &&
-        renderLanes &&
-        ((renderLanes = workInProgress.child),
-        null !== renderLanes &&
-          (workInProgress.treeBaseDuration -= renderLanes.treeBaseDuration));
-      return null;
+      return updateSuspenseComponent(current, workInProgress, renderLanes);
     case 4:
-      return popHostContainer(), bubbleProperties(workInProgress), null;
-    case 10:
       return (
-        popProvider(workInProgress.type._context),
-        bubbleProperties(workInProgress),
-        null
+        pushHostContainer(
+          workInProgress,
+          workInProgress.stateNode.containerInfo
+        ),
+        (Component = workInProgress.pendingProps),
+        null === current
+          ? (workInProgress.child = reconcileChildFibers(
+              workInProgress,
+              null,
+              Component,
+              renderLanes
+            ))
+          : reconcileChildren(current, workInProgress, Component, renderLanes),
+        workInProgress.child
       );
-    case 17:
+    case 11:
       return (
-        isContextProvider(workInProgress.type) && popContext(),
-        bubbleProperties(workInProgress),
-        null
+        (Component = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === Component
+            ? value
+            : resolveDefaultProps(Component, value)),
+        updateForwardRef(current, workInProgress, Component, value, renderLanes)
       );
-    case 19:
-      pop(suspenseStackCursor);
-      type = workInProgress.memoizedState;
-      if (null === type) return bubbleProperties(workInProgress), null;
-      newProps = 0 !== (workInProgress.flags & 128);
-      updatePayload = type.rendering;
-      if (null === updatePayload)
-        if (newProps) cutOffTailIfNeeded(type, !1);
-        else {
-          if (
-            0 !== workInProgressRootExitStatus ||
-            (null !== current && 0 !== (current.flags & 128))
-          )
-            for (current = workInProgress.child; null !== current; ) {
-              updatePayload = findFirstSuspended(current);
-              if (null !== updatePayload) {
-                workInProgress.flags |= 128;
-                cutOffTailIfNeeded(type, !1);
-                current = updatePayload.updateQueue;
-                workInProgress.updateQueue = current;
-                scheduleRetryEffect(workInProgress, current);
-                workInProgress.subtreeFlags = 0;
-                for (current = workInProgress.child; null !== current; )
-                  resetWorkInProgress(current, renderLanes),
-                    (current = current.sibling);
-                push(
-                  suspenseStackCursor,
-                  (suspenseStackCursor.current & 1) | 2
-                );
-                return workInProgress.child;
-              }
-              current = current.sibling;
-            }
-          null !== type.tail &&
-            now$1() > workInProgressRootRenderTargetTime &&
-            ((workInProgress.flags |= 128),
-            (newProps = !0),
-            cutOffTailIfNeeded(type, !1),
-            (workInProgress.lanes = 4194304));
-        }
-      else {
-        if (!newProps)
-          if (
-            ((current = findFirstSuspended(updatePayload)), null !== current)
-          ) {
-            if (
-              ((workInProgress.flags |= 128),
-              (newProps = !0),
-              (renderLanes = current.updateQueue),
-              (workInProgress.updateQueue = renderLanes),
-              scheduleRetryEffect(workInProgress, renderLanes),
-              cutOffTailIfNeeded(type, !0),
-              null === type.tail &&
-                "hidden" === type.tailMode &&
-                !updatePayload.alternate)
-            )
-              return bubbleProperties(workInProgress), null;
-          } else
-            2 * now$1() - type.renderingStartTime >
-              workInProgressRootRenderTargetTime &&
-              536870912 !== renderLanes &&
-              ((workInProgress.flags |= 128),
-              (newProps = !0),
-              cutOffTailIfNeeded(type, !1),
-              (workInProgress.lanes = 4194304));
-        type.isBackwards
-          ? ((updatePayload.sibling = workInProgress.child),
-            (workInProgress.child = updatePayload))
-          : ((renderLanes = type.last),
-            null !== renderLanes
-              ? (renderLanes.sibling = updatePayload)
-              : (workInProgress.child = updatePayload),
-            (type.last = updatePayload));
-      }
-      if (null !== type.tail)
-        return (
-          (workInProgress = type.tail),
-          (type.rendering = workInProgress),
-          (type.tail = workInProgress.sibling),
-          (type.renderingStartTime = now$1()),
-          (workInProgress.sibling = null),
-          (renderLanes = suspenseStackCursor.current),
-          push(
-            suspenseStackCursor,
-            newProps ? (renderLanes & 1) | 2 : renderLanes & 1
-          ),
-          workInProgress
-        );
-      bubbleProperties(workInProgress);
-      return null;
-    case 22:
-    case 23:
+    case 7:
       return (
-        popSuspenseHandler(workInProgress),
-        popHiddenContext(),
-        (newProps = null !== workInProgress.memoizedState),
-        null !== current
-          ? (null !== current.memoizedState) !== newProps &&
-            (workInProgress.flags |= 8192)
-          : newProps && (workInProgress.flags |= 8192),
-        newProps && 0 !== (workInProgress.mode & 1)
-          ? 0 !== (renderLanes & 536870912) &&
-            0 === (workInProgress.flags & 128) &&
-            (bubbleProperties(workInProgress),
-            workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192))
-          : bubbleProperties(workInProgress),
-        (renderLanes = workInProgress.updateQueue),
-        null !== renderLanes &&
-          scheduleRetryEffect(workInProgress, renderLanes.retryQueue),
-        null
+        reconcileChildren(
+          current,
+          workInProgress,
+          workInProgress.pendingProps,
+          renderLanes
+        ),
+        workInProgress.child
       );
-    case 24:
-      return null;
-    case 25:
-      return null;
-  }
-  throw Error(
-    "Unknown unit of work tag (" +
-      workInProgress.tag +
-      "). This error is likely caused by a bug in React. Please file an issue."
-  );
-}
-function unwindWork(current, workInProgress) {
-  switch (workInProgress.tag) {
-    case 1:
+    case 8:
       return (
-        isContextProvider(workInProgress.type) && popContext(),
-        (current = workInProgress.flags),
-        current & 65536
-          ? ((workInProgress.flags = (current & -65537) | 128),
-            0 !== (workInProgress.mode & 2) &&
-              transferActualDuration(workInProgress),
-            workInProgress)
-          : null
+        reconcileChildren(
+          current,
+          workInProgress,
+          workInProgress.pendingProps.children,
+          renderLanes
+        ),
+        workInProgress.child
       );
-    case 3:
+    case 12:
       return (
-        popHostContainer(),
-        pop(didPerformWorkStackCursor),
-        pop(contextStackCursor$1),
-        (current = workInProgress.flags),
-        0 !== (current & 65536) && 0 === (current & 128)
-          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
-          : null
+        (workInProgress.flags |= 4),
+        (Component = workInProgress.stateNode),
+        (Component.effectDuration = 0),
+        (Component.passiveEffectDuration = 0),
+        reconcileChildren(
+          current,
+          workInProgress,
+          workInProgress.pendingProps.children,
+          renderLanes
+        ),
+        workInProgress.child
       );
-    case 26:
-    case 27:
-    case 5:
-      return popHostContext(workInProgress), null;
-    case 13:
-      popSuspenseHandler(workInProgress);
-      current = workInProgress.memoizedState;
-      if (
-        null !== current &&
-        null !== current.dehydrated &&
-        null === workInProgress.alternate
-      )
-        throw Error(
-          "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
-        );
-      current = workInProgress.flags;
-      return current & 65536
-        ? ((workInProgress.flags = (current & -65537) | 128),
-          0 !== (workInProgress.mode & 2) &&
-            transferActualDuration(workInProgress),
-          workInProgress)
-        : null;
-    case 19:
-      return pop(suspenseStackCursor), null;
-    case 4:
-      return popHostContainer(), null;
     case 10:
-      return popProvider(workInProgress.type._context), null;
-    case 22:
-    case 23:
+      a: {
+        Component = workInProgress.type._context;
+        value = workInProgress.pendingProps;
+        var oldProps = workInProgress.memoizedProps,
+          newValue = value.value;
+        push(valueCursor, Component._currentValue);
+        Component._currentValue = newValue;
+        if (null !== oldProps)
+          if (objectIs(oldProps.value, newValue)) {
+            if (oldProps.children === value.children) {
+              workInProgress = bailoutOnAlreadyFinishedWork(
+                current,
+                workInProgress,
+                renderLanes
+              );
+              break a;
+            }
+          } else
+            for (
+              oldProps = workInProgress.child,
+                null !== oldProps && (oldProps.return = workInProgress);
+              null !== oldProps;
+
+            ) {
+              var list = oldProps.dependencies;
+              if (null !== list) {
+                newValue = oldProps.child;
+                for (
+                  var dependency = list.firstContext;
+                  null !== dependency;
+
+                ) {
+                  if (dependency.context === Component) {
+                    if (1 === oldProps.tag) {
+                      dependency = createUpdate(renderLanes & -renderLanes);
+                      dependency.tag = 2;
+                      var updateQueue = oldProps.updateQueue;
+                      if (null !== updateQueue) {
+                        updateQueue = updateQueue.shared;
+                        var pending = updateQueue.pending;
+                        null === pending
+                          ? (dependency.next = dependency)
+                          : ((dependency.next = pending.next),
+                            (pending.next = dependency));
+                        updateQueue.pending = dependency;
+                      }
+                    }
+                    oldProps.lanes |= renderLanes;
+                    dependency = oldProps.alternate;
+                    null !== dependency && (dependency.lanes |= renderLanes);
+                    scheduleContextWorkOnParentPath(
+                      oldProps.return,
+                      renderLanes,
+                      workInProgress
+                    );
+                    list.lanes |= renderLanes;
+                    break;
+                  }
+                  dependency = dependency.next;
+                }
+              } else if (10 === oldProps.tag)
+                newValue =
+                  oldProps.type === workInProgress.type ? null : oldProps.child;
+              else if (18 === oldProps.tag) {
+                newValue = oldProps.return;
+                if (null === newValue)
+                  throw Error(
+                    "We just came from a parent so we must have had a parent. This is a bug in React."
+                  );
+                newValue.lanes |= renderLanes;
+                list = newValue.alternate;
+                null !== list && (list.lanes |= renderLanes);
+                scheduleContextWorkOnParentPath(
+                  newValue,
+                  renderLanes,
+                  workInProgress
+                );
+                newValue = oldProps.sibling;
+              } else newValue = oldProps.child;
+              if (null !== newValue) newValue.return = oldProps;
+              else
+                for (newValue = oldProps; null !== newValue; ) {
+                  if (newValue === workInProgress) {
+                    newValue = null;
+                    break;
+                  }
+                  oldProps = newValue.sibling;
+                  if (null !== oldProps) {
+                    oldProps.return = newValue.return;
+                    newValue = oldProps;
+                    break;
+                  }
+                  newValue = newValue.return;
+                }
+              oldProps = newValue;
+            }
+        reconcileChildren(current, workInProgress, value.children, renderLanes);
+        workInProgress = workInProgress.child;
+      }
+      return workInProgress;
+    case 9:
       return (
-        popSuspenseHandler(workInProgress),
-        popHiddenContext(),
-        (current = workInProgress.flags),
-        current & 65536
-          ? ((workInProgress.flags = (current & -65537) | 128),
-            0 !== (workInProgress.mode & 2) &&
-              transferActualDuration(workInProgress),
-            workInProgress)
-          : null
+        (value = workInProgress.type),
+        (Component = workInProgress.pendingProps.children),
+        prepareToReadContext(workInProgress, renderLanes),
+        (value = readContext(value)),
+        (Component = Component(value)),
+        (workInProgress.flags |= 1),
+        reconcileChildren(current, workInProgress, Component, renderLanes),
+        workInProgress.child
+      );
+    case 14:
+      return (
+        (Component = workInProgress.type),
+        (value = resolveDefaultProps(Component, workInProgress.pendingProps)),
+        (value = resolveDefaultProps(Component.type, value)),
+        updateMemoComponent(
+          current,
+          workInProgress,
+          Component,
+          value,
+          renderLanes
+        )
+      );
+    case 15:
+      return updateSimpleMemoComponent(
+        current,
+        workInProgress,
+        workInProgress.type,
+        workInProgress.pendingProps,
+        renderLanes
+      );
+    case 17:
+      return (
+        (Component = workInProgress.type),
+        (value = workInProgress.pendingProps),
+        (value =
+          workInProgress.elementType === Component
+            ? value
+            : resolveDefaultProps(Component, value)),
+        resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress),
+        (workInProgress.tag = 1),
+        prepareToReadContext(workInProgress, renderLanes),
+        constructClassInstance(workInProgress, Component, value),
+        mountClassInstance(workInProgress, Component, value, renderLanes),
+        finishClassComponent(
+          null,
+          workInProgress,
+          Component,
+          !0,
+          !1,
+          renderLanes
+        )
       );
-    case 24:
-      return null;
-    case 25:
-      return null;
-    default:
-      return null;
-  }
-}
-function unwindInterruptedWork(current, interruptedWork) {
-  switch (interruptedWork.tag) {
-    case 1:
-      current = interruptedWork.type.childContextTypes;
-      null !== current && void 0 !== current && popContext();
-      break;
-    case 3:
-      popHostContainer();
-      pop(didPerformWorkStackCursor);
-      pop(contextStackCursor$1);
-      break;
-    case 26:
-    case 27:
-    case 5:
-      popHostContext(interruptedWork);
-      break;
-    case 4:
-      popHostContainer();
-      break;
-    case 13:
-      popSuspenseHandler(interruptedWork);
-      break;
     case 19:
-      pop(suspenseStackCursor);
-      break;
-    case 10:
-      popProvider(interruptedWork.type._context);
-      break;
+      return updateSuspenseListComponent(current, workInProgress, renderLanes);
     case 22:
-    case 23:
-      popSuspenseHandler(interruptedWork), popHiddenContext();
+      return updateOffscreenComponent(current, workInProgress, renderLanes);
   }
+  throw Error(
+    "Unknown unit of work tag (" +
+      workInProgress.tag +
+      "). This error is likely caused by a bug in React. Please file an issue."
+  );
 }
-var offscreenSubtreeIsHidden = !1,
-  offscreenSubtreeWasHidden = !1,
-  PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
-  nextEffect = null,
-  inProgressLanes = null,
-  inProgressRoot = null;
-function shouldProfile(current) {
-  return 0 !== (current.mode & 2) && 0 !== (executionContext & 4);
+var valueCursor = createCursor(null),
+  currentlyRenderingFiber = null,
+  lastContextDependency = null,
+  lastFullyObservedContext = null;
+function resetContextDependencies() {
+  lastFullyObservedContext =
+    lastContextDependency =
+    currentlyRenderingFiber =
+      null;
 }
-function callComponentWillUnmountWithTimer(current, instance) {
-  instance.props = current.memoizedProps;
-  instance.state = current.memoizedState;
-  if (shouldProfile(current))
-    try {
-      startLayoutEffectTimer(), instance.componentWillUnmount();
-    } finally {
-      recordLayoutEffectDuration(current);
-    }
-  else instance.componentWillUnmount();
+function popProvider(context) {
+  context._currentValue = valueCursor.current;
+  pop(valueCursor);
 }
-function safelyAttachRef(current, nearestMountedAncestor) {
-  try {
-    var ref = current.ref;
-    if (null !== ref) {
-      var instance = current.stateNode;
-      switch (current.tag) {
-        case 26:
-        case 27:
-        case 5:
-          var instanceToUse = getPublicInstance(instance);
-          break;
-        default:
-          instanceToUse = instance;
-      }
-      if ("function" === typeof ref)
-        if (shouldProfile(current))
-          try {
-            startLayoutEffectTimer(), (current.refCleanup = ref(instanceToUse));
-          } finally {
-            recordLayoutEffectDuration(current);
-          }
-        else current.refCleanup = ref(instanceToUse);
-      else ref.current = instanceToUse;
-    }
-  } catch (error) {
-    captureCommitPhaseError(current, nearestMountedAncestor, error);
+function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {
+  for (; null !== parent; ) {
+    var alternate = parent.alternate;
+    (parent.childLanes & renderLanes) !== renderLanes
+      ? ((parent.childLanes |= renderLanes),
+        null !== alternate && (alternate.childLanes |= renderLanes))
+      : null !== alternate &&
+        (alternate.childLanes & renderLanes) !== renderLanes &&
+        (alternate.childLanes |= renderLanes);
+    if (parent === propagationRoot) break;
+    parent = parent.return;
   }
 }
-function safelyDetachRef(current, nearestMountedAncestor) {
-  var ref = current.ref,
-    refCleanup = current.refCleanup;
-  if (null !== ref)
-    if ("function" === typeof refCleanup)
-      try {
-        if (shouldProfile(current))
-          try {
-            startLayoutEffectTimer(), refCleanup();
-          } finally {
-            recordLayoutEffectDuration(current);
-          }
-        else refCleanup();
-      } catch (error) {
-        captureCommitPhaseError(current, nearestMountedAncestor, error);
-      } finally {
-        (current.refCleanup = null),
-          (current = current.alternate),
-          null != current && (current.refCleanup = null);
-      }
-    else if ("function" === typeof ref)
-      try {
-        if (shouldProfile(current))
-          try {
-            startLayoutEffectTimer(), ref(null);
-          } finally {
-            recordLayoutEffectDuration(current);
-          }
-        else ref(null);
-      } catch (error$85) {
-        captureCommitPhaseError(current, nearestMountedAncestor, error$85);
-      }
-    else ref.current = null;
-}
-function safelyCallDestroy(current, nearestMountedAncestor, destroy) {
-  try {
-    destroy();
-  } catch (error) {
-    captureCommitPhaseError(current, nearestMountedAncestor, error);
-  }
+function prepareToReadContext(workInProgress, renderLanes) {
+  currentlyRenderingFiber = workInProgress;
+  lastFullyObservedContext = lastContextDependency = null;
+  workInProgress = workInProgress.dependencies;
+  null !== workInProgress &&
+    null !== workInProgress.firstContext &&
+    (0 !== (workInProgress.lanes & renderLanes) && (didReceiveUpdate = !0),
+    (workInProgress.firstContext = null));
 }
-var shouldFireAfterActiveInstanceBlur = !1;
-function commitBeforeMutationEffects(root, firstChild) {
-  for (nextEffect = firstChild; null !== nextEffect; )
-    if (
-      ((root = nextEffect),
-      (firstChild = root.child),
-      0 !== (root.subtreeFlags & 1028) && null !== firstChild)
-    )
-      (firstChild.return = root), (nextEffect = firstChild);
-    else
-      for (; null !== nextEffect; ) {
-        root = nextEffect;
-        try {
-          var current = root.alternate,
-            flags = root.flags;
-          switch (root.tag) {
-            case 0:
-              break;
-            case 11:
-            case 15:
-              break;
-            case 1:
-              if (0 !== (flags & 1024) && null !== current) {
-                var prevProps = current.memoizedProps,
-                  prevState = current.memoizedState,
-                  instance = root.stateNode,
-                  snapshot = instance.getSnapshotBeforeUpdate(
-                    root.elementType === root.type
-                      ? prevProps
-                      : resolveDefaultProps(root.type, prevProps),
-                    prevState
-                  );
-                instance.__reactInternalSnapshotBeforeUpdate = snapshot;
-              }
-              break;
-            case 3:
-              break;
-            case 5:
-            case 26:
-            case 27:
-            case 6:
-            case 4:
-            case 17:
-              break;
-            default:
-              if (0 !== (flags & 1024))
-                throw Error(
-                  "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
-                );
-          }
-        } catch (error) {
-          captureCommitPhaseError(root, root.return, error);
-        }
-        firstChild = root.sibling;
-        if (null !== firstChild) {
-          firstChild.return = root.return;
-          nextEffect = firstChild;
-          break;
-        }
-        nextEffect = root.return;
-      }
-  current = shouldFireAfterActiveInstanceBlur;
-  shouldFireAfterActiveInstanceBlur = !1;
-  return current;
+function readContext(context) {
+  return readContextForConsumer(currentlyRenderingFiber, context);
 }
-function commitHookEffectListUnmount(
-  flags,
-  finishedWork,
-  nearestMountedAncestor
-) {
-  var updateQueue = finishedWork.updateQueue;
-  updateQueue = null !== updateQueue ? updateQueue.lastEffect : null;
-  if (null !== updateQueue) {
-    var effect = (updateQueue = updateQueue.next);
-    do {
-      if ((effect.tag & flags) === flags) {
-        var inst = effect.inst,
-          destroy = inst.destroy;
-        void 0 !== destroy &&
-          ((inst.destroy = void 0),
-          safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy));
-      }
-      effect = effect.next;
-    } while (effect !== updateQueue);
-  }
+function readContextDuringReconciliation(consumer, context, renderLanes) {
+  null === currentlyRenderingFiber &&
+    prepareToReadContext(consumer, renderLanes);
+  return readContextForConsumer(consumer, context);
 }
-function commitHookEffectListMount(flags, finishedWork) {
-  finishedWork = finishedWork.updateQueue;
-  finishedWork = null !== finishedWork ? finishedWork.lastEffect : null;
-  if (null !== finishedWork) {
-    var effect = (finishedWork = finishedWork.next);
-    do {
-      if ((effect.tag & flags) === flags) {
-        var create$86 = effect.create,
-          inst = effect.inst;
-        create$86 = create$86();
-        inst.destroy = create$86;
-      }
-      effect = effect.next;
-    } while (effect !== finishedWork);
-  }
+function readContextForConsumer(consumer, context) {
+  var value = context._currentValue;
+  if (lastFullyObservedContext !== context)
+    if (
+      ((context = { context: context, memoizedValue: value, next: null }),
+      null === lastContextDependency)
+    ) {
+      if (null === consumer)
+        throw Error(
+          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
+        );
+      lastContextDependency = context;
+      consumer.dependencies = { lanes: 0, firstContext: context };
+    } else lastContextDependency = lastContextDependency.next = context;
+  return value;
 }
-function commitHookLayoutEffects(finishedWork, hookFlags) {
-  if (shouldProfile(finishedWork)) {
-    try {
-      startLayoutEffectTimer(),
-        commitHookEffectListMount(hookFlags, finishedWork);
-    } catch (error) {
-      captureCommitPhaseError(finishedWork, finishedWork.return, error);
-    }
-    recordLayoutEffectDuration(finishedWork);
-  } else
-    try {
-      commitHookEffectListMount(hookFlags, finishedWork);
-    } catch (error$88) {
-      captureCommitPhaseError(finishedWork, finishedWork.return, error$88);
-    }
+var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
+function handleAsyncAction() {}
+function scheduleRetryEffect(workInProgress, retryQueue) {
+  null !== retryQueue
+    ? (workInProgress.flags |= 4)
+    : workInProgress.flags & 16384 &&
+      ((retryQueue =
+        22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),
+      (workInProgress.lanes |= retryQueue));
 }
-function commitClassCallbacks(finishedWork) {
-  var updateQueue = finishedWork.updateQueue;
-  if (null !== updateQueue) {
-    var instance = finishedWork.stateNode;
-    try {
-      commitCallbacks(updateQueue, instance);
-    } catch (error) {
-      captureCommitPhaseError(finishedWork, finishedWork.return, error);
-    }
+function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
+  switch (renderState.tailMode) {
+    case "hidden":
+      hasRenderedATailFallback = renderState.tail;
+      for (var lastTailNode = null; null !== hasRenderedATailFallback; )
+        null !== hasRenderedATailFallback.alternate &&
+          (lastTailNode = hasRenderedATailFallback),
+          (hasRenderedATailFallback = hasRenderedATailFallback.sibling);
+      null === lastTailNode
+        ? (renderState.tail = null)
+        : (lastTailNode.sibling = null);
+      break;
+    case "collapsed":
+      lastTailNode = renderState.tail;
+      for (var lastTailNode$64 = null; null !== lastTailNode; )
+        null !== lastTailNode.alternate && (lastTailNode$64 = lastTailNode),
+          (lastTailNode = lastTailNode.sibling);
+      null === lastTailNode$64
+        ? hasRenderedATailFallback || null === renderState.tail
+          ? (renderState.tail = null)
+          : (renderState.tail.sibling = null)
+        : (lastTailNode$64.sibling = null);
   }
 }
-function commitProfilerUpdate(finishedWork, current) {
-  if (executionContext & 4)
-    try {
-      var _finishedWork$memoize2 = finishedWork.memoizedProps,
-        onCommit = _finishedWork$memoize2.onCommit,
-        onRender = _finishedWork$memoize2.onRender,
-        effectDuration = finishedWork.stateNode.effectDuration;
-      _finishedWork$memoize2 = commitTime;
-      current = null === current ? "mount" : "update";
-      currentUpdateIsNested && (current = "nested-update");
-      "function" === typeof onRender &&
-        onRender(
-          finishedWork.memoizedProps.id,
-          current,
-          finishedWork.actualDuration,
-          finishedWork.treeBaseDuration,
-          finishedWork.actualStartTime,
-          _finishedWork$memoize2
-        );
-      "function" === typeof onCommit &&
-        onCommit(
-          finishedWork.memoizedProps.id,
-          current,
-          effectDuration,
-          _finishedWork$memoize2
-        );
-      enqueuePendingPassiveProfilerEffect(finishedWork);
-      var parentFiber = finishedWork.return;
-      a: for (; null !== parentFiber; ) {
-        switch (parentFiber.tag) {
-          case 3:
-            parentFiber.stateNode.effectDuration += effectDuration;
-            break a;
-          case 12:
-            parentFiber.stateNode.effectDuration += effectDuration;
-            break a;
-        }
-        parentFiber = parentFiber.return;
-      }
-    } catch (error) {
-      captureCommitPhaseError(finishedWork, finishedWork.return, error);
-    }
+function bubbleProperties(completedWork) {
+  var didBailout =
+      null !== completedWork.alternate &&
+      completedWork.alternate.child === completedWork.child,
+    newChildLanes = 0,
+    subtreeFlags = 0;
+  if (didBailout)
+    if (0 !== (completedWork.mode & 2)) {
+      for (
+        var treeBaseDuration$66 = completedWork.selfBaseDuration,
+          child$67 = completedWork.child;
+        null !== child$67;
+
+      )
+        (newChildLanes |= child$67.lanes | child$67.childLanes),
+          (subtreeFlags |= child$67.subtreeFlags & 31457280),
+          (subtreeFlags |= child$67.flags & 31457280),
+          (treeBaseDuration$66 += child$67.treeBaseDuration),
+          (child$67 = child$67.sibling);
+      completedWork.treeBaseDuration = treeBaseDuration$66;
+    } else
+      for (
+        treeBaseDuration$66 = completedWork.child;
+        null !== treeBaseDuration$66;
+
+      )
+        (newChildLanes |=
+          treeBaseDuration$66.lanes | treeBaseDuration$66.childLanes),
+          (subtreeFlags |= treeBaseDuration$66.subtreeFlags & 31457280),
+          (subtreeFlags |= treeBaseDuration$66.flags & 31457280),
+          (treeBaseDuration$66.return = completedWork),
+          (treeBaseDuration$66 = treeBaseDuration$66.sibling);
+  else if (0 !== (completedWork.mode & 2)) {
+    treeBaseDuration$66 = completedWork.actualDuration;
+    child$67 = completedWork.selfBaseDuration;
+    for (var child = completedWork.child; null !== child; )
+      (newChildLanes |= child.lanes | child.childLanes),
+        (subtreeFlags |= child.subtreeFlags),
+        (subtreeFlags |= child.flags),
+        (treeBaseDuration$66 += child.actualDuration),
+        (child$67 += child.treeBaseDuration),
+        (child = child.sibling);
+    completedWork.actualDuration = treeBaseDuration$66;
+    completedWork.treeBaseDuration = child$67;
+  } else
+    for (
+      treeBaseDuration$66 = completedWork.child;
+      null !== treeBaseDuration$66;
+
+    )
+      (newChildLanes |=
+        treeBaseDuration$66.lanes | treeBaseDuration$66.childLanes),
+        (subtreeFlags |= treeBaseDuration$66.subtreeFlags),
+        (subtreeFlags |= treeBaseDuration$66.flags),
+        (treeBaseDuration$66.return = completedWork),
+        (treeBaseDuration$66 = treeBaseDuration$66.sibling);
+  completedWork.subtreeFlags |= subtreeFlags;
+  completedWork.childLanes = newChildLanes;
+  return didBailout;
 }
-function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
-  var flags = finishedWork.flags;
-  switch (finishedWork.tag) {
+function completeWork(current, workInProgress, renderLanes) {
+  var newProps = workInProgress.pendingProps;
+  switch (workInProgress.tag) {
+    case 2:
+    case 16:
+    case 15:
     case 0:
     case 11:
-    case 15:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      flags & 4 && commitHookLayoutEffects(finishedWork, 5);
-      break;
+    case 7:
+    case 8:
+    case 12:
+    case 9:
+    case 14:
+      return bubbleProperties(workInProgress), null;
     case 1:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      if (flags & 4)
-        if (((finishedRoot = finishedWork.stateNode), null === current))
-          if (shouldProfile(finishedWork)) {
-            try {
-              startLayoutEffectTimer(), finishedRoot.componentDidMount();
-            } catch (error) {
-              captureCommitPhaseError(finishedWork, finishedWork.return, error);
-            }
-            recordLayoutEffectDuration(finishedWork);
-          } else
-            try {
-              finishedRoot.componentDidMount();
-            } catch (error$89) {
-              captureCommitPhaseError(
-                finishedWork,
-                finishedWork.return,
-                error$89
-              );
-            }
-        else {
-          var prevProps =
-            finishedWork.elementType === finishedWork.type
-              ? current.memoizedProps
-              : resolveDefaultProps(finishedWork.type, current.memoizedProps);
-          current = current.memoizedState;
-          if (shouldProfile(finishedWork)) {
-            try {
-              startLayoutEffectTimer(),
-                finishedRoot.componentDidUpdate(
-                  prevProps,
-                  current,
-                  finishedRoot.__reactInternalSnapshotBeforeUpdate
-                );
-            } catch (error$90) {
-              captureCommitPhaseError(
-                finishedWork,
-                finishedWork.return,
-                error$90
-              );
-            }
-            recordLayoutEffectDuration(finishedWork);
-          } else
-            try {
-              finishedRoot.componentDidUpdate(
-                prevProps,
-                current,
-                finishedRoot.__reactInternalSnapshotBeforeUpdate
-              );
-            } catch (error$91) {
-              captureCommitPhaseError(
-                finishedWork,
-                finishedWork.return,
-                error$91
-              );
-            }
-        }
-      flags & 64 && commitClassCallbacks(finishedWork);
-      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
-      break;
+      return bubbleProperties(workInProgress), null;
     case 3:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      if (flags & 64 && ((flags = finishedWork.updateQueue), null !== flags)) {
-        finishedRoot = null;
-        if (null !== finishedWork.child)
-          switch (finishedWork.child.tag) {
-            case 27:
-            case 5:
-              finishedRoot = getPublicInstance(finishedWork.child.stateNode);
-              break;
-            case 1:
-              finishedRoot = finishedWork.child.stateNode;
-          }
-        try {
-          commitCallbacks(flags, finishedRoot);
-        } catch (error) {
-          captureCommitPhaseError(finishedWork, finishedWork.return, error);
-        }
-      }
-      break;
+      return (
+        (renderLanes = workInProgress.stateNode),
+        popHostContainer(),
+        renderLanes.pendingContext &&
+          ((renderLanes.context = renderLanes.pendingContext),
+          (renderLanes.pendingContext = null)),
+        (null !== current && null !== current.child) ||
+          null === current ||
+          (current.memoizedState.isDehydrated &&
+            0 === (workInProgress.flags & 256)) ||
+          ((workInProgress.flags |= 1024),
+          null !== hydrationErrors &&
+            (queueRecoverableErrors(hydrationErrors),
+            (hydrationErrors = null))),
+        bubbleProperties(workInProgress),
+        null
+      );
     case 26:
     case 27:
     case 5:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
-      break;
-    case 12:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      flags & 4 && commitProfilerUpdate(finishedWork, current);
-      break;
-    case 13:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      break;
-    case 22:
-      if (0 !== (finishedWork.mode & 1)) {
-        if (
-          ((prevProps =
-            null !== finishedWork.memoizedState || offscreenSubtreeIsHidden),
-          !prevProps)
-        ) {
-          current =
-            (null !== current && null !== current.memoizedState) ||
-            offscreenSubtreeWasHidden;
-          var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
-            prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
-          offscreenSubtreeIsHidden = prevProps;
-          (offscreenSubtreeWasHidden = current) &&
-          !prevOffscreenSubtreeWasHidden
-            ? recursivelyTraverseReappearLayoutEffects(
-                finishedRoot,
-                finishedWork,
-                0 !== (finishedWork.subtreeFlags & 8772)
-              )
-            : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
-          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
+      popHostContext(workInProgress);
+      var type = workInProgress.type;
+      if (null !== current && null != workInProgress.stateNode)
+        current.memoizedProps !== newProps && (workInProgress.flags |= 4);
+      else {
+        if (!newProps) {
+          if (null === workInProgress.stateNode)
+            throw Error(
+              "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
+            );
+          bubbleProperties(workInProgress);
+          return null;
         }
-      } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-      flags & 512 &&
-        ("manual" === finishedWork.memoizedProps.mode
-          ? safelyAttachRef(finishedWork, finishedWork.return)
-          : safelyDetachRef(finishedWork, finishedWork.return));
-      break;
-    default:
-      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
-  }
-}
-function detachFiberAfterEffects(fiber) {
-  var alternate = fiber.alternate;
-  null !== alternate &&
-    ((fiber.alternate = null), detachFiberAfterEffects(alternate));
-  fiber.child = null;
-  fiber.deletions = null;
-  fiber.sibling = null;
-  fiber.stateNode = null;
-  fiber.return = null;
-  fiber.dependencies = null;
-  fiber.memoizedProps = null;
-  fiber.memoizedState = null;
-  fiber.pendingProps = null;
-  fiber.stateNode = null;
-  fiber.updateQueue = null;
-}
-function isHostParent(fiber) {
-  return 5 === fiber.tag || 3 === fiber.tag || 4 === fiber.tag;
-}
-function getHostSibling(fiber) {
-  a: for (;;) {
-    for (; null === fiber.sibling; ) {
-      if (null === fiber.return || isHostParent(fiber.return)) return null;
-      fiber = fiber.return;
-    }
-    fiber.sibling.return = fiber.return;
-    for (
-      fiber = fiber.sibling;
-      5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;
-
-    ) {
-      if (fiber.flags & 2) continue a;
-      if (null === fiber.child || 4 === fiber.tag) continue a;
-      else (fiber.child.return = fiber), (fiber = fiber.child);
-    }
-    if (!(fiber.flags & 2)) return fiber.stateNode;
-  }
-}
-function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
-  var tag = node.tag;
-  if (5 === tag || 6 === tag)
-    if (((node = node.stateNode), before)) {
-      if ("number" === typeof parent)
-        throw Error("Container does not support insertBefore operation");
-    } else
-      ReactNativePrivateInterface.UIManager.setChildren(parent, [
-        "number" === typeof node ? node : node._nativeTag
-      ]);
-  else if (4 !== tag && ((node = node.child), null !== node))
-    for (
-      insertOrAppendPlacementNodeIntoContainer(node, before, parent),
-        node = node.sibling;
-      null !== node;
-
-    )
-      insertOrAppendPlacementNodeIntoContainer(node, before, parent),
-        (node = node.sibling);
-}
-function insertOrAppendPlacementNode(node, before, parent) {
-  var tag = node.tag;
-  if (5 === tag || 6 === tag)
-    if (((node = node.stateNode), before)) {
-      tag = parent._children;
-      var index = tag.indexOf(node);
-      0 <= index
-        ? (tag.splice(index, 1),
-          (before = tag.indexOf(before)),
-          tag.splice(before, 0, node),
-          ReactNativePrivateInterface.UIManager.manageChildren(
-            parent._nativeTag,
-            [index],
-            [before],
-            [],
-            [],
-            []
-          ))
-        : ((before = tag.indexOf(before)),
-          tag.splice(before, 0, node),
-          ReactNativePrivateInterface.UIManager.manageChildren(
-            parent._nativeTag,
-            [],
-            [],
-            ["number" === typeof node ? node : node._nativeTag],
-            [before],
-            []
-          ));
-    } else
-      (before = "number" === typeof node ? node : node._nativeTag),
-        (tag = parent._children),
-        (index = tag.indexOf(node)),
-        0 <= index
-          ? (tag.splice(index, 1),
-            tag.push(node),
-            ReactNativePrivateInterface.UIManager.manageChildren(
-              parent._nativeTag,
-              [index],
-              [tag.length - 1],
-              [],
-              [],
-              []
-            ))
-          : (tag.push(node),
-            ReactNativePrivateInterface.UIManager.manageChildren(
-              parent._nativeTag,
-              [],
-              [],
-              [before],
-              [tag.length - 1],
-              []
-            ));
-  else if (4 !== tag && ((node = node.child), null !== node))
-    for (
-      insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
-      null !== node;
-
-    )
-      insertOrAppendPlacementNode(node, before, parent), (node = node.sibling);
-}
-var hostParent = null,
-  hostParentIsContainer = !1;
-function recursivelyTraverseDeletionEffects(
-  finishedRoot,
-  nearestMountedAncestor,
-  parent
-) {
-  for (parent = parent.child; null !== parent; )
-    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent),
-      (parent = parent.sibling);
-}
-function commitDeletionEffectsOnFiber(
-  finishedRoot,
-  nearestMountedAncestor,
-  deletedFiber
-) {
-  if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
-    try {
-      injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
-    } catch (err) {}
-  switch (deletedFiber.tag) {
-    case 26:
-    case 27:
-    case 5:
-      offscreenSubtreeWasHidden ||
-        safelyDetachRef(deletedFiber, nearestMountedAncestor);
-    case 6:
-      var prevHostParent = hostParent,
-        prevHostParentIsContainer = hostParentIsContainer;
-      hostParent = null;
-      recursivelyTraverseDeletionEffects(
-        finishedRoot,
-        nearestMountedAncestor,
-        deletedFiber
-      );
-      hostParent = prevHostParent;
-      hostParentIsContainer = prevHostParentIsContainer;
-      null !== hostParent &&
-        (hostParentIsContainer
-          ? ((finishedRoot = hostParent),
-            recursivelyUncacheFiberNode(deletedFiber.stateNode),
-            ReactNativePrivateInterface.UIManager.manageChildren(
-              finishedRoot,
-              [],
-              [],
-              [],
-              [],
-              [0]
-            ))
-          : ((finishedRoot = hostParent),
-            (nearestMountedAncestor = deletedFiber.stateNode),
-            recursivelyUncacheFiberNode(nearestMountedAncestor),
-            (deletedFiber = finishedRoot._children),
-            (nearestMountedAncestor = deletedFiber.indexOf(
-              nearestMountedAncestor
-            )),
-            deletedFiber.splice(nearestMountedAncestor, 1),
-            ReactNativePrivateInterface.UIManager.manageChildren(
-              finishedRoot._nativeTag,
-              [],
-              [],
-              [],
-              [],
-              [nearestMountedAncestor]
-            )));
-      break;
-    case 18:
-      null !== hostParent && shim$1();
-      break;
-    case 4:
-      prevHostParent = hostParent;
-      prevHostParentIsContainer = hostParentIsContainer;
-      hostParent = deletedFiber.stateNode.containerInfo;
-      hostParentIsContainer = !0;
-      recursivelyTraverseDeletionEffects(
-        finishedRoot,
-        nearestMountedAncestor,
-        deletedFiber
-      );
-      hostParent = prevHostParent;
-      hostParentIsContainer = prevHostParentIsContainer;
-      break;
-    case 0:
-    case 11:
-    case 14:
-    case 15:
-      if (
-        !offscreenSubtreeWasHidden &&
-        ((prevHostParent = deletedFiber.updateQueue),
-        null !== prevHostParent &&
-          ((prevHostParent = prevHostParent.lastEffect),
-          null !== prevHostParent))
-      ) {
-        prevHostParentIsContainer = prevHostParent = prevHostParent.next;
-        do {
-          var tag = prevHostParentIsContainer.tag,
-            inst = prevHostParentIsContainer.inst,
-            destroy = inst.destroy;
-          void 0 !== destroy &&
-            (0 !== (tag & 2)
-              ? ((inst.destroy = void 0),
-                safelyCallDestroy(
-                  deletedFiber,
-                  nearestMountedAncestor,
-                  destroy
-                ))
-              : 0 !== (tag & 4) &&
-                (shouldProfile(deletedFiber)
-                  ? (startLayoutEffectTimer(),
-                    (inst.destroy = void 0),
-                    safelyCallDestroy(
-                      deletedFiber,
-                      nearestMountedAncestor,
-                      destroy
-                    ),
-                    recordLayoutEffectDuration(deletedFiber))
-                  : ((inst.destroy = void 0),
-                    safelyCallDestroy(
-                      deletedFiber,
-                      nearestMountedAncestor,
-                      destroy
-                    ))));
-          prevHostParentIsContainer = prevHostParentIsContainer.next;
-        } while (prevHostParentIsContainer !== prevHostParent);
+        current = rootInstanceStackCursor.current;
+        renderLanes = allocateTag();
+        type = getViewConfigForType(type);
+        var updatePayload = diffProperties(
+          null,
+          emptyObject,
+          newProps,
+          type.validAttributes
+        );
+        ReactNativePrivateInterface.UIManager.createView(
+          renderLanes,
+          type.uiViewClassName,
+          current,
+          updatePayload
+        );
+        current = new ReactNativeFiberHostComponent(
+          renderLanes,
+          type,
+          workInProgress
+        );
+        instanceCache.set(renderLanes, workInProgress);
+        instanceProps.set(renderLanes, newProps);
+        a: for (renderLanes = workInProgress.child; null !== renderLanes; ) {
+          if (5 === renderLanes.tag || 6 === renderLanes.tag)
+            current._children.push(renderLanes.stateNode);
+          else if (4 !== renderLanes.tag && null !== renderLanes.child) {
+            renderLanes.child.return = renderLanes;
+            renderLanes = renderLanes.child;
+            continue;
+          }
+          if (renderLanes === workInProgress) break a;
+          for (; null === renderLanes.sibling; ) {
+            if (
+              null === renderLanes.return ||
+              renderLanes.return === workInProgress
+            )
+              break a;
+            renderLanes = renderLanes.return;
+          }
+          renderLanes.sibling.return = renderLanes.return;
+          renderLanes = renderLanes.sibling;
+        }
+        workInProgress.stateNode = current;
+        finalizeInitialChildren(current) && (workInProgress.flags |= 4);
       }
-      recursivelyTraverseDeletionEffects(
-        finishedRoot,
-        nearestMountedAncestor,
-        deletedFiber
-      );
-      break;
-    case 1:
+      bubbleProperties(workInProgress);
+      workInProgress.flags &= -16777217;
+      return null;
+    case 6:
+      if (current && null != workInProgress.stateNode)
+        current.memoizedProps !== newProps && (workInProgress.flags |= 4);
+      else {
+        if ("string" !== typeof newProps && null === workInProgress.stateNode)
+          throw Error(
+            "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
+          );
+        renderLanes = rootInstanceStackCursor.current;
+        if (!contextStackCursor.current.isInAParentText)
+          throw Error(
+            "Text strings must be rendered within a <Text> component."
+          );
+        current = allocateTag();
+        ReactNativePrivateInterface.UIManager.createView(
+          current,
+          "RCTRawText",
+          renderLanes,
+          { text: newProps }
+        );
+        instanceCache.set(current, workInProgress);
+        workInProgress.stateNode = current;
+      }
+      bubbleProperties(workInProgress);
+      return null;
+    case 13:
+      newProps = workInProgress.memoizedState;
       if (
-        !offscreenSubtreeWasHidden &&
-        (safelyDetachRef(deletedFiber, nearestMountedAncestor),
-        (prevHostParent = deletedFiber.stateNode),
-        "function" === typeof prevHostParent.componentWillUnmount)
-      )
-        try {
-          callComponentWillUnmountWithTimer(deletedFiber, prevHostParent);
-        } catch (error) {
-          captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
+        null === current ||
+        (null !== current.memoizedState &&
+          null !== current.memoizedState.dehydrated)
+      ) {
+        if (null !== newProps && null !== newProps.dehydrated) {
+          if (null === current) {
+            throw Error(
+              "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
+            );
+            throw Error(
+              "Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue."
+            );
+          }
+          0 === (workInProgress.flags & 128) &&
+            (workInProgress.memoizedState = null);
+          workInProgress.flags |= 4;
+          bubbleProperties(workInProgress);
+          0 !== (workInProgress.mode & 2) &&
+            null !== newProps &&
+            ((type = workInProgress.child),
+            null !== type &&
+              (workInProgress.treeBaseDuration -= type.treeBaseDuration));
+          type = !1;
+        } else
+          null !== hydrationErrors &&
+            (queueRecoverableErrors(hydrationErrors), (hydrationErrors = null)),
+            (type = !0);
+        if (!type) {
+          if (workInProgress.flags & 256)
+            return popSuspenseHandler(workInProgress), workInProgress;
+          popSuspenseHandler(workInProgress);
+          return null;
         }
-      recursivelyTraverseDeletionEffects(
-        finishedRoot,
-        nearestMountedAncestor,
-        deletedFiber
-      );
-      break;
-    case 21:
-      recursivelyTraverseDeletionEffects(
-        finishedRoot,
-        nearestMountedAncestor,
-        deletedFiber
-      );
-      break;
-    case 22:
-      safelyDetachRef(deletedFiber, nearestMountedAncestor);
-      deletedFiber.mode & 1
-        ? ((offscreenSubtreeWasHidden =
-            (prevHostParent = offscreenSubtreeWasHidden) ||
-            null !== deletedFiber.memoizedState),
-          recursivelyTraverseDeletionEffects(
-            finishedRoot,
-            nearestMountedAncestor,
-            deletedFiber
-          ),
-          (offscreenSubtreeWasHidden = prevHostParent))
-        : recursivelyTraverseDeletionEffects(
-            finishedRoot,
-            nearestMountedAncestor,
-            deletedFiber
-          );
-      break;
-    default:
-      recursivelyTraverseDeletionEffects(
-        finishedRoot,
-        nearestMountedAncestor,
-        deletedFiber
+      }
+      popSuspenseHandler(workInProgress);
+      if (0 !== (workInProgress.flags & 128))
+        return (
+          (workInProgress.lanes = renderLanes),
+          0 !== (workInProgress.mode & 2) &&
+            transferActualDuration(workInProgress),
+          workInProgress
+        );
+      renderLanes = null !== newProps;
+      renderLanes !== (null !== current && null !== current.memoizedState) &&
+        renderLanes &&
+        (workInProgress.child.flags |= 8192);
+      scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
+      bubbleProperties(workInProgress);
+      0 !== (workInProgress.mode & 2) &&
+        renderLanes &&
+        ((renderLanes = workInProgress.child),
+        null !== renderLanes &&
+          (workInProgress.treeBaseDuration -= renderLanes.treeBaseDuration));
+      return null;
+    case 4:
+      return popHostContainer(), bubbleProperties(workInProgress), null;
+    case 10:
+      return (
+        popProvider(workInProgress.type._context),
+        bubbleProperties(workInProgress),
+        null
       );
-  }
-}
-function getRetryCache(finishedWork) {
-  switch (finishedWork.tag) {
-    case 13:
+    case 17:
+      return bubbleProperties(workInProgress), null;
     case 19:
-      var retryCache = finishedWork.stateNode;
-      null === retryCache &&
-        (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
-      return retryCache;
+      pop(suspenseStackCursor);
+      type = workInProgress.memoizedState;
+      if (null === type) return bubbleProperties(workInProgress), null;
+      newProps = 0 !== (workInProgress.flags & 128);
+      updatePayload = type.rendering;
+      if (null === updatePayload)
+        if (newProps) cutOffTailIfNeeded(type, !1);
+        else {
+          if (
+            0 !== workInProgressRootExitStatus ||
+            (null !== current && 0 !== (current.flags & 128))
+          )
+            for (current = workInProgress.child; null !== current; ) {
+              updatePayload = findFirstSuspended(current);
+              if (null !== updatePayload) {
+                workInProgress.flags |= 128;
+                cutOffTailIfNeeded(type, !1);
+                current = updatePayload.updateQueue;
+                workInProgress.updateQueue = current;
+                scheduleRetryEffect(workInProgress, current);
+                workInProgress.subtreeFlags = 0;
+                for (current = workInProgress.child; null !== current; )
+                  resetWorkInProgress(current, renderLanes),
+                    (current = current.sibling);
+                push(
+                  suspenseStackCursor,
+                  (suspenseStackCursor.current & 1) | 2
+                );
+                return workInProgress.child;
+              }
+              current = current.sibling;
+            }
+          null !== type.tail &&
+            now$1() > workInProgressRootRenderTargetTime &&
+            ((workInProgress.flags |= 128),
+            (newProps = !0),
+            cutOffTailIfNeeded(type, !1),
+            (workInProgress.lanes = 4194304));
+        }
+      else {
+        if (!newProps)
+          if (
+            ((current = findFirstSuspended(updatePayload)), null !== current)
+          ) {
+            if (
+              ((workInProgress.flags |= 128),
+              (newProps = !0),
+              (renderLanes = current.updateQueue),
+              (workInProgress.updateQueue = renderLanes),
+              scheduleRetryEffect(workInProgress, renderLanes),
+              cutOffTailIfNeeded(type, !0),
+              null === type.tail &&
+                "hidden" === type.tailMode &&
+                !updatePayload.alternate)
+            )
+              return bubbleProperties(workInProgress), null;
+          } else
+            2 * now$1() - type.renderingStartTime >
+              workInProgressRootRenderTargetTime &&
+              536870912 !== renderLanes &&
+              ((workInProgress.flags |= 128),
+              (newProps = !0),
+              cutOffTailIfNeeded(type, !1),
+              (workInProgress.lanes = 4194304));
+        type.isBackwards
+          ? ((updatePayload.sibling = workInProgress.child),
+            (workInProgress.child = updatePayload))
+          : ((renderLanes = type.last),
+            null !== renderLanes
+              ? (renderLanes.sibling = updatePayload)
+              : (workInProgress.child = updatePayload),
+            (type.last = updatePayload));
+      }
+      if (null !== type.tail)
+        return (
+          (workInProgress = type.tail),
+          (type.rendering = workInProgress),
+          (type.tail = workInProgress.sibling),
+          (type.renderingStartTime = now$1()),
+          (workInProgress.sibling = null),
+          (renderLanes = suspenseStackCursor.current),
+          push(
+            suspenseStackCursor,
+            newProps ? (renderLanes & 1) | 2 : renderLanes & 1
+          ),
+          workInProgress
+        );
+      bubbleProperties(workInProgress);
+      return null;
     case 22:
+    case 23:
       return (
-        (finishedWork = finishedWork.stateNode),
-        (retryCache = finishedWork._retryCache),
-        null === retryCache &&
-          (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),
-        retryCache
-      );
-    default:
-      throw Error(
-        "Unexpected Suspense handler tag (" +
-          finishedWork.tag +
-          "). This is a bug in React."
+        popSuspenseHandler(workInProgress),
+        popHiddenContext(),
+        (newProps = null !== workInProgress.memoizedState),
+        null !== current
+          ? (null !== current.memoizedState) !== newProps &&
+            (workInProgress.flags |= 8192)
+          : newProps && (workInProgress.flags |= 8192),
+        newProps && 0 !== (workInProgress.mode & 1)
+          ? 0 !== (renderLanes & 536870912) &&
+            0 === (workInProgress.flags & 128) &&
+            (bubbleProperties(workInProgress),
+            workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192))
+          : bubbleProperties(workInProgress),
+        (renderLanes = workInProgress.updateQueue),
+        null !== renderLanes &&
+          scheduleRetryEffect(workInProgress, renderLanes.retryQueue),
+        null
       );
+    case 24:
+      return null;
+    case 25:
+      return null;
   }
+  throw Error(
+    "Unknown unit of work tag (" +
+      workInProgress.tag +
+      "). This error is likely caused by a bug in React. Please file an issue."
+  );
 }
-function attachSuspenseRetryListeners(finishedWork, wakeables) {
-  var retryCache = getRetryCache(finishedWork);
-  wakeables.forEach(function (wakeable) {
-    var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
-    if (!retryCache.has(wakeable)) {
-      retryCache.add(wakeable);
-      if (isDevToolsPresent)
-        if (null !== inProgressLanes && null !== inProgressRoot)
-          restorePendingUpdaters(inProgressRoot, inProgressLanes);
-        else
-          throw Error(
-            "Expected finished root and lanes to be set. This is a bug in React."
-          );
-      wakeable.then(retry, retry);
-    }
-  });
-}
-function commitMutationEffects(root, finishedWork, committedLanes) {
-  inProgressLanes = committedLanes;
-  inProgressRoot = root;
-  commitMutationEffectsOnFiber(finishedWork, root);
-  inProgressRoot = inProgressLanes = null;
-}
-function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
-  var deletions = parentFiber.deletions;
-  if (null !== deletions)
-    for (var i = 0; i < deletions.length; i++) {
-      var childToDelete = deletions[i];
-      try {
-        var root = root$jscomp$0,
-          returnFiber = parentFiber,
-          parent = returnFiber;
-        a: for (; null !== parent; ) {
-          switch (parent.tag) {
-            case 27:
-            case 5:
-              hostParent = parent.stateNode;
-              hostParentIsContainer = !1;
-              break a;
-            case 3:
-              hostParent = parent.stateNode.containerInfo;
-              hostParentIsContainer = !0;
-              break a;
-            case 4:
-              hostParent = parent.stateNode.containerInfo;
-              hostParentIsContainer = !0;
-              break a;
-          }
-          parent = parent.return;
-        }
-        if (null === hostParent)
-          throw Error(
-            "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
-          );
-        commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);
-        hostParent = null;
-        hostParentIsContainer = !1;
-        var alternate = childToDelete.alternate;
-        null !== alternate && (alternate.return = null);
-        childToDelete.return = null;
-      } catch (error) {
-        captureCommitPhaseError(childToDelete, parentFiber, error);
-      }
-    }
-  if (parentFiber.subtreeFlags & 12854)
-    for (parentFiber = parentFiber.child; null !== parentFiber; )
-      commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),
-        (parentFiber = parentFiber.sibling);
-}
-function commitMutationEffectsOnFiber(finishedWork, root) {
-  var current = finishedWork.alternate,
-    flags = finishedWork.flags;
-  switch (finishedWork.tag) {
-    case 0:
-    case 11:
-    case 14:
-    case 15:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      if (flags & 4) {
-        try {
-          commitHookEffectListUnmount(3, finishedWork, finishedWork.return),
-            commitHookEffectListMount(3, finishedWork);
-        } catch (error) {
-          captureCommitPhaseError(finishedWork, finishedWork.return, error);
-        }
-        if (shouldProfile(finishedWork)) {
-          try {
-            startLayoutEffectTimer(),
-              commitHookEffectListUnmount(5, finishedWork, finishedWork.return);
-          } catch (error$100) {
-            captureCommitPhaseError(
-              finishedWork,
-              finishedWork.return,
-              error$100
-            );
-          }
-          recordLayoutEffectDuration(finishedWork);
-        } else
-          try {
-            commitHookEffectListUnmount(5, finishedWork, finishedWork.return);
-          } catch (error$101) {
-            captureCommitPhaseError(
-              finishedWork,
-              finishedWork.return,
-              error$101
-            );
-          }
-      }
-      break;
+function unwindWork(current, workInProgress) {
+  switch (workInProgress.tag) {
     case 1:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      flags & 512 &&
-        null !== current &&
-        safelyDetachRef(current, current.return);
-      flags & 64 &&
-        offscreenSubtreeIsHidden &&
-        ((finishedWork = finishedWork.updateQueue),
-        null !== finishedWork &&
-          ((flags = finishedWork.callbacks),
-          null !== flags &&
-            ((current = finishedWork.shared.hiddenCallbacks),
-            (finishedWork.shared.hiddenCallbacks =
-              null === current ? flags : current.concat(flags)))));
-      break;
+      return (
+        (current = workInProgress.flags),
+        current & 65536
+          ? ((workInProgress.flags = (current & -65537) | 128),
+            0 !== (workInProgress.mode & 2) &&
+              transferActualDuration(workInProgress),
+            workInProgress)
+          : null
+      );
+    case 3:
+      return (
+        popHostContainer(),
+        (current = workInProgress.flags),
+        0 !== (current & 65536) && 0 === (current & 128)
+          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)
+          : null
+      );
     case 26:
     case 27:
     case 5:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      flags & 512 &&
+      return popHostContext(workInProgress), null;
+    case 13:
+      popSuspenseHandler(workInProgress);
+      current = workInProgress.memoizedState;
+      if (
         null !== current &&
-        safelyDetachRef(current, current.return);
-      if (flags & 4 && ((flags = finishedWork.stateNode), null != flags)) {
-        var newProps = finishedWork.memoizedProps;
-        current = null !== current ? current.memoizedProps : newProps;
-        finishedWork.updateQueue = null;
-        try {
-          var viewConfig = flags.viewConfig;
-          instanceProps.set(flags._nativeTag, newProps);
-          var updatePayload = diffProperties(
-            null,
-            current,
-            newProps,
-            viewConfig.validAttributes
-          );
-          null != updatePayload &&
-            ReactNativePrivateInterface.UIManager.updateView(
-              flags._nativeTag,
-              viewConfig.uiViewClassName,
-              updatePayload
-            );
-        } catch (error$104) {
-          captureCommitPhaseError(finishedWork, finishedWork.return, error$104);
-        }
-      }
-      break;
-    case 6:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      if (flags & 4) {
-        if (null === finishedWork.stateNode)
-          throw Error(
-            "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
-          );
-        flags = finishedWork.stateNode;
-        current = finishedWork.memoizedProps;
-        try {
-          ReactNativePrivateInterface.UIManager.updateView(
-            flags,
-            "RCTRawText",
-            { text: current }
-          );
-        } catch (error$105) {
-          captureCommitPhaseError(finishedWork, finishedWork.return, error$105);
-        }
-      }
-      break;
+        null !== current.dehydrated &&
+        null === workInProgress.alternate
+      )
+        throw Error(
+          "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
+        );
+      current = workInProgress.flags;
+      return current & 65536
+        ? ((workInProgress.flags = (current & -65537) | 128),
+          0 !== (workInProgress.mode & 2) &&
+            transferActualDuration(workInProgress),
+          workInProgress)
+        : null;
+    case 19:
+      return pop(suspenseStackCursor), null;
+    case 4:
+      return popHostContainer(), null;
+    case 10:
+      return popProvider(workInProgress.type._context), null;
+    case 22:
+    case 23:
+      return (
+        popSuspenseHandler(workInProgress),
+        popHiddenContext(),
+        (current = workInProgress.flags),
+        current & 65536
+          ? ((workInProgress.flags = (current & -65537) | 128),
+            0 !== (workInProgress.mode & 2) &&
+              transferActualDuration(workInProgress),
+            workInProgress)
+          : null
+      );
+    case 24:
+      return null;
+    case 25:
+      return null;
+    default:
+      return null;
+  }
+}
+function unwindInterruptedWork(current, interruptedWork) {
+  switch (interruptedWork.tag) {
     case 3:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
+      popHostContainer();
+      break;
+    case 26:
+    case 27:
+    case 5:
+      popHostContext(interruptedWork);
       break;
     case 4:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
+      popHostContainer();
       break;
     case 13:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      finishedWork.child.flags & 8192 &&
-        ((current = null !== current && null !== current.memoizedState),
-        null === finishedWork.memoizedState ||
-          current ||
-          (globalMostRecentFallbackTime = now$1()));
-      flags & 4 &&
-        ((flags = finishedWork.updateQueue),
-        null !== flags &&
-          ((finishedWork.updateQueue = null),
-          attachSuspenseRetryListeners(finishedWork, flags)));
+      popSuspenseHandler(interruptedWork);
+      break;
+    case 19:
+      pop(suspenseStackCursor);
+      break;
+    case 10:
+      popProvider(interruptedWork.type._context);
       break;
     case 22:
-      flags & 512 &&
-        null !== current &&
-        safelyDetachRef(current, current.return);
-      viewConfig = null !== finishedWork.memoizedState;
-      updatePayload = null !== current && null !== current.memoizedState;
-      if (finishedWork.mode & 1) {
-        var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
-          prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
-        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || viewConfig;
-        offscreenSubtreeWasHidden =
-          prevOffscreenSubtreeWasHidden || updatePayload;
-        recursivelyTraverseMutationEffects(root, finishedWork);
-        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
-        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
-      } else recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      root = finishedWork.stateNode;
-      root._current = finishedWork;
-      root._visibility &= -3;
-      root._visibility |= root._pendingVisibility & 2;
-      if (
-        flags & 8192 &&
-        ((root._visibility = viewConfig
-          ? root._visibility & -2
-          : root._visibility | 1),
-        viewConfig &&
-          ((root = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden),
-          null === current ||
-            updatePayload ||
-            root ||
-            (0 !== (finishedWork.mode & 1) &&
-              recursivelyTraverseDisappearLayoutEffects(finishedWork))),
-        null === finishedWork.memoizedProps ||
-          "manual" !== finishedWork.memoizedProps.mode)
-      )
-        a: for (current = null, root = finishedWork; ; ) {
-          if (5 === root.tag) {
-            if (null === current) {
-              current = root;
-              try {
-                if (((newProps = root.stateNode), viewConfig)) {
-                  var viewConfig$jscomp$0 = newProps.viewConfig;
-                  var updatePayload$jscomp$0 = diffProperties(
-                    null,
-                    emptyObject,
-                    { style: { display: "none" } },
-                    viewConfig$jscomp$0.validAttributes
-                  );
-                  ReactNativePrivateInterface.UIManager.updateView(
-                    newProps._nativeTag,
-                    viewConfig$jscomp$0.uiViewClassName,
-                    updatePayload$jscomp$0
-                  );
-                } else {
-                  var instance = root.stateNode,
-                    props = root.memoizedProps,
-                    viewConfig$jscomp$1 = instance.viewConfig,
-                    prevProps = assign({}, props, {
-                      style: [props.style, { display: "none" }]
-                    });
-                  var updatePayload$jscomp$1 = diffProperties(
-                    null,
-                    prevProps,
-                    props,
-                    viewConfig$jscomp$1.validAttributes
-                  );
-                  ReactNativePrivateInterface.UIManager.updateView(
-                    instance._nativeTag,
-                    viewConfig$jscomp$1.uiViewClassName,
-                    updatePayload$jscomp$1
+    case 23:
+      popSuspenseHandler(interruptedWork), popHiddenContext();
+  }
+}
+var offscreenSubtreeIsHidden = !1,
+  offscreenSubtreeWasHidden = !1,
+  PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
+  nextEffect = null,
+  inProgressLanes = null,
+  inProgressRoot = null;
+function shouldProfile(current) {
+  return 0 !== (current.mode & 2) && 0 !== (executionContext & 4);
+}
+function callComponentWillUnmountWithTimer(current, instance) {
+  instance.props = current.memoizedProps;
+  instance.state = current.memoizedState;
+  if (shouldProfile(current))
+    try {
+      startLayoutEffectTimer(), instance.componentWillUnmount();
+    } finally {
+      recordLayoutEffectDuration(current);
+    }
+  else instance.componentWillUnmount();
+}
+function safelyAttachRef(current, nearestMountedAncestor) {
+  try {
+    var ref = current.ref;
+    if (null !== ref) {
+      var instance = current.stateNode;
+      switch (current.tag) {
+        case 26:
+        case 27:
+        case 5:
+          var instanceToUse = getPublicInstance(instance);
+          break;
+        default:
+          instanceToUse = instance;
+      }
+      if ("function" === typeof ref)
+        if (shouldProfile(current))
+          try {
+            startLayoutEffectTimer(), (current.refCleanup = ref(instanceToUse));
+          } finally {
+            recordLayoutEffectDuration(current);
+          }
+        else current.refCleanup = ref(instanceToUse);
+      else ref.current = instanceToUse;
+    }
+  } catch (error) {
+    captureCommitPhaseError(current, nearestMountedAncestor, error);
+  }
+}
+function safelyDetachRef(current, nearestMountedAncestor) {
+  var ref = current.ref,
+    refCleanup = current.refCleanup;
+  if (null !== ref)
+    if ("function" === typeof refCleanup)
+      try {
+        if (shouldProfile(current))
+          try {
+            startLayoutEffectTimer(), refCleanup();
+          } finally {
+            recordLayoutEffectDuration(current);
+          }
+        else refCleanup();
+      } catch (error) {
+        captureCommitPhaseError(current, nearestMountedAncestor, error);
+      } finally {
+        (current.refCleanup = null),
+          (current = current.alternate),
+          null != current && (current.refCleanup = null);
+      }
+    else if ("function" === typeof ref)
+      try {
+        if (shouldProfile(current))
+          try {
+            startLayoutEffectTimer(), ref(null);
+          } finally {
+            recordLayoutEffectDuration(current);
+          }
+        else ref(null);
+      } catch (error$84) {
+        captureCommitPhaseError(current, nearestMountedAncestor, error$84);
+      }
+    else ref.current = null;
+}
+function safelyCallDestroy(current, nearestMountedAncestor, destroy) {
+  try {
+    destroy();
+  } catch (error) {
+    captureCommitPhaseError(current, nearestMountedAncestor, error);
+  }
+}
+var shouldFireAfterActiveInstanceBlur = !1;
+function commitBeforeMutationEffects(root, firstChild) {
+  for (nextEffect = firstChild; null !== nextEffect; )
+    if (
+      ((root = nextEffect),
+      (firstChild = root.child),
+      0 !== (root.subtreeFlags & 1028) && null !== firstChild)
+    )
+      (firstChild.return = root), (nextEffect = firstChild);
+    else
+      for (; null !== nextEffect; ) {
+        root = nextEffect;
+        try {
+          var current = root.alternate,
+            flags = root.flags;
+          switch (root.tag) {
+            case 0:
+              break;
+            case 11:
+            case 15:
+              break;
+            case 1:
+              if (0 !== (flags & 1024) && null !== current) {
+                var prevProps = current.memoizedProps,
+                  prevState = current.memoizedState,
+                  instance = root.stateNode,
+                  snapshot = instance.getSnapshotBeforeUpdate(
+                    root.elementType === root.type
+                      ? prevProps
+                      : resolveDefaultProps(root.type, prevProps),
+                    prevState
                   );
-                }
-              } catch (error) {
-                captureCommitPhaseError(
-                  finishedWork,
-                  finishedWork.return,
-                  error
-                );
+                instance.__reactInternalSnapshotBeforeUpdate = snapshot;
               }
-            }
-          } else if (6 === root.tag) {
-            if (null === current)
-              try {
-                throw Error("Not yet implemented.");
-              } catch (error$94) {
-                captureCommitPhaseError(
-                  finishedWork,
-                  finishedWork.return,
-                  error$94
+              break;
+            case 3:
+              break;
+            case 5:
+            case 26:
+            case 27:
+            case 6:
+            case 4:
+            case 17:
+              break;
+            default:
+              if (0 !== (flags & 1024))
+                throw Error(
+                  "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
                 );
-              }
-          } else if (
-            ((22 !== root.tag && 23 !== root.tag) ||
-              null === root.memoizedState ||
-              root === finishedWork) &&
-            null !== root.child
-          ) {
-            root.child.return = root;
-            root = root.child;
-            continue;
-          }
-          if (root === finishedWork) break a;
-          for (; null === root.sibling; ) {
-            if (null === root.return || root.return === finishedWork) break a;
-            current === root && (current = null);
-            root = root.return;
           }
-          current === root && (current = null);
-          root.sibling.return = root.return;
-          root = root.sibling;
+        } catch (error) {
+          captureCommitPhaseError(root, root.return, error);
         }
-      flags & 4 &&
-        ((flags = finishedWork.updateQueue),
-        null !== flags &&
-          ((current = flags.retryQueue),
-          null !== current &&
-            ((flags.retryQueue = null),
-            attachSuspenseRetryListeners(finishedWork, current))));
-      break;
-    case 19:
-      recursivelyTraverseMutationEffects(root, finishedWork);
-      commitReconciliationEffects(finishedWork);
-      flags & 4 &&
-        ((flags = finishedWork.updateQueue),
-        null !== flags &&
-          ((finishedWork.updateQueue = null),
-          attachSuspenseRetryListeners(finishedWork, flags)));
-      break;
-    case 21:
-      break;
-    default:
-      recursivelyTraverseMutationEffects(root, finishedWork),
-        commitReconciliationEffects(finishedWork);
+        firstChild = root.sibling;
+        if (null !== firstChild) {
+          firstChild.return = root.return;
+          nextEffect = firstChild;
+          break;
+        }
+        nextEffect = root.return;
+      }
+  current = shouldFireAfterActiveInstanceBlur;
+  shouldFireAfterActiveInstanceBlur = !1;
+  return current;
+}
+function commitHookEffectListUnmount(
+  flags,
+  finishedWork,
+  nearestMountedAncestor
+) {
+  var updateQueue = finishedWork.updateQueue;
+  updateQueue = null !== updateQueue ? updateQueue.lastEffect : null;
+  if (null !== updateQueue) {
+    var effect = (updateQueue = updateQueue.next);
+    do {
+      if ((effect.tag & flags) === flags) {
+        var inst = effect.inst,
+          destroy = inst.destroy;
+        void 0 !== destroy &&
+          ((inst.destroy = void 0),
+          safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy));
+      }
+      effect = effect.next;
+    } while (effect !== updateQueue);
   }
 }
-function commitReconciliationEffects(finishedWork) {
-  var flags = finishedWork.flags;
-  if (flags & 2) {
+function commitHookEffectListMount(flags, finishedWork) {
+  finishedWork = finishedWork.updateQueue;
+  finishedWork = null !== finishedWork ? finishedWork.lastEffect : null;
+  if (null !== finishedWork) {
+    var effect = (finishedWork = finishedWork.next);
+    do {
+      if ((effect.tag & flags) === flags) {
+        var create$85 = effect.create,
+          inst = effect.inst;
+        create$85 = create$85();
+        inst.destroy = create$85;
+      }
+      effect = effect.next;
+    } while (effect !== finishedWork);
+  }
+}
+function commitHookLayoutEffects(finishedWork, hookFlags) {
+  if (shouldProfile(finishedWork)) {
     try {
-      a: {
-        for (var parent = finishedWork.return; null !== parent; ) {
-          if (isHostParent(parent)) {
-            var JSCompiler_inline_result = parent;
+      startLayoutEffectTimer(),
+        commitHookEffectListMount(hookFlags, finishedWork);
+    } catch (error) {
+      captureCommitPhaseError(finishedWork, finishedWork.return, error);
+    }
+    recordLayoutEffectDuration(finishedWork);
+  } else
+    try {
+      commitHookEffectListMount(hookFlags, finishedWork);
+    } catch (error$87) {
+      captureCommitPhaseError(finishedWork, finishedWork.return, error$87);
+    }
+}
+function commitClassCallbacks(finishedWork) {
+  var updateQueue = finishedWork.updateQueue;
+  if (null !== updateQueue) {
+    var instance = finishedWork.stateNode;
+    try {
+      commitCallbacks(updateQueue, instance);
+    } catch (error) {
+      captureCommitPhaseError(finishedWork, finishedWork.return, error);
+    }
+  }
+}
+function commitProfilerUpdate(finishedWork, current) {
+  if (executionContext & 4)
+    try {
+      var _finishedWork$memoize2 = finishedWork.memoizedProps,
+        onCommit = _finishedWork$memoize2.onCommit,
+        onRender = _finishedWork$memoize2.onRender,
+        effectDuration = finishedWork.stateNode.effectDuration;
+      _finishedWork$memoize2 = commitTime;
+      current = null === current ? "mount" : "update";
+      currentUpdateIsNested && (current = "nested-update");
+      "function" === typeof onRender &&
+        onRender(
+          finishedWork.memoizedProps.id,
+          current,
+          finishedWork.actualDuration,
+          finishedWork.treeBaseDuration,
+          finishedWork.actualStartTime,
+          _finishedWork$memoize2
+        );
+      "function" === typeof onCommit &&
+        onCommit(
+          finishedWork.memoizedProps.id,
+          current,
+          effectDuration,
+          _finishedWork$memoize2
+        );
+      enqueuePendingPassiveProfilerEffect(finishedWork);
+      var parentFiber = finishedWork.return;
+      a: for (; null !== parentFiber; ) {
+        switch (parentFiber.tag) {
+          case 3:
+            parentFiber.stateNode.effectDuration += effectDuration;
+            break a;
+          case 12:
+            parentFiber.stateNode.effectDuration += effectDuration;
             break a;
+        }
+        parentFiber = parentFiber.return;
+      }
+    } catch (error) {
+      captureCommitPhaseError(finishedWork, finishedWork.return, error);
+    }
+}
+function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
+  var flags = finishedWork.flags;
+  switch (finishedWork.tag) {
+    case 0:
+    case 11:
+    case 15:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      flags & 4 && commitHookLayoutEffects(finishedWork, 5);
+      break;
+    case 1:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      if (flags & 4)
+        if (((finishedRoot = finishedWork.stateNode), null === current))
+          if (shouldProfile(finishedWork)) {
+            try {
+              startLayoutEffectTimer(), finishedRoot.componentDidMount();
+            } catch (error) {
+              captureCommitPhaseError(finishedWork, finishedWork.return, error);
+            }
+            recordLayoutEffectDuration(finishedWork);
+          } else
+            try {
+              finishedRoot.componentDidMount();
+            } catch (error$88) {
+              captureCommitPhaseError(
+                finishedWork,
+                finishedWork.return,
+                error$88
+              );
+            }
+        else {
+          var prevProps =
+            finishedWork.elementType === finishedWork.type
+              ? current.memoizedProps
+              : resolveDefaultProps(finishedWork.type, current.memoizedProps);
+          current = current.memoizedState;
+          if (shouldProfile(finishedWork)) {
+            try {
+              startLayoutEffectTimer(),
+                finishedRoot.componentDidUpdate(
+                  prevProps,
+                  current,
+                  finishedRoot.__reactInternalSnapshotBeforeUpdate
+                );
+            } catch (error$89) {
+              captureCommitPhaseError(
+                finishedWork,
+                finishedWork.return,
+                error$89
+              );
+            }
+            recordLayoutEffectDuration(finishedWork);
+          } else
+            try {
+              finishedRoot.componentDidUpdate(
+                prevProps,
+                current,
+                finishedRoot.__reactInternalSnapshotBeforeUpdate
+              );
+            } catch (error$90) {
+              captureCommitPhaseError(
+                finishedWork,
+                finishedWork.return,
+                error$90
+              );
+            }
+        }
+      flags & 64 && commitClassCallbacks(finishedWork);
+      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
+      break;
+    case 3:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      if (flags & 64 && ((flags = finishedWork.updateQueue), null !== flags)) {
+        finishedRoot = null;
+        if (null !== finishedWork.child)
+          switch (finishedWork.child.tag) {
+            case 27:
+            case 5:
+              finishedRoot = getPublicInstance(finishedWork.child.stateNode);
+              break;
+            case 1:
+              finishedRoot = finishedWork.child.stateNode;
           }
-          parent = parent.return;
+        try {
+          commitCallbacks(flags, finishedRoot);
+        } catch (error) {
+          captureCommitPhaseError(finishedWork, finishedWork.return, error);
         }
-        throw Error(
-          "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
-        );
-      }
-      switch (JSCompiler_inline_result.tag) {
-        case 27:
-        case 5:
-          var parent$jscomp$0 = JSCompiler_inline_result.stateNode;
-          JSCompiler_inline_result.flags & 32 &&
-            (JSCompiler_inline_result.flags &= -33);
-          var before = getHostSibling(finishedWork);
-          insertOrAppendPlacementNode(finishedWork, before, parent$jscomp$0);
-          break;
-        case 3:
-        case 4:
-          var parent$95 = JSCompiler_inline_result.stateNode.containerInfo,
-            before$96 = getHostSibling(finishedWork);
-          insertOrAppendPlacementNodeIntoContainer(
-            finishedWork,
-            before$96,
-            parent$95
-          );
-          break;
-        default:
-          throw Error(
-            "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
-          );
       }
-    } catch (error) {
-      captureCommitPhaseError(finishedWork, finishedWork.return, error);
-    }
-    finishedWork.flags &= -3;
-  }
-  flags & 4096 && (finishedWork.flags &= -4097);
-}
-function commitLayoutEffects(finishedWork, root, committedLanes) {
-  inProgressLanes = committedLanes;
-  inProgressRoot = root;
-  commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);
-  inProgressRoot = inProgressLanes = null;
-}
-function recursivelyTraverseLayoutEffects(root, parentFiber) {
-  if (parentFiber.subtreeFlags & 8772)
-    for (parentFiber = parentFiber.child; null !== parentFiber; )
-      commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),
-        (parentFiber = parentFiber.sibling);
-}
-function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
-  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
-    var finishedWork = parentFiber;
-    switch (finishedWork.tag) {
-      case 0:
-      case 11:
-      case 14:
-      case 15:
-        if (shouldProfile(finishedWork))
-          try {
-            startLayoutEffectTimer(),
-              commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
-          } finally {
-            recordLayoutEffectDuration(finishedWork);
-          }
-        else commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
-        recursivelyTraverseDisappearLayoutEffects(finishedWork);
-        break;
-      case 1:
-        safelyDetachRef(finishedWork, finishedWork.return);
-        var instance = finishedWork.stateNode;
-        if ("function" === typeof instance.componentWillUnmount) {
-          var current = finishedWork,
-            nearestMountedAncestor = finishedWork.return;
-          try {
-            callComponentWillUnmountWithTimer(current, instance);
-          } catch (error) {
-            captureCommitPhaseError(current, nearestMountedAncestor, error);
-          }
+      break;
+    case 26:
+    case 27:
+    case 5:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
+      break;
+    case 12:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      flags & 4 && commitProfilerUpdate(finishedWork, current);
+      break;
+    case 13:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      break;
+    case 22:
+      if (0 !== (finishedWork.mode & 1)) {
+        if (
+          ((prevProps =
+            null !== finishedWork.memoizedState || offscreenSubtreeIsHidden),
+          !prevProps)
+        ) {
+          current =
+            (null !== current && null !== current.memoizedState) ||
+            offscreenSubtreeWasHidden;
+          var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
+            prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
+          offscreenSubtreeIsHidden = prevProps;
+          (offscreenSubtreeWasHidden = current) &&
+          !prevOffscreenSubtreeWasHidden
+            ? recursivelyTraverseReappearLayoutEffects(
+                finishedRoot,
+                finishedWork,
+                0 !== (finishedWork.subtreeFlags & 8772)
+              )
+            : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
+          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
         }
-        recursivelyTraverseDisappearLayoutEffects(finishedWork);
-        break;
-      case 26:
-      case 27:
-      case 5:
-        safelyDetachRef(finishedWork, finishedWork.return);
-        recursivelyTraverseDisappearLayoutEffects(finishedWork);
-        break;
-      case 22:
-        safelyDetachRef(finishedWork, finishedWork.return);
-        null === finishedWork.memoizedState &&
-          recursivelyTraverseDisappearLayoutEffects(finishedWork);
-        break;
-      default:
-        recursivelyTraverseDisappearLayoutEffects(finishedWork);
-    }
-    parentFiber = parentFiber.sibling;
+      } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
+      flags & 512 &&
+        ("manual" === finishedWork.memoizedProps.mode
+          ? safelyAttachRef(finishedWork, finishedWork.return)
+          : safelyDetachRef(finishedWork, finishedWork.return));
+      break;
+    default:
+      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
   }
 }
-function recursivelyTraverseReappearLayoutEffects(
-  finishedRoot$jscomp$0,
-  parentFiber,
-  includeWorkInProgressEffects
-) {
-  includeWorkInProgressEffects =
-    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
-  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
-    var current = parentFiber.alternate,
-      finishedRoot = finishedRoot$jscomp$0,
-      finishedWork = parentFiber,
-      flags = finishedWork.flags;
-    switch (finishedWork.tag) {
-      case 0:
-      case 11:
-      case 15:
-        recursivelyTraverseReappearLayoutEffects(
-          finishedRoot,
-          finishedWork,
-          includeWorkInProgressEffects
-        );
-        commitHookLayoutEffects(finishedWork, 4);
-        break;
-      case 1:
-        recursivelyTraverseReappearLayoutEffects(
-          finishedRoot,
-          finishedWork,
-          includeWorkInProgressEffects
-        );
-        finishedRoot = finishedWork.stateNode;
-        if ("function" === typeof finishedRoot.componentDidMount)
-          try {
-            finishedRoot.componentDidMount();
-          } catch (error) {
-            captureCommitPhaseError(finishedWork, finishedWork.return, error);
-          }
-        current = finishedWork.updateQueue;
-        if (null !== current) {
-          var hiddenCallbacks = current.shared.hiddenCallbacks;
-          if (null !== hiddenCallbacks)
-            for (
-              current.shared.hiddenCallbacks = null, current = 0;
-              current < hiddenCallbacks.length;
-              current++
-            )
-              callCallback(hiddenCallbacks[current], finishedRoot);
-        }
-        includeWorkInProgressEffects &&
-          flags & 64 &&
-          commitClassCallbacks(finishedWork);
-        safelyAttachRef(finishedWork, finishedWork.return);
-        break;
-      case 26:
-      case 27:
-      case 5:
-        recursivelyTraverseReappearLayoutEffects(
-          finishedRoot,
-          finishedWork,
-          includeWorkInProgressEffects
-        );
-        safelyAttachRef(finishedWork, finishedWork.return);
-        break;
-      case 12:
-        recursivelyTraverseReappearLayoutEffects(
-          finishedRoot,
-          finishedWork,
-          includeWorkInProgressEffects
-        );
-        includeWorkInProgressEffects &&
-          flags & 4 &&
-          commitProfilerUpdate(finishedWork, current);
-        break;
-      case 13:
-        recursivelyTraverseReappearLayoutEffects(
-          finishedRoot,
-          finishedWork,
-          includeWorkInProgressEffects
-        );
-        break;
-      case 22:
-        null === finishedWork.memoizedState &&
-          recursivelyTraverseReappearLayoutEffects(
-            finishedRoot,
-            finishedWork,
-            includeWorkInProgressEffects
-          );
-        safelyAttachRef(finishedWork, finishedWork.return);
-        break;
-      default:
-        recursivelyTraverseReappearLayoutEffects(
-          finishedRoot,
-          finishedWork,
-          includeWorkInProgressEffects
-        );
-    }
-    parentFiber = parentFiber.sibling;
-  }
+function detachFiberAfterEffects(fiber) {
+  var alternate = fiber.alternate;
+  null !== alternate &&
+    ((fiber.alternate = null), detachFiberAfterEffects(alternate));
+  fiber.child = null;
+  fiber.deletions = null;
+  fiber.sibling = null;
+  fiber.stateNode = null;
+  fiber.return = null;
+  fiber.dependencies = null;
+  fiber.memoizedProps = null;
+  fiber.memoizedState = null;
+  fiber.pendingProps = null;
+  fiber.stateNode = null;
+  fiber.updateQueue = null;
 }
-function commitHookPassiveMountEffects(finishedWork, hookFlags) {
-  if (shouldProfile(finishedWork)) {
-    passiveEffectStartTime = now();
-    try {
-      commitHookEffectListMount(hookFlags, finishedWork);
-    } catch (error) {
-      captureCommitPhaseError(finishedWork, finishedWork.return, error);
+function isHostParent(fiber) {
+  return 5 === fiber.tag || 3 === fiber.tag || 4 === fiber.tag;
+}
+function getHostSibling(fiber) {
+  a: for (;;) {
+    for (; null === fiber.sibling; ) {
+      if (null === fiber.return || isHostParent(fiber.return)) return null;
+      fiber = fiber.return;
     }
-    recordPassiveEffectDuration(finishedWork);
-  } else
-    try {
-      commitHookEffectListMount(hookFlags, finishedWork);
-    } catch (error$109) {
-      captureCommitPhaseError(finishedWork, finishedWork.return, error$109);
+    fiber.sibling.return = fiber.return;
+    for (
+      fiber = fiber.sibling;
+      5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;
+
+    ) {
+      if (fiber.flags & 2) continue a;
+      if (null === fiber.child || 4 === fiber.tag) continue a;
+      else (fiber.child.return = fiber), (fiber = fiber.child);
     }
+    if (!(fiber.flags & 2)) return fiber.stateNode;
+  }
 }
-function recursivelyTraversePassiveMountEffects(root, parentFiber) {
-  if (parentFiber.subtreeFlags & 10256)
-    for (parentFiber = parentFiber.child; null !== parentFiber; )
-      commitPassiveMountOnFiber(root, parentFiber),
-        (parentFiber = parentFiber.sibling);
+function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
+  var tag = node.tag;
+  if (5 === tag || 6 === tag)
+    if (((node = node.stateNode), before)) {
+      if ("number" === typeof parent)
+        throw Error("Container does not support insertBefore operation");
+    } else
+      ReactNativePrivateInterface.UIManager.setChildren(parent, [
+        "number" === typeof node ? node : node._nativeTag
+      ]);
+  else if (4 !== tag && ((node = node.child), null !== node))
+    for (
+      insertOrAppendPlacementNodeIntoContainer(node, before, parent),
+        node = node.sibling;
+      null !== node;
+
+    )
+      insertOrAppendPlacementNodeIntoContainer(node, before, parent),
+        (node = node.sibling);
 }
-function commitPassiveMountOnFiber(finishedRoot, finishedWork) {
-  var flags = finishedWork.flags;
-  switch (finishedWork.tag) {
+function insertOrAppendPlacementNode(node, before, parent) {
+  var tag = node.tag;
+  if (5 === tag || 6 === tag)
+    if (((node = node.stateNode), before)) {
+      tag = parent._children;
+      var index = tag.indexOf(node);
+      0 <= index
+        ? (tag.splice(index, 1),
+          (before = tag.indexOf(before)),
+          tag.splice(before, 0, node),
+          ReactNativePrivateInterface.UIManager.manageChildren(
+            parent._nativeTag,
+            [index],
+            [before],
+            [],
+            [],
+            []
+          ))
+        : ((before = tag.indexOf(before)),
+          tag.splice(before, 0, node),
+          ReactNativePrivateInterface.UIManager.manageChildren(
+            parent._nativeTag,
+            [],
+            [],
+            ["number" === typeof node ? node : node._nativeTag],
+            [before],
+            []
+          ));
+    } else
+      (before = "number" === typeof node ? node : node._nativeTag),
+        (tag = parent._children),
+        (index = tag.indexOf(node)),
+        0 <= index
+          ? (tag.splice(index, 1),
+            tag.push(node),
+            ReactNativePrivateInterface.UIManager.manageChildren(
+              parent._nativeTag,
+              [index],
+              [tag.length - 1],
+              [],
+              [],
+              []
+            ))
+          : (tag.push(node),
+            ReactNativePrivateInterface.UIManager.manageChildren(
+              parent._nativeTag,
+              [],
+              [],
+              [before],
+              [tag.length - 1],
+              []
+            ));
+  else if (4 !== tag && ((node = node.child), null !== node))
+    for (
+      insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
+      null !== node;
+
+    )
+      insertOrAppendPlacementNode(node, before, parent), (node = node.sibling);
+}
+var hostParent = null,
+  hostParentIsContainer = !1;
+function recursivelyTraverseDeletionEffects(
+  finishedRoot,
+  nearestMountedAncestor,
+  parent
+) {
+  for (parent = parent.child; null !== parent; )
+    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent),
+      (parent = parent.sibling);
+}
+function commitDeletionEffectsOnFiber(
+  finishedRoot,
+  nearestMountedAncestor,
+  deletedFiber
+) {
+  if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
+    try {
+      injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
+    } catch (err) {}
+  switch (deletedFiber.tag) {
+    case 26:
+    case 27:
+    case 5:
+      offscreenSubtreeWasHidden ||
+        safelyDetachRef(deletedFiber, nearestMountedAncestor);
+    case 6:
+      var prevHostParent = hostParent,
+        prevHostParentIsContainer = hostParentIsContainer;
+      hostParent = null;
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
+      hostParent = prevHostParent;
+      hostParentIsContainer = prevHostParentIsContainer;
+      null !== hostParent &&
+        (hostParentIsContainer
+          ? ((finishedRoot = hostParent),
+            recursivelyUncacheFiberNode(deletedFiber.stateNode),
+            ReactNativePrivateInterface.UIManager.manageChildren(
+              finishedRoot,
+              [],
+              [],
+              [],
+              [],
+              [0]
+            ))
+          : ((finishedRoot = hostParent),
+            (nearestMountedAncestor = deletedFiber.stateNode),
+            recursivelyUncacheFiberNode(nearestMountedAncestor),
+            (deletedFiber = finishedRoot._children),
+            (nearestMountedAncestor = deletedFiber.indexOf(
+              nearestMountedAncestor
+            )),
+            deletedFiber.splice(nearestMountedAncestor, 1),
+            ReactNativePrivateInterface.UIManager.manageChildren(
+              finishedRoot._nativeTag,
+              [],
+              [],
+              [],
+              [],
+              [nearestMountedAncestor]
+            )));
+      break;
+    case 18:
+      null !== hostParent && shim$1();
+      break;
+    case 4:
+      prevHostParent = hostParent;
+      prevHostParentIsContainer = hostParentIsContainer;
+      hostParent = deletedFiber.stateNode.containerInfo;
+      hostParentIsContainer = !0;
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
+      hostParent = prevHostParent;
+      hostParentIsContainer = prevHostParentIsContainer;
+      break;
     case 0:
     case 11:
+    case 14:
     case 15:
-      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
-      flags & 2048 && commitHookPassiveMountEffects(finishedWork, 9);
+      if (
+        !offscreenSubtreeWasHidden &&
+        ((prevHostParent = deletedFiber.updateQueue),
+        null !== prevHostParent &&
+          ((prevHostParent = prevHostParent.lastEffect),
+          null !== prevHostParent))
+      ) {
+        prevHostParentIsContainer = prevHostParent = prevHostParent.next;
+        do {
+          var tag = prevHostParentIsContainer.tag,
+            inst = prevHostParentIsContainer.inst,
+            destroy = inst.destroy;
+          void 0 !== destroy &&
+            (0 !== (tag & 2)
+              ? ((inst.destroy = void 0),
+                safelyCallDestroy(
+                  deletedFiber,
+                  nearestMountedAncestor,
+                  destroy
+                ))
+              : 0 !== (tag & 4) &&
+                (shouldProfile(deletedFiber)
+                  ? (startLayoutEffectTimer(),
+                    (inst.destroy = void 0),
+                    safelyCallDestroy(
+                      deletedFiber,
+                      nearestMountedAncestor,
+                      destroy
+                    ),
+                    recordLayoutEffectDuration(deletedFiber))
+                  : ((inst.destroy = void 0),
+                    safelyCallDestroy(
+                      deletedFiber,
+                      nearestMountedAncestor,
+                      destroy
+                    ))));
+          prevHostParentIsContainer = prevHostParentIsContainer.next;
+        } while (prevHostParentIsContainer !== prevHostParent);
+      }
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
       break;
-    case 3:
-      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
+    case 1:
+      if (
+        !offscreenSubtreeWasHidden &&
+        (safelyDetachRef(deletedFiber, nearestMountedAncestor),
+        (prevHostParent = deletedFiber.stateNode),
+        "function" === typeof prevHostParent.componentWillUnmount)
+      )
+        try {
+          callComponentWillUnmountWithTimer(deletedFiber, prevHostParent);
+        } catch (error) {
+          captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
+        }
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
       break;
-    case 23:
+    case 21:
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
       break;
     case 22:
-      flags = finishedWork.stateNode;
-      null !== finishedWork.memoizedState
-        ? flags._visibility & 4
-          ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork)
-          : finishedWork.mode & 1 ||
-            ((flags._visibility |= 4),
-            recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork))
-        : flags._visibility & 4
-        ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork)
-        : ((flags._visibility |= 4),
-          recursivelyTraverseReconnectPassiveEffects(
+      safelyDetachRef(deletedFiber, nearestMountedAncestor);
+      deletedFiber.mode & 1
+        ? ((offscreenSubtreeWasHidden =
+            (prevHostParent = offscreenSubtreeWasHidden) ||
+            null !== deletedFiber.memoizedState),
+          recursivelyTraverseDeletionEffects(
             finishedRoot,
-            finishedWork
-          ));
-      break;
-    case 24:
-      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
+            nearestMountedAncestor,
+            deletedFiber
+          ),
+          (offscreenSubtreeWasHidden = prevHostParent))
+        : recursivelyTraverseDeletionEffects(
+            finishedRoot,
+            nearestMountedAncestor,
+            deletedFiber
+          );
       break;
     default:
-      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
-  }
-}
-function recursivelyTraverseReconnectPassiveEffects(
-  finishedRoot$jscomp$0,
-  parentFiber
-) {
-  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
-    var finishedRoot = finishedRoot$jscomp$0,
-      finishedWork = parentFiber;
-    switch (finishedWork.tag) {
-      case 0:
-      case 11:
-      case 15:
-        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork);
-        commitHookPassiveMountEffects(finishedWork, 8);
-        break;
-      case 23:
-        break;
-      case 22:
-        var instance = finishedWork.stateNode;
-        null !== finishedWork.memoizedState
-          ? instance._visibility & 4
-            ? recursivelyTraverseReconnectPassiveEffects(
-                finishedRoot,
-                finishedWork
-              )
-            : finishedWork.mode & 1 ||
-              ((instance._visibility |= 4),
-              recursivelyTraverseReconnectPassiveEffects(
-                finishedRoot,
-                finishedWork
-              ))
-          : ((instance._visibility |= 4),
-            recursivelyTraverseReconnectPassiveEffects(
-              finishedRoot,
-              finishedWork
-            ));
-        break;
-      case 24:
-        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork);
-        break;
-      default:
-        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork);
-    }
-    parentFiber = parentFiber.sibling;
+      recursivelyTraverseDeletionEffects(
+        finishedRoot,
+        nearestMountedAncestor,
+        deletedFiber
+      );
   }
 }
-var suspenseyCommitFlag = 8192;
-function recursivelyAccumulateSuspenseyCommit(parentFiber) {
-  if (parentFiber.subtreeFlags & suspenseyCommitFlag)
-    for (parentFiber = parentFiber.child; null !== parentFiber; )
-      accumulateSuspenseyCommitOnFiber(parentFiber),
-        (parentFiber = parentFiber.sibling);
-}
-function accumulateSuspenseyCommitOnFiber(fiber) {
-  switch (fiber.tag) {
-    case 26:
-      recursivelyAccumulateSuspenseyCommit(fiber);
-      if (fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState)
-        throw Error(
-          "The current renderer does not support Resources. This error is likely caused by a bug in React. Please file an issue."
-        );
-      break;
-    case 5:
-      recursivelyAccumulateSuspenseyCommit(fiber);
-      break;
-    case 3:
-    case 4:
-      recursivelyAccumulateSuspenseyCommit(fiber);
-      break;
+function getRetryCache(finishedWork) {
+  switch (finishedWork.tag) {
+    case 13:
+    case 19:
+      var retryCache = finishedWork.stateNode;
+      null === retryCache &&
+        (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
+      return retryCache;
     case 22:
-      if (null === fiber.memoizedState) {
-        var current = fiber.alternate;
-        null !== current && null !== current.memoizedState
-          ? ((current = suspenseyCommitFlag),
-            (suspenseyCommitFlag = 16777216),
-            recursivelyAccumulateSuspenseyCommit(fiber),
-            (suspenseyCommitFlag = current))
-          : recursivelyAccumulateSuspenseyCommit(fiber);
-      }
-      break;
+      return (
+        (finishedWork = finishedWork.stateNode),
+        (retryCache = finishedWork._retryCache),
+        null === retryCache &&
+          (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),
+        retryCache
+      );
     default:
-      recursivelyAccumulateSuspenseyCommit(fiber);
+      throw Error(
+        "Unexpected Suspense handler tag (" +
+          finishedWork.tag +
+          "). This is a bug in React."
+      );
   }
 }
-function detachAlternateSiblings(parentFiber) {
-  var previousFiber = parentFiber.alternate;
-  if (
-    null !== previousFiber &&
-    ((parentFiber = previousFiber.child), null !== parentFiber)
-  ) {
-    previousFiber.child = null;
-    do
-      (previousFiber = parentFiber.sibling),
-        (parentFiber.sibling = null),
-        (parentFiber = previousFiber);
-    while (null !== parentFiber);
-  }
+function attachSuspenseRetryListeners(finishedWork, wakeables) {
+  var retryCache = getRetryCache(finishedWork);
+  wakeables.forEach(function (wakeable) {
+    var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
+    if (!retryCache.has(wakeable)) {
+      retryCache.add(wakeable);
+      if (isDevToolsPresent)
+        if (null !== inProgressLanes && null !== inProgressRoot)
+          restorePendingUpdaters(inProgressRoot, inProgressLanes);
+        else
+          throw Error(
+            "Expected finished root and lanes to be set. This is a bug in React."
+          );
+      wakeable.then(retry, retry);
+    }
+  });
 }
-function commitHookPassiveUnmountEffects(
-  finishedWork,
-  nearestMountedAncestor,
-  hookFlags
-) {
-  shouldProfile(finishedWork)
-    ? ((passiveEffectStartTime = now()),
-      commitHookEffectListUnmount(
-        hookFlags,
-        finishedWork,
-        nearestMountedAncestor
-      ),
-      recordPassiveEffectDuration(finishedWork))
-    : commitHookEffectListUnmount(
-        hookFlags,
-        finishedWork,
-        nearestMountedAncestor
-      );
+function commitMutationEffects(root, finishedWork, committedLanes) {
+  inProgressLanes = committedLanes;
+  inProgressRoot = root;
+  commitMutationEffectsOnFiber(finishedWork, root);
+  inProgressRoot = inProgressLanes = null;
 }
-function recursivelyTraversePassiveUnmountEffects(parentFiber) {
+function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
   var deletions = parentFiber.deletions;
-  if (0 !== (parentFiber.flags & 16)) {
-    if (null !== deletions)
-      for (var i = 0; i < deletions.length; i++) {
-        var childToDelete = deletions[i];
-        nextEffect = childToDelete;
-        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
-          childToDelete,
-          parentFiber
-        );
-      }
-    detachAlternateSiblings(parentFiber);
-  }
-  if (parentFiber.subtreeFlags & 10256)
+  if (null !== deletions)
+    for (var i = 0; i < deletions.length; i++) {
+      var childToDelete = deletions[i];
+      try {
+        var root = root$jscomp$0,
+          returnFiber = parentFiber,
+          parent = returnFiber;
+        a: for (; null !== parent; ) {
+          switch (parent.tag) {
+            case 27:
+            case 5:
+              hostParent = parent.stateNode;
+              hostParentIsContainer = !1;
+              break a;
+            case 3:
+              hostParent = parent.stateNode.containerInfo;
+              hostParentIsContainer = !0;
+              break a;
+            case 4:
+              hostParent = parent.stateNode.containerInfo;
+              hostParentIsContainer = !0;
+              break a;
+          }
+          parent = parent.return;
+        }
+        if (null === hostParent)
+          throw Error(
+            "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
+          );
+        commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);
+        hostParent = null;
+        hostParentIsContainer = !1;
+        var alternate = childToDelete.alternate;
+        null !== alternate && (alternate.return = null);
+        childToDelete.return = null;
+      } catch (error) {
+        captureCommitPhaseError(childToDelete, parentFiber, error);
+      }
+    }
+  if (parentFiber.subtreeFlags & 12854)
     for (parentFiber = parentFiber.child; null !== parentFiber; )
-      commitPassiveUnmountOnFiber(parentFiber),
+      commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),
         (parentFiber = parentFiber.sibling);
 }
-function commitPassiveUnmountOnFiber(finishedWork) {
+function commitMutationEffectsOnFiber(finishedWork, root) {
+  var current = finishedWork.alternate,
+    flags = finishedWork.flags;
   switch (finishedWork.tag) {
     case 0:
     case 11:
+    case 14:
     case 15:
-      recursivelyTraversePassiveUnmountEffects(finishedWork);
-      finishedWork.flags & 2048 &&
-        commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, 9);
-      break;
-    case 22:
-      var instance = finishedWork.stateNode;
-      null !== finishedWork.memoizedState &&
-      instance._visibility & 4 &&
-      (null === finishedWork.return || 13 !== finishedWork.return.tag)
-        ? ((instance._visibility &= -5),
-          recursivelyTraverseDisconnectPassiveEffects(finishedWork))
-        : recursivelyTraversePassiveUnmountEffects(finishedWork);
-      break;
-    default:
-      recursivelyTraversePassiveUnmountEffects(finishedWork);
-  }
-}
-function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
-  var deletions = parentFiber.deletions;
-  if (0 !== (parentFiber.flags & 16)) {
-    if (null !== deletions)
-      for (var i = 0; i < deletions.length; i++) {
-        var childToDelete = deletions[i];
-        nextEffect = childToDelete;
-        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
-          childToDelete,
-          parentFiber
-        );
-      }
-    detachAlternateSiblings(parentFiber);
-  }
-  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
-    deletions = parentFiber;
-    switch (deletions.tag) {
-      case 0:
-      case 11:
-      case 15:
-        commitHookPassiveUnmountEffects(deletions, deletions.return, 8);
-        recursivelyTraverseDisconnectPassiveEffects(deletions);
-        break;
-      case 22:
-        i = deletions.stateNode;
-        i._visibility & 4 &&
-          ((i._visibility &= -5),
-          recursivelyTraverseDisconnectPassiveEffects(deletions));
-        break;
-      default:
-        recursivelyTraverseDisconnectPassiveEffects(deletions);
-    }
-    parentFiber = parentFiber.sibling;
-  }
-}
-function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
-  deletedSubtreeRoot,
-  nearestMountedAncestor
-) {
-  for (; null !== nextEffect; ) {
-    var fiber = nextEffect;
-    switch (fiber.tag) {
-      case 0:
-      case 11:
-      case 15:
-        commitHookPassiveUnmountEffects(fiber, nearestMountedAncestor, 8);
-    }
-    var child = fiber.child;
-    if (null !== child) (child.return = fiber), (nextEffect = child);
-    else
-      a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
-        child = nextEffect;
-        var sibling = child.sibling,
-          returnFiber = child.return;
-        detachFiberAfterEffects(child);
-        if (child === fiber) {
-          nextEffect = null;
-          break a;
-        }
-        if (null !== sibling) {
-          sibling.return = returnFiber;
-          nextEffect = sibling;
-          break a;
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      if (flags & 4) {
+        try {
+          commitHookEffectListUnmount(3, finishedWork, finishedWork.return),
+            commitHookEffectListMount(3, finishedWork);
+        } catch (error) {
+          captureCommitPhaseError(finishedWork, finishedWork.return, error);
         }
-        nextEffect = returnFiber;
+        if (shouldProfile(finishedWork)) {
+          try {
+            startLayoutEffectTimer(),
+              commitHookEffectListUnmount(5, finishedWork, finishedWork.return);
+          } catch (error$99) {
+            captureCommitPhaseError(
+              finishedWork,
+              finishedWork.return,
+              error$99
+            );
+          }
+          recordLayoutEffectDuration(finishedWork);
+        } else
+          try {
+            commitHookEffectListUnmount(5, finishedWork, finishedWork.return);
+          } catch (error$100) {
+            captureCommitPhaseError(
+              finishedWork,
+              finishedWork.return,
+              error$100
+            );
+          }
       }
-  }
-}
-var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
-  ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher,
-  ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner,
-  ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig,
-  executionContext = 0,
-  workInProgressRoot = null,
-  workInProgress = null,
-  workInProgressRootRenderLanes = 0,
-  workInProgressSuspendedReason = 0,
-  workInProgressThrownValue = null,
-  workInProgressRootDidAttachPingListener = !1,
-  entangledRenderLanes = 0,
-  workInProgressRootExitStatus = 0,
-  workInProgressRootFatalError = null,
-  workInProgressRootSkippedLanes = 0,
-  workInProgressRootInterleavedUpdatedLanes = 0,
-  workInProgressRootPingedLanes = 0,
-  workInProgressDeferredLane = 0,
-  workInProgressRootConcurrentErrors = null,
-  workInProgressRootRecoverableErrors = null,
-  globalMostRecentFallbackTime = 0,
-  workInProgressRootRenderTargetTime = Infinity,
-  workInProgressTransitions = null,
-  hasUncaughtError = !1,
-  firstUncaughtError = null,
-  legacyErrorBoundariesThatAlreadyFailed = null,
-  rootDoesHavePassiveEffects = !1,
-  rootWithPendingPassiveEffects = null,
-  pendingPassiveEffectsLanes = 0,
-  pendingPassiveProfilerEffects = [],
-  nestedUpdateCount = 0,
-  rootWithNestedUpdates = null;
-function requestUpdateLane(fiber) {
-  if (0 === (fiber.mode & 1)) return 2;
-  if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)
-    return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
-  fiber = ReactCurrentBatchConfig$1.transition;
-  null !== fiber && fiber._callbacks.add(handleAsyncAction);
-  if (null !== fiber)
-    return (
-      0 === currentEventTransitionLane &&
-        (currentEventTransitionLane = claimNextTransitionLane()),
-      currentEventTransitionLane
-    );
-  fiber = currentUpdatePriority;
-  return 0 !== fiber ? fiber : 32;
-}
-function requestDeferredLane() {
-  0 === workInProgressDeferredLane &&
-    (workInProgressDeferredLane =
-      0 !== (workInProgressRootRenderLanes & 536870912)
-        ? 536870912
-        : claimNextTransitionLane());
-  var suspenseHandler = suspenseHandlerStackCursor.current;
-  null !== suspenseHandler && (suspenseHandler.flags |= 32);
-  return workInProgressDeferredLane;
-}
-function scheduleUpdateOnFiber(root, fiber, lane) {
-  if (
-    (root === workInProgressRoot && 2 === workInProgressSuspendedReason) ||
-    null !== root.cancelPendingCommit
-  )
-    prepareFreshStack(root, 0),
-      markRootSuspended(
-        root,
-        workInProgressRootRenderLanes,
-        workInProgressDeferredLane
-      );
-  markRootUpdated(root, lane);
-  if (0 === (executionContext & 2) || root !== workInProgressRoot)
-    isDevToolsPresent && addFiberToLanesMap(root, fiber, lane),
-      root === workInProgressRoot &&
-        (0 === (executionContext & 2) &&
-          (workInProgressRootInterleavedUpdatedLanes |= lane),
-        4 === workInProgressRootExitStatus &&
-          markRootSuspended(
-            root,
-            workInProgressRootRenderLanes,
-            workInProgressDeferredLane
-          )),
-      ensureRootIsScheduled(root),
-      2 === lane &&
-        0 === executionContext &&
-        0 === (fiber.mode & 1) &&
-        ((workInProgressRootRenderTargetTime = now$1() + 500),
-        flushSyncWorkAcrossRoots_impl(!0));
-}
-function performConcurrentWorkOnRoot(root, didTimeout) {
-  nestedUpdateScheduled = currentUpdateIsNested = !1;
-  if (0 !== (executionContext & 6))
-    throw Error("Should not already be working.");
-  var originalCallbackNode = root.callbackNode;
-  if (flushPassiveEffects() && root.callbackNode !== originalCallbackNode)
-    return null;
-  var lanes = getNextLanes(
-    root,
-    root === workInProgressRoot ? workInProgressRootRenderLanes : 0
-  );
-  if (0 === lanes) return null;
-  var exitStatus = (didTimeout =
-    0 === (lanes & 60) && 0 === (lanes & root.expiredLanes) && !didTimeout)
-    ? renderRootConcurrent(root, lanes)
-    : renderRootSync(root, lanes);
-  if (0 !== exitStatus) {
-    var renderWasConcurrent = didTimeout;
-    do {
-      if (6 === exitStatus) markRootSuspended(root, lanes, 0);
-      else {
-        didTimeout = root.current.alternate;
-        if (
-          renderWasConcurrent &&
-          !isRenderConsistentWithExternalStores(didTimeout)
-        ) {
-          exitStatus = renderRootSync(root, lanes);
-          renderWasConcurrent = !1;
-          continue;
-        }
-        if (2 === exitStatus) {
-          renderWasConcurrent = lanes;
-          var errorRetryLanes = getLanesToRetrySynchronouslyOnError(
-            root,
-            renderWasConcurrent
+      break;
+    case 1:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      flags & 512 &&
+        null !== current &&
+        safelyDetachRef(current, current.return);
+      flags & 64 &&
+        offscreenSubtreeIsHidden &&
+        ((finishedWork = finishedWork.updateQueue),
+        null !== finishedWork &&
+          ((flags = finishedWork.callbacks),
+          null !== flags &&
+            ((current = finishedWork.shared.hiddenCallbacks),
+            (finishedWork.shared.hiddenCallbacks =
+              null === current ? flags : current.concat(flags)))));
+      break;
+    case 26:
+    case 27:
+    case 5:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      flags & 512 &&
+        null !== current &&
+        safelyDetachRef(current, current.return);
+      if (flags & 4 && ((flags = finishedWork.stateNode), null != flags)) {
+        var newProps = finishedWork.memoizedProps;
+        current = null !== current ? current.memoizedProps : newProps;
+        finishedWork.updateQueue = null;
+        try {
+          var viewConfig = flags.viewConfig;
+          instanceProps.set(flags._nativeTag, newProps);
+          var updatePayload = diffProperties(
+            null,
+            current,
+            newProps,
+            viewConfig.validAttributes
           );
-          0 !== errorRetryLanes &&
-            ((lanes = errorRetryLanes),
-            (exitStatus = recoverFromConcurrentError(
-              root,
-              renderWasConcurrent,
-              errorRetryLanes
-            )));
+          null != updatePayload &&
+            ReactNativePrivateInterface.UIManager.updateView(
+              flags._nativeTag,
+              viewConfig.uiViewClassName,
+              updatePayload
+            );
+        } catch (error$103) {
+          captureCommitPhaseError(finishedWork, finishedWork.return, error$103);
         }
-        if (1 === exitStatus)
-          throw (
-            ((originalCallbackNode = workInProgressRootFatalError),
-            prepareFreshStack(root, 0),
-            markRootSuspended(root, lanes, 0),
-            ensureRootIsScheduled(root),
-            originalCallbackNode)
+      }
+      break;
+    case 6:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      if (flags & 4) {
+        if (null === finishedWork.stateNode)
+          throw Error(
+            "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
           );
-        root.finishedWork = didTimeout;
-        root.finishedLanes = lanes;
-        a: {
-          renderWasConcurrent = root;
-          switch (exitStatus) {
-            case 0:
-            case 1:
-              throw Error("Root did not complete. This is a bug in React.");
-            case 4:
-              if ((lanes & 4194176) === lanes) {
-                markRootSuspended(
-                  renderWasConcurrent,
-                  lanes,
-                  workInProgressDeferredLane
+        flags = finishedWork.stateNode;
+        current = finishedWork.memoizedProps;
+        try {
+          ReactNativePrivateInterface.UIManager.updateView(
+            flags,
+            "RCTRawText",
+            { text: current }
+          );
+        } catch (error$104) {
+          captureCommitPhaseError(finishedWork, finishedWork.return, error$104);
+        }
+      }
+      break;
+    case 3:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      break;
+    case 4:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      break;
+    case 13:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      finishedWork.child.flags & 8192 &&
+        ((current = null !== current && null !== current.memoizedState),
+        null === finishedWork.memoizedState ||
+          current ||
+          (globalMostRecentFallbackTime = now$1()));
+      flags & 4 &&
+        ((flags = finishedWork.updateQueue),
+        null !== flags &&
+          ((finishedWork.updateQueue = null),
+          attachSuspenseRetryListeners(finishedWork, flags)));
+      break;
+    case 22:
+      flags & 512 &&
+        null !== current &&
+        safelyDetachRef(current, current.return);
+      viewConfig = null !== finishedWork.memoizedState;
+      updatePayload = null !== current && null !== current.memoizedState;
+      if (finishedWork.mode & 1) {
+        var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
+          prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
+        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || viewConfig;
+        offscreenSubtreeWasHidden =
+          prevOffscreenSubtreeWasHidden || updatePayload;
+        recursivelyTraverseMutationEffects(root, finishedWork);
+        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
+        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
+      } else recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      root = finishedWork.stateNode;
+      root._current = finishedWork;
+      root._visibility &= -3;
+      root._visibility |= root._pendingVisibility & 2;
+      if (
+        flags & 8192 &&
+        ((root._visibility = viewConfig
+          ? root._visibility & -2
+          : root._visibility | 1),
+        viewConfig &&
+          ((root = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden),
+          null === current ||
+            updatePayload ||
+            root ||
+            (0 !== (finishedWork.mode & 1) &&
+              recursivelyTraverseDisappearLayoutEffects(finishedWork))),
+        null === finishedWork.memoizedProps ||
+          "manual" !== finishedWork.memoizedProps.mode)
+      )
+        a: for (current = null, root = finishedWork; ; ) {
+          if (5 === root.tag) {
+            if (null === current) {
+              current = root;
+              try {
+                if (((newProps = root.stateNode), viewConfig)) {
+                  var viewConfig$jscomp$0 = newProps.viewConfig;
+                  var updatePayload$jscomp$0 = diffProperties(
+                    null,
+                    emptyObject,
+                    { style: { display: "none" } },
+                    viewConfig$jscomp$0.validAttributes
+                  );
+                  ReactNativePrivateInterface.UIManager.updateView(
+                    newProps._nativeTag,
+                    viewConfig$jscomp$0.uiViewClassName,
+                    updatePayload$jscomp$0
+                  );
+                } else {
+                  var instance = root.stateNode,
+                    props = root.memoizedProps,
+                    viewConfig$jscomp$1 = instance.viewConfig,
+                    prevProps = assign({}, props, {
+                      style: [props.style, { display: "none" }]
+                    });
+                  var updatePayload$jscomp$1 = diffProperties(
+                    null,
+                    prevProps,
+                    props,
+                    viewConfig$jscomp$1.validAttributes
+                  );
+                  ReactNativePrivateInterface.UIManager.updateView(
+                    instance._nativeTag,
+                    viewConfig$jscomp$1.uiViewClassName,
+                    updatePayload$jscomp$1
+                  );
+                }
+              } catch (error) {
+                captureCommitPhaseError(
+                  finishedWork,
+                  finishedWork.return,
+                  error
                 );
-                break a;
               }
-              break;
-            case 2:
-            case 3:
-            case 5:
-              break;
-            default:
-              throw Error("Unknown root exit status.");
-          }
-          if (
-            (lanes & 62914560) === lanes &&
-            3 === exitStatus &&
-            ((exitStatus = globalMostRecentFallbackTime + 300 - now$1()),
-            10 < exitStatus)
+            }
+          } else if (6 === root.tag) {
+            if (null === current)
+              try {
+                throw Error("Not yet implemented.");
+              } catch (error$93) {
+                captureCommitPhaseError(
+                  finishedWork,
+                  finishedWork.return,
+                  error$93
+                );
+              }
+          } else if (
+            ((22 !== root.tag && 23 !== root.tag) ||
+              null === root.memoizedState ||
+              root === finishedWork) &&
+            null !== root.child
           ) {
-            markRootSuspended(
-              renderWasConcurrent,
-              lanes,
-              workInProgressDeferredLane
-            );
-            if (0 !== getNextLanes(renderWasConcurrent, 0)) break a;
-            renderWasConcurrent.timeoutHandle = scheduleTimeout(
-              commitRootWhenReady.bind(
-                null,
-                renderWasConcurrent,
-                didTimeout,
-                workInProgressRootRecoverableErrors,
-                workInProgressTransitions,
-                lanes,
-                workInProgressDeferredLane
-              ),
-              exitStatus
-            );
+            root.child.return = root;
+            root = root.child;
+            continue;
+          }
+          if (root === finishedWork) break a;
+          for (; null === root.sibling; ) {
+            if (null === root.return || root.return === finishedWork) break a;
+            current === root && (current = null);
+            root = root.return;
+          }
+          current === root && (current = null);
+          root.sibling.return = root.return;
+          root = root.sibling;
+        }
+      flags & 4 &&
+        ((flags = finishedWork.updateQueue),
+        null !== flags &&
+          ((current = flags.retryQueue),
+          null !== current &&
+            ((flags.retryQueue = null),
+            attachSuspenseRetryListeners(finishedWork, current))));
+      break;
+    case 19:
+      recursivelyTraverseMutationEffects(root, finishedWork);
+      commitReconciliationEffects(finishedWork);
+      flags & 4 &&
+        ((flags = finishedWork.updateQueue),
+        null !== flags &&
+          ((finishedWork.updateQueue = null),
+          attachSuspenseRetryListeners(finishedWork, flags)));
+      break;
+    case 21:
+      break;
+    default:
+      recursivelyTraverseMutationEffects(root, finishedWork),
+        commitReconciliationEffects(finishedWork);
+  }
+}
+function commitReconciliationEffects(finishedWork) {
+  var flags = finishedWork.flags;
+  if (flags & 2) {
+    try {
+      a: {
+        for (var parent = finishedWork.return; null !== parent; ) {
+          if (isHostParent(parent)) {
+            var JSCompiler_inline_result = parent;
             break a;
           }
-          commitRootWhenReady(
-            renderWasConcurrent,
-            didTimeout,
-            workInProgressRootRecoverableErrors,
-            workInProgressTransitions,
-            lanes,
-            workInProgressDeferredLane
-          );
+          parent = parent.return;
         }
+        throw Error(
+          "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
+        );
       }
-      break;
-    } while (1);
-  }
-  ensureRootIsScheduled(root);
-  scheduleTaskForRootDuringMicrotask(root, now$1());
-  root =
-    root.callbackNode === originalCallbackNode
-      ? performConcurrentWorkOnRoot.bind(null, root)
-      : null;
-  return root;
-}
-function recoverFromConcurrentError(
-  root,
-  originallyAttemptedLanes,
-  errorRetryLanes
-) {
-  var errorsFromFirstAttempt = workInProgressRootConcurrentErrors,
-    JSCompiler_inline_result;
-  (JSCompiler_inline_result = root.current.memoizedState.isDehydrated) &&
-    (prepareFreshStack(root, errorRetryLanes).flags |= 256);
-  errorRetryLanes = renderRootSync(root, errorRetryLanes);
-  if (2 !== errorRetryLanes) {
-    if (workInProgressRootDidAttachPingListener && !JSCompiler_inline_result)
-      return (
-        (root.errorRecoveryDisabledLanes |= originallyAttemptedLanes),
-        (workInProgressRootInterleavedUpdatedLanes |= originallyAttemptedLanes),
-        4
-      );
-    root = workInProgressRootRecoverableErrors;
-    workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
-    null !== root && queueRecoverableErrors(root);
+      switch (JSCompiler_inline_result.tag) {
+        case 27:
+        case 5:
+          var parent$jscomp$0 = JSCompiler_inline_result.stateNode;
+          JSCompiler_inline_result.flags & 32 &&
+            (JSCompiler_inline_result.flags &= -33);
+          var before = getHostSibling(finishedWork);
+          insertOrAppendPlacementNode(finishedWork, before, parent$jscomp$0);
+          break;
+        case 3:
+        case 4:
+          var parent$94 = JSCompiler_inline_result.stateNode.containerInfo,
+            before$95 = getHostSibling(finishedWork);
+          insertOrAppendPlacementNodeIntoContainer(
+            finishedWork,
+            before$95,
+            parent$94
+          );
+          break;
+        default:
+          throw Error(
+            "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
+          );
+      }
+    } catch (error) {
+      captureCommitPhaseError(finishedWork, finishedWork.return, error);
+    }
+    finishedWork.flags &= -3;
   }
-  return errorRetryLanes;
+  flags & 4096 && (finishedWork.flags &= -4097);
 }
-function queueRecoverableErrors(errors) {
-  null === workInProgressRootRecoverableErrors
-    ? (workInProgressRootRecoverableErrors = errors)
-    : workInProgressRootRecoverableErrors.push.apply(
-        workInProgressRootRecoverableErrors,
-        errors
-      );
+function commitLayoutEffects(finishedWork, root, committedLanes) {
+  inProgressLanes = committedLanes;
+  inProgressRoot = root;
+  commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);
+  inProgressRoot = inProgressLanes = null;
 }
-function commitRootWhenReady(
-  root,
-  finishedWork,
-  recoverableErrors,
-  transitions,
-  lanes,
-  spawnedLane
-) {
-  0 === (lanes & 42) && accumulateSuspenseyCommitOnFiber(finishedWork);
-  commitRoot(root, recoverableErrors, transitions, spawnedLane);
+function recursivelyTraverseLayoutEffects(root, parentFiber) {
+  if (parentFiber.subtreeFlags & 8772)
+    for (parentFiber = parentFiber.child; null !== parentFiber; )
+      commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),
+        (parentFiber = parentFiber.sibling);
 }
-function isRenderConsistentWithExternalStores(finishedWork) {
-  for (var node = finishedWork; ; ) {
-    if (node.flags & 16384) {
-      var updateQueue = node.updateQueue;
-      if (
-        null !== updateQueue &&
-        ((updateQueue = updateQueue.stores), null !== updateQueue)
-      )
-        for (var i = 0; i < updateQueue.length; i++) {
-          var check = updateQueue[i],
-            getSnapshot = check.getSnapshot;
-          check = check.value;
+function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
+  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+    var finishedWork = parentFiber;
+    switch (finishedWork.tag) {
+      case 0:
+      case 11:
+      case 14:
+      case 15:
+        if (shouldProfile(finishedWork))
           try {
-            if (!objectIs(getSnapshot(), check)) return !1;
+            startLayoutEffectTimer(),
+              commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
+          } finally {
+            recordLayoutEffectDuration(finishedWork);
+          }
+        else commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
+        recursivelyTraverseDisappearLayoutEffects(finishedWork);
+        break;
+      case 1:
+        safelyDetachRef(finishedWork, finishedWork.return);
+        var instance = finishedWork.stateNode;
+        if ("function" === typeof instance.componentWillUnmount) {
+          var current = finishedWork,
+            nearestMountedAncestor = finishedWork.return;
+          try {
+            callComponentWillUnmountWithTimer(current, instance);
           } catch (error) {
-            return !1;
+            captureCommitPhaseError(current, nearestMountedAncestor, error);
           }
         }
+        recursivelyTraverseDisappearLayoutEffects(finishedWork);
+        break;
+      case 26:
+      case 27:
+      case 5:
+        safelyDetachRef(finishedWork, finishedWork.return);
+        recursivelyTraverseDisappearLayoutEffects(finishedWork);
+        break;
+      case 22:
+        safelyDetachRef(finishedWork, finishedWork.return);
+        null === finishedWork.memoizedState &&
+          recursivelyTraverseDisappearLayoutEffects(finishedWork);
+        break;
+      default:
+        recursivelyTraverseDisappearLayoutEffects(finishedWork);
     }
-    updateQueue = node.child;
-    if (node.subtreeFlags & 16384 && null !== updateQueue)
-      (updateQueue.return = node), (node = updateQueue);
-    else {
-      if (node === finishedWork) break;
-      for (; null === node.sibling; ) {
-        if (null === node.return || node.return === finishedWork) return !0;
-        node = node.return;
-      }
-      node.sibling.return = node.return;
-      node = node.sibling;
+    parentFiber = parentFiber.sibling;
+  }
+}
+function recursivelyTraverseReappearLayoutEffects(
+  finishedRoot$jscomp$0,
+  parentFiber,
+  includeWorkInProgressEffects
+) {
+  includeWorkInProgressEffects =
+    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
+  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+    var current = parentFiber.alternate,
+      finishedRoot = finishedRoot$jscomp$0,
+      finishedWork = parentFiber,
+      flags = finishedWork.flags;
+    switch (finishedWork.tag) {
+      case 0:
+      case 11:
+      case 15:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+        commitHookLayoutEffects(finishedWork, 4);
+        break;
+      case 1:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+        finishedRoot = finishedWork.stateNode;
+        if ("function" === typeof finishedRoot.componentDidMount)
+          try {
+            finishedRoot.componentDidMount();
+          } catch (error) {
+            captureCommitPhaseError(finishedWork, finishedWork.return, error);
+          }
+        current = finishedWork.updateQueue;
+        if (null !== current) {
+          var hiddenCallbacks = current.shared.hiddenCallbacks;
+          if (null !== hiddenCallbacks)
+            for (
+              current.shared.hiddenCallbacks = null, current = 0;
+              current < hiddenCallbacks.length;
+              current++
+            )
+              callCallback(hiddenCallbacks[current], finishedRoot);
+        }
+        includeWorkInProgressEffects &&
+          flags & 64 &&
+          commitClassCallbacks(finishedWork);
+        safelyAttachRef(finishedWork, finishedWork.return);
+        break;
+      case 26:
+      case 27:
+      case 5:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+        safelyAttachRef(finishedWork, finishedWork.return);
+        break;
+      case 12:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+        includeWorkInProgressEffects &&
+          flags & 4 &&
+          commitProfilerUpdate(finishedWork, current);
+        break;
+      case 13:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
+        break;
+      case 22:
+        null === finishedWork.memoizedState &&
+          recursivelyTraverseReappearLayoutEffects(
+            finishedRoot,
+            finishedWork,
+            includeWorkInProgressEffects
+          );
+        safelyAttachRef(finishedWork, finishedWork.return);
+        break;
+      default:
+        recursivelyTraverseReappearLayoutEffects(
+          finishedRoot,
+          finishedWork,
+          includeWorkInProgressEffects
+        );
     }
+    parentFiber = parentFiber.sibling;
   }
-  return !0;
 }
-function markRootSuspended(root, suspendedLanes, spawnedLane) {
-  suspendedLanes &= ~workInProgressRootPingedLanes;
-  suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
-  root.suspendedLanes |= suspendedLanes;
-  root.pingedLanes &= ~suspendedLanes;
-  for (
-    var expirationTimes = root.expirationTimes, lanes = suspendedLanes;
-    0 < lanes;
-
-  ) {
-    var index$6 = 31 - clz32(lanes),
-      lane = 1 << index$6;
-    expirationTimes[index$6] = -1;
-    lanes &= ~lane;
-  }
-  0 !== spawnedLane &&
-    markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
+function commitHookPassiveMountEffects(finishedWork, hookFlags) {
+  if (shouldProfile(finishedWork)) {
+    passiveEffectStartTime = now();
+    try {
+      commitHookEffectListMount(hookFlags, finishedWork);
+    } catch (error) {
+      captureCommitPhaseError(finishedWork, finishedWork.return, error);
+    }
+    recordPassiveEffectDuration(finishedWork);
+  } else
+    try {
+      commitHookEffectListMount(hookFlags, finishedWork);
+    } catch (error$108) {
+      captureCommitPhaseError(finishedWork, finishedWork.return, error$108);
+    }
 }
-function resetWorkInProgressStack() {
-  if (null !== workInProgress) {
-    if (0 === workInProgressSuspendedReason)
-      var interruptedWork = workInProgress.return;
-    else
-      (interruptedWork = workInProgress),
-        resetContextDependencies(),
-        resetHooksOnUnwind(interruptedWork),
-        (thenableState$1 = null),
-        (thenableIndexCounter$1 = 0),
-        (interruptedWork = workInProgress);
-    for (; null !== interruptedWork; )
-      unwindInterruptedWork(interruptedWork.alternate, interruptedWork),
-        (interruptedWork = interruptedWork.return);
-    workInProgress = null;
+function recursivelyTraversePassiveMountEffects(root, parentFiber) {
+  if (parentFiber.subtreeFlags & 10256)
+    for (parentFiber = parentFiber.child; null !== parentFiber; )
+      commitPassiveMountOnFiber(root, parentFiber),
+        (parentFiber = parentFiber.sibling);
+}
+function commitPassiveMountOnFiber(finishedRoot, finishedWork) {
+  var flags = finishedWork.flags;
+  switch (finishedWork.tag) {
+    case 0:
+    case 11:
+    case 15:
+      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
+      flags & 2048 && commitHookPassiveMountEffects(finishedWork, 9);
+      break;
+    case 3:
+      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
+      break;
+    case 23:
+      break;
+    case 22:
+      flags = finishedWork.stateNode;
+      null !== finishedWork.memoizedState
+        ? flags._visibility & 4
+          ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork)
+          : finishedWork.mode & 1 ||
+            ((flags._visibility |= 4),
+            recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork))
+        : flags._visibility & 4
+        ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork)
+        : ((flags._visibility |= 4),
+          recursivelyTraverseReconnectPassiveEffects(
+            finishedRoot,
+            finishedWork
+          ));
+      break;
+    case 24:
+      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
+      break;
+    default:
+      recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork);
   }
 }
-function prepareFreshStack(root, lanes) {
-  root.finishedWork = null;
-  root.finishedLanes = 0;
-  var timeoutHandle = root.timeoutHandle;
-  -1 !== timeoutHandle &&
-    ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle));
-  timeoutHandle = root.cancelPendingCommit;
-  null !== timeoutHandle &&
-    ((root.cancelPendingCommit = null), timeoutHandle());
-  resetWorkInProgressStack();
-  workInProgressRoot = root;
-  workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
-  workInProgressRootRenderLanes = lanes;
-  workInProgressSuspendedReason = 0;
-  workInProgressThrownValue = null;
-  workInProgressRootDidAttachPingListener = !1;
-  workInProgressRootExitStatus = 0;
-  workInProgressRootFatalError = null;
-  workInProgressDeferredLane =
-    workInProgressRootPingedLanes =
-    workInProgressRootInterleavedUpdatedLanes =
-    workInProgressRootSkippedLanes =
-      0;
-  workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors =
-    null;
-  0 !== (lanes & 8) && (lanes |= lanes & 32);
-  var allEntangledLanes = root.entangledLanes;
-  if (0 !== allEntangledLanes)
-    for (
-      root = root.entanglements, allEntangledLanes &= lanes;
-      0 < allEntangledLanes;
-
-    ) {
-      var index$4 = 31 - clz32(allEntangledLanes),
-        lane = 1 << index$4;
-      lanes |= root[index$4];
-      allEntangledLanes &= ~lane;
+function recursivelyTraverseReconnectPassiveEffects(
+  finishedRoot$jscomp$0,
+  parentFiber
+) {
+  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+    var finishedRoot = finishedRoot$jscomp$0,
+      finishedWork = parentFiber;
+    switch (finishedWork.tag) {
+      case 0:
+      case 11:
+      case 15:
+        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork);
+        commitHookPassiveMountEffects(finishedWork, 8);
+        break;
+      case 23:
+        break;
+      case 22:
+        var instance = finishedWork.stateNode;
+        null !== finishedWork.memoizedState
+          ? instance._visibility & 4
+            ? recursivelyTraverseReconnectPassiveEffects(
+                finishedRoot,
+                finishedWork
+              )
+            : finishedWork.mode & 1 ||
+              ((instance._visibility |= 4),
+              recursivelyTraverseReconnectPassiveEffects(
+                finishedRoot,
+                finishedWork
+              ))
+          : ((instance._visibility |= 4),
+            recursivelyTraverseReconnectPassiveEffects(
+              finishedRoot,
+              finishedWork
+            ));
+        break;
+      case 24:
+        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork);
+        break;
+      default:
+        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork);
     }
-  entangledRenderLanes = lanes;
-  finishQueueingConcurrentUpdates();
-  return timeoutHandle;
+    parentFiber = parentFiber.sibling;
+  }
 }
-function handleThrow(root, thrownValue) {
-  currentlyRenderingFiber$1 = null;
-  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
-  ReactCurrentOwner.current = null;
-  thrownValue === SuspenseException
-    ? ((thrownValue = getSuspendedThenable()),
-      (root = suspenseHandlerStackCursor.current),
-      (workInProgressSuspendedReason =
-        (null !== root &&
-          ((workInProgressRootRenderLanes & 4194176) ===
-          workInProgressRootRenderLanes
-            ? null !== shellBoundary
-            : ((workInProgressRootRenderLanes & 62914560) !==
-                workInProgressRootRenderLanes &&
-                0 === (workInProgressRootRenderLanes & 536870912)) ||
-              root !== shellBoundary)) ||
-        0 !== (workInProgressRootSkippedLanes & 134217727) ||
-        0 !== (workInProgressRootInterleavedUpdatedLanes & 134217727)
-          ? 3
-          : 2))
-    : thrownValue === SuspenseyCommitException
-    ? ((thrownValue = getSuspendedThenable()),
-      (workInProgressSuspendedReason = 4))
-    : (workInProgressSuspendedReason =
-        thrownValue === SelectiveHydrationException
-          ? 8
-          : null !== thrownValue &&
-            "object" === typeof thrownValue &&
-            "function" === typeof thrownValue.then
-          ? 6
-          : 1);
-  workInProgressThrownValue = thrownValue;
-  root = workInProgress;
-  null === root
-    ? ((workInProgressRootExitStatus = 1),
-      (workInProgressRootFatalError = thrownValue))
-    : root.mode & 2 && stopProfilerTimerIfRunningAndRecordDelta(root, !0);
+var suspenseyCommitFlag = 8192;
+function recursivelyAccumulateSuspenseyCommit(parentFiber) {
+  if (parentFiber.subtreeFlags & suspenseyCommitFlag)
+    for (parentFiber = parentFiber.child; null !== parentFiber; )
+      accumulateSuspenseyCommitOnFiber(parentFiber),
+        (parentFiber = parentFiber.sibling);
+}
+function accumulateSuspenseyCommitOnFiber(fiber) {
+  switch (fiber.tag) {
+    case 26:
+      recursivelyAccumulateSuspenseyCommit(fiber);
+      if (fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState)
+        throw Error(
+          "The current renderer does not support Resources. This error is likely caused by a bug in React. Please file an issue."
+        );
+      break;
+    case 5:
+      recursivelyAccumulateSuspenseyCommit(fiber);
+      break;
+    case 3:
+    case 4:
+      recursivelyAccumulateSuspenseyCommit(fiber);
+      break;
+    case 22:
+      if (null === fiber.memoizedState) {
+        var current = fiber.alternate;
+        null !== current && null !== current.memoizedState
+          ? ((current = suspenseyCommitFlag),
+            (suspenseyCommitFlag = 16777216),
+            recursivelyAccumulateSuspenseyCommit(fiber),
+            (suspenseyCommitFlag = current))
+          : recursivelyAccumulateSuspenseyCommit(fiber);
+      }
+      break;
+    default:
+      recursivelyAccumulateSuspenseyCommit(fiber);
+  }
 }
-function pushDispatcher() {
-  var prevDispatcher = ReactCurrentDispatcher.current;
-  ReactCurrentDispatcher.current = ContextOnlyDispatcher;
-  return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
+function detachAlternateSiblings(parentFiber) {
+  var previousFiber = parentFiber.alternate;
+  if (
+    null !== previousFiber &&
+    ((parentFiber = previousFiber.child), null !== parentFiber)
+  ) {
+    previousFiber.child = null;
+    do
+      (previousFiber = parentFiber.sibling),
+        (parentFiber.sibling = null),
+        (parentFiber = previousFiber);
+    while (null !== parentFiber);
+  }
 }
-function renderDidSuspendDelayIfPossible() {
-  workInProgressRootExitStatus = 4;
-  (0 === (workInProgressRootSkippedLanes & 134217727) &&
-    0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||
-    null === workInProgressRoot ||
-    markRootSuspended(
-      workInProgressRoot,
-      workInProgressRootRenderLanes,
-      workInProgressDeferredLane
-    );
+function commitHookPassiveUnmountEffects(
+  finishedWork,
+  nearestMountedAncestor,
+  hookFlags
+) {
+  shouldProfile(finishedWork)
+    ? ((passiveEffectStartTime = now()),
+      commitHookEffectListUnmount(
+        hookFlags,
+        finishedWork,
+        nearestMountedAncestor
+      ),
+      recordPassiveEffectDuration(finishedWork))
+    : commitHookEffectListUnmount(
+        hookFlags,
+        finishedWork,
+        nearestMountedAncestor
+      );
 }
-function renderRootSync(root, lanes) {
-  var prevExecutionContext = executionContext;
-  executionContext |= 2;
-  var prevDispatcher = pushDispatcher();
-  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
-    if (isDevToolsPresent) {
-      var memoizedUpdaters = root.memoizedUpdaters;
-      0 < memoizedUpdaters.size &&
-        (restorePendingUpdaters(root, workInProgressRootRenderLanes),
-        memoizedUpdaters.clear());
-      movePendingFibersToMemoized(root, lanes);
-    }
-    workInProgressTransitions = null;
-    prepareFreshStack(root, lanes);
-  }
-  lanes = !1;
-  a: do
-    try {
-      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
-        memoizedUpdaters = workInProgress;
-        var thrownValue = workInProgressThrownValue;
-        switch (workInProgressSuspendedReason) {
-          case 8:
-            resetWorkInProgressStack();
-            workInProgressRootExitStatus = 6;
-            break a;
-          case 3:
-          case 2:
-            lanes ||
-              null !== suspenseHandlerStackCursor.current ||
-              (lanes = !0);
-          default:
-            (workInProgressSuspendedReason = 0),
-              (workInProgressThrownValue = null),
-              throwAndUnwindWorkLoop(root, memoizedUpdaters, thrownValue);
-        }
+function recursivelyTraversePassiveUnmountEffects(parentFiber) {
+  var deletions = parentFiber.deletions;
+  if (0 !== (parentFiber.flags & 16)) {
+    if (null !== deletions)
+      for (var i = 0; i < deletions.length; i++) {
+        var childToDelete = deletions[i];
+        nextEffect = childToDelete;
+        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
+          childToDelete,
+          parentFiber
+        );
       }
-      workLoopSync();
-      break;
-    } catch (thrownValue$110) {
-      handleThrow(root, thrownValue$110);
-    }
-  while (1);
-  lanes && root.shellSuspendCounter++;
-  resetContextDependencies();
-  executionContext = prevExecutionContext;
-  ReactCurrentDispatcher.current = prevDispatcher;
-  if (null !== workInProgress)
-    throw Error(
-      "Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue."
-    );
-  workInProgressRoot = null;
-  workInProgressRootRenderLanes = 0;
-  finishQueueingConcurrentUpdates();
-  return workInProgressRootExitStatus;
+    detachAlternateSiblings(parentFiber);
+  }
+  if (parentFiber.subtreeFlags & 10256)
+    for (parentFiber = parentFiber.child; null !== parentFiber; )
+      commitPassiveUnmountOnFiber(parentFiber),
+        (parentFiber = parentFiber.sibling);
 }
-function workLoopSync() {
-  for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
+function commitPassiveUnmountOnFiber(finishedWork) {
+  switch (finishedWork.tag) {
+    case 0:
+    case 11:
+    case 15:
+      recursivelyTraversePassiveUnmountEffects(finishedWork);
+      finishedWork.flags & 2048 &&
+        commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, 9);
+      break;
+    case 22:
+      var instance = finishedWork.stateNode;
+      null !== finishedWork.memoizedState &&
+      instance._visibility & 4 &&
+      (null === finishedWork.return || 13 !== finishedWork.return.tag)
+        ? ((instance._visibility &= -5),
+          recursivelyTraverseDisconnectPassiveEffects(finishedWork))
+        : recursivelyTraversePassiveUnmountEffects(finishedWork);
+      break;
+    default:
+      recursivelyTraversePassiveUnmountEffects(finishedWork);
+  }
 }
-function renderRootConcurrent(root, lanes) {
-  var prevExecutionContext = executionContext;
-  executionContext |= 2;
-  var prevDispatcher = pushDispatcher();
-  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
-    if (isDevToolsPresent) {
-      var memoizedUpdaters = root.memoizedUpdaters;
-      0 < memoizedUpdaters.size &&
-        (restorePendingUpdaters(root, workInProgressRootRenderLanes),
-        memoizedUpdaters.clear());
-      movePendingFibersToMemoized(root, lanes);
-    }
-    workInProgressTransitions = null;
-    workInProgressRootRenderTargetTime = now$1() + 500;
-    prepareFreshStack(root, lanes);
+function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
+  var deletions = parentFiber.deletions;
+  if (0 !== (parentFiber.flags & 16)) {
+    if (null !== deletions)
+      for (var i = 0; i < deletions.length; i++) {
+        var childToDelete = deletions[i];
+        nextEffect = childToDelete;
+        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
+          childToDelete,
+          parentFiber
+        );
+      }
+    detachAlternateSiblings(parentFiber);
   }
-  a: do
-    try {
-      if (0 !== workInProgressSuspendedReason && null !== workInProgress)
-        b: switch (
-          ((lanes = workInProgress),
-          (memoizedUpdaters = workInProgressThrownValue),
-          workInProgressSuspendedReason)
-        ) {
-          case 1:
-            workInProgressSuspendedReason = 0;
-            workInProgressThrownValue = null;
-            throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters);
-            break;
-          case 2:
-            if (isThenableResolved(memoizedUpdaters)) {
-              workInProgressSuspendedReason = 0;
-              workInProgressThrownValue = null;
-              replaySuspendedUnitOfWork(lanes);
-              break;
-            }
-            lanes = function () {
-              2 === workInProgressSuspendedReason &&
-                workInProgressRoot === root &&
-                (workInProgressSuspendedReason = 7);
-              ensureRootIsScheduled(root);
-            };
-            memoizedUpdaters.then(lanes, lanes);
-            break a;
-          case 3:
-            workInProgressSuspendedReason = 7;
-            break a;
-          case 4:
-            workInProgressSuspendedReason = 5;
-            break a;
-          case 7:
-            isThenableResolved(memoizedUpdaters)
-              ? ((workInProgressSuspendedReason = 0),
-                (workInProgressThrownValue = null),
-                replaySuspendedUnitOfWork(lanes))
-              : ((workInProgressSuspendedReason = 0),
-                (workInProgressThrownValue = null),
-                throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters));
-            break;
-          case 5:
-            switch (workInProgress.tag) {
-              case 5:
-              case 26:
-              case 27:
-                lanes = workInProgress;
-                workInProgressSuspendedReason = 0;
-                workInProgressThrownValue = null;
-                var sibling = lanes.sibling;
-                if (null !== sibling) workInProgress = sibling;
-                else {
-                  var returnFiber = lanes.return;
-                  null !== returnFiber
-                    ? ((workInProgress = returnFiber),
-                      completeUnitOfWork(returnFiber))
-                    : (workInProgress = null);
-                }
-                break b;
-            }
-            workInProgressSuspendedReason = 0;
-            workInProgressThrownValue = null;
-            throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters);
-            break;
-          case 6:
-            workInProgressSuspendedReason = 0;
-            workInProgressThrownValue = null;
-            throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters);
-            break;
-          case 8:
-            resetWorkInProgressStack();
-            workInProgressRootExitStatus = 6;
-            break a;
-          default:
-            throw Error("Unexpected SuspendedReason. This is a bug in React.");
-        }
-      workLoopConcurrent();
-      break;
-    } catch (thrownValue$112) {
-      handleThrow(root, thrownValue$112);
+  for (parentFiber = parentFiber.child; null !== parentFiber; ) {
+    deletions = parentFiber;
+    switch (deletions.tag) {
+      case 0:
+      case 11:
+      case 15:
+        commitHookPassiveUnmountEffects(deletions, deletions.return, 8);
+        recursivelyTraverseDisconnectPassiveEffects(deletions);
+        break;
+      case 22:
+        i = deletions.stateNode;
+        i._visibility & 4 &&
+          ((i._visibility &= -5),
+          recursivelyTraverseDisconnectPassiveEffects(deletions));
+        break;
+      default:
+        recursivelyTraverseDisconnectPassiveEffects(deletions);
     }
-  while (1);
-  resetContextDependencies();
-  ReactCurrentDispatcher.current = prevDispatcher;
-  executionContext = prevExecutionContext;
-  if (null !== workInProgress) return 0;
-  workInProgressRoot = null;
-  workInProgressRootRenderLanes = 0;
-  finishQueueingConcurrentUpdates();
-  return workInProgressRootExitStatus;
+    parentFiber = parentFiber.sibling;
+  }
 }
-function workLoopConcurrent() {
-  for (; null !== workInProgress && !shouldYield(); )
-    performUnitOfWork(workInProgress);
+function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
+  deletedSubtreeRoot,
+  nearestMountedAncestor
+) {
+  for (; null !== nextEffect; ) {
+    var fiber = nextEffect;
+    switch (fiber.tag) {
+      case 0:
+      case 11:
+      case 15:
+        commitHookPassiveUnmountEffects(fiber, nearestMountedAncestor, 8);
+    }
+    var child = fiber.child;
+    if (null !== child) (child.return = fiber), (nextEffect = child);
+    else
+      a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
+        child = nextEffect;
+        var sibling = child.sibling,
+          returnFiber = child.return;
+        detachFiberAfterEffects(child);
+        if (child === fiber) {
+          nextEffect = null;
+          break a;
+        }
+        if (null !== sibling) {
+          sibling.return = returnFiber;
+          nextEffect = sibling;
+          break a;
+        }
+        nextEffect = returnFiber;
+      }
+  }
 }
-function performUnitOfWork(unitOfWork) {
-  var current = unitOfWork.alternate;
-  0 !== (unitOfWork.mode & 2)
-    ? (startProfilerTimer(unitOfWork),
-      (current = beginWork(current, unitOfWork, entangledRenderLanes)),
-      stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, !0))
-    : (current = beginWork(current, unitOfWork, entangledRenderLanes));
-  unitOfWork.memoizedProps = unitOfWork.pendingProps;
-  null === current
-    ? completeUnitOfWork(unitOfWork)
-    : (workInProgress = current);
-  ReactCurrentOwner.current = null;
+var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
+  ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher,
+  ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner,
+  ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig,
+  executionContext = 0,
+  workInProgressRoot = null,
+  workInProgress = null,
+  workInProgressRootRenderLanes = 0,
+  workInProgressSuspendedReason = 0,
+  workInProgressThrownValue = null,
+  workInProgressRootDidAttachPingListener = !1,
+  entangledRenderLanes = 0,
+  workInProgressRootExitStatus = 0,
+  workInProgressRootFatalError = null,
+  workInProgressRootSkippedLanes = 0,
+  workInProgressRootInterleavedUpdatedLanes = 0,
+  workInProgressRootPingedLanes = 0,
+  workInProgressDeferredLane = 0,
+  workInProgressRootConcurrentErrors = null,
+  workInProgressRootRecoverableErrors = null,
+  workInProgressRootDidIncludeRecursiveRenderUpdate = !1,
+  globalMostRecentFallbackTime = 0,
+  workInProgressRootRenderTargetTime = Infinity,
+  workInProgressTransitions = null,
+  hasUncaughtError = !1,
+  firstUncaughtError = null,
+  legacyErrorBoundariesThatAlreadyFailed = null,
+  rootDoesHavePassiveEffects = !1,
+  rootWithPendingPassiveEffects = null,
+  pendingPassiveEffectsLanes = 0,
+  pendingPassiveProfilerEffects = [],
+  nestedUpdateCount = 0,
+  rootWithNestedUpdates = null;
+function requestUpdateLane(fiber) {
+  if (0 === (fiber.mode & 1)) return 2;
+  if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)
+    return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
+  fiber = ReactCurrentBatchConfig$1.transition;
+  if (null !== fiber) {
+    if (!fiber._callbacks) {
+      fiber._callbacks = new Set();
+    }
+    fiber._callbacks.add(handleAsyncAction);
+  }
+  if (null !== fiber)
+    return (
+      0 === currentEventTransitionLane &&
+        (currentEventTransitionLane = claimNextTransitionLane()),
+      currentEventTransitionLane
+    );
+  fiber = currentUpdatePriority;
+  return 0 !== fiber ? fiber : 32;
 }
-function replaySuspendedUnitOfWork(unitOfWork) {
-  var current = unitOfWork.alternate,
-    isProfilingMode = 0 !== (unitOfWork.mode & 2);
-  isProfilingMode && startProfilerTimer(unitOfWork);
-  switch (unitOfWork.tag) {
-    case 2:
-      unitOfWork.tag = 0;
-    case 15:
-    case 0:
-      var Component = unitOfWork.type,
-        unresolvedProps = unitOfWork.pendingProps;
-      unresolvedProps =
-        unitOfWork.elementType === Component
-          ? unresolvedProps
-          : resolveDefaultProps(Component, unresolvedProps);
-      var context = isContextProvider(Component)
-        ? previousContext
-        : contextStackCursor$1.current;
-      context = getMaskedContext(unitOfWork, context);
-      current = replayFunctionComponent(
-        current,
-        unitOfWork,
-        unresolvedProps,
-        Component,
-        context,
-        workInProgressRootRenderLanes
+function requestDeferredLane() {
+  0 === workInProgressDeferredLane &&
+    (workInProgressDeferredLane =
+      0 !== (workInProgressRootRenderLanes & 536870912)
+        ? 536870912
+        : claimNextTransitionLane());
+  var suspenseHandler = suspenseHandlerStackCursor.current;
+  null !== suspenseHandler && (suspenseHandler.flags |= 32);
+  return workInProgressDeferredLane;
+}
+function scheduleUpdateOnFiber(root, fiber, lane) {
+  if (
+    (root === workInProgressRoot && 2 === workInProgressSuspendedReason) ||
+    null !== root.cancelPendingCommit
+  )
+    prepareFreshStack(root, 0),
+      markRootSuspended(
+        root,
+        workInProgressRootRenderLanes,
+        workInProgressDeferredLane
       );
+  markRootUpdated$1(root, lane);
+  if (0 === (executionContext & 2) || root !== workInProgressRoot)
+    isDevToolsPresent && addFiberToLanesMap(root, fiber, lane),
+      root === workInProgressRoot &&
+        (0 === (executionContext & 2) &&
+          (workInProgressRootInterleavedUpdatedLanes |= lane),
+        4 === workInProgressRootExitStatus &&
+          markRootSuspended(
+            root,
+            workInProgressRootRenderLanes,
+            workInProgressDeferredLane
+          )),
+      ensureRootIsScheduled(root),
+      2 === lane &&
+        0 === executionContext &&
+        0 === (fiber.mode & 1) &&
+        ((workInProgressRootRenderTargetTime = now$1() + 500),
+        flushSyncWorkAcrossRoots_impl(!0));
+}
+function performConcurrentWorkOnRoot(root, didTimeout) {
+  nestedUpdateScheduled = currentUpdateIsNested = !1;
+  if (0 !== (executionContext & 6))
+    throw Error("Should not already be working.");
+  var originalCallbackNode = root.callbackNode;
+  if (flushPassiveEffects() && root.callbackNode !== originalCallbackNode)
+    return null;
+  var lanes = getNextLanes(
+    root,
+    root === workInProgressRoot ? workInProgressRootRenderLanes : 0
+  );
+  if (0 === lanes) return null;
+  var exitStatus = (didTimeout =
+    0 === (lanes & 60) && 0 === (lanes & root.expiredLanes) && !didTimeout)
+    ? renderRootConcurrent(root, lanes)
+    : renderRootSync(root, lanes);
+  if (0 !== exitStatus) {
+    var renderWasConcurrent = didTimeout;
+    do {
+      if (6 === exitStatus) markRootSuspended(root, lanes, 0);
+      else {
+        didTimeout = root.current.alternate;
+        if (
+          renderWasConcurrent &&
+          !isRenderConsistentWithExternalStores(didTimeout)
+        ) {
+          exitStatus = renderRootSync(root, lanes);
+          renderWasConcurrent = !1;
+          continue;
+        }
+        if (2 === exitStatus) {
+          renderWasConcurrent = lanes;
+          var errorRetryLanes = getLanesToRetrySynchronouslyOnError(
+            root,
+            renderWasConcurrent
+          );
+          0 !== errorRetryLanes &&
+            ((lanes = errorRetryLanes),
+            (exitStatus = recoverFromConcurrentError(
+              root,
+              renderWasConcurrent,
+              errorRetryLanes
+            )));
+        }
+        if (1 === exitStatus)
+          throw (
+            ((originalCallbackNode = workInProgressRootFatalError),
+            prepareFreshStack(root, 0),
+            markRootSuspended(root, lanes, 0),
+            ensureRootIsScheduled(root),
+            originalCallbackNode)
+          );
+        root.finishedWork = didTimeout;
+        root.finishedLanes = lanes;
+        a: {
+          renderWasConcurrent = root;
+          switch (exitStatus) {
+            case 0:
+            case 1:
+              throw Error("Root did not complete. This is a bug in React.");
+            case 4:
+              if ((lanes & 4194176) === lanes) {
+                markRootSuspended(
+                  renderWasConcurrent,
+                  lanes,
+                  workInProgressDeferredLane
+                );
+                break a;
+              }
+              break;
+            case 2:
+            case 3:
+            case 5:
+              break;
+            default:
+              throw Error("Unknown root exit status.");
+          }
+          if (
+            (lanes & 62914560) === lanes &&
+            3 === exitStatus &&
+            ((exitStatus = globalMostRecentFallbackTime + 300 - now$1()),
+            10 < exitStatus)
+          ) {
+            markRootSuspended(
+              renderWasConcurrent,
+              lanes,
+              workInProgressDeferredLane
+            );
+            if (0 !== getNextLanes(renderWasConcurrent, 0)) break a;
+            renderWasConcurrent.timeoutHandle = scheduleTimeout(
+              commitRootWhenReady.bind(
+                null,
+                renderWasConcurrent,
+                didTimeout,
+                workInProgressRootRecoverableErrors,
+                workInProgressTransitions,
+                workInProgressRootDidIncludeRecursiveRenderUpdate,
+                lanes,
+                workInProgressDeferredLane
+              ),
+              exitStatus
+            );
+            break a;
+          }
+          commitRootWhenReady(
+            renderWasConcurrent,
+            didTimeout,
+            workInProgressRootRecoverableErrors,
+            workInProgressTransitions,
+            workInProgressRootDidIncludeRecursiveRenderUpdate,
+            lanes,
+            workInProgressDeferredLane
+          );
+        }
+      }
       break;
-    case 11:
-      Component = unitOfWork.type.render;
-      unresolvedProps = unitOfWork.pendingProps;
-      unresolvedProps =
-        unitOfWork.elementType === Component
-          ? unresolvedProps
-          : resolveDefaultProps(Component, unresolvedProps);
-      current = replayFunctionComponent(
-        current,
-        unitOfWork,
-        unresolvedProps,
-        Component,
-        unitOfWork.ref,
-        workInProgressRootRenderLanes
+    } while (1);
+  }
+  ensureRootIsScheduled(root);
+  scheduleTaskForRootDuringMicrotask(root, now$1());
+  root =
+    root.callbackNode === originalCallbackNode
+      ? performConcurrentWorkOnRoot.bind(null, root)
+      : null;
+  return root;
+}
+function recoverFromConcurrentError(
+  root,
+  originallyAttemptedLanes,
+  errorRetryLanes
+) {
+  var errorsFromFirstAttempt = workInProgressRootConcurrentErrors,
+    JSCompiler_inline_result;
+  (JSCompiler_inline_result = root.current.memoizedState.isDehydrated) &&
+    (prepareFreshStack(root, errorRetryLanes).flags |= 256);
+  errorRetryLanes = renderRootSync(root, errorRetryLanes);
+  if (2 !== errorRetryLanes) {
+    if (workInProgressRootDidAttachPingListener && !JSCompiler_inline_result)
+      return (
+        (root.errorRecoveryDisabledLanes |= originallyAttemptedLanes),
+        (workInProgressRootInterleavedUpdatedLanes |= originallyAttemptedLanes),
+        4
       );
-      break;
-    case 5:
-      resetHooksOnUnwind(unitOfWork);
-    default:
-      unwindInterruptedWork(current, unitOfWork),
-        (unitOfWork = workInProgress =
-          resetWorkInProgress(unitOfWork, entangledRenderLanes)),
-        (current = beginWork(current, unitOfWork, entangledRenderLanes));
+    root = workInProgressRootRecoverableErrors;
+    workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
+    null !== root && queueRecoverableErrors(root);
   }
-  isProfilingMode && stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, !0);
-  unitOfWork.memoizedProps = unitOfWork.pendingProps;
-  null === current
-    ? completeUnitOfWork(unitOfWork)
-    : (workInProgress = current);
-  ReactCurrentOwner.current = null;
+  return errorRetryLanes;
 }
-function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue) {
-  resetContextDependencies();
-  resetHooksOnUnwind(unitOfWork);
-  thenableState$1 = null;
-  thenableIndexCounter$1 = 0;
-  var returnFiber = unitOfWork.return;
-  try {
-    if (
-      throwException(
-        root,
-        returnFiber,
-        unitOfWork,
-        thrownValue,
-        workInProgressRootRenderLanes
+function queueRecoverableErrors(errors) {
+  null === workInProgressRootRecoverableErrors
+    ? (workInProgressRootRecoverableErrors = errors)
+    : workInProgressRootRecoverableErrors.push.apply(
+        workInProgressRootRecoverableErrors,
+        errors
+      );
+}
+function commitRootWhenReady(
+  root,
+  finishedWork,
+  recoverableErrors,
+  transitions,
+  didIncludeRenderPhaseUpdate,
+  lanes,
+  spawnedLane
+) {
+  0 === (lanes & 42) && accumulateSuspenseyCommitOnFiber(finishedWork);
+  commitRoot(
+    root,
+    recoverableErrors,
+    transitions,
+    didIncludeRenderPhaseUpdate,
+    spawnedLane
+  );
+}
+function isRenderConsistentWithExternalStores(finishedWork) {
+  for (var node = finishedWork; ; ) {
+    if (node.flags & 16384) {
+      var updateQueue = node.updateQueue;
+      if (
+        null !== updateQueue &&
+        ((updateQueue = updateQueue.stores), null !== updateQueue)
       )
-    ) {
-      workInProgressRootExitStatus = 1;
-      workInProgressRootFatalError = thrownValue;
-      workInProgress = null;
-      return;
-    }
-  } catch (error) {
-    if (null !== returnFiber) throw ((workInProgress = returnFiber), error);
-    workInProgressRootExitStatus = 1;
-    workInProgressRootFatalError = thrownValue;
-    workInProgress = null;
-    return;
-  }
-  if (unitOfWork.flags & 32768)
-    a: {
-      root = unitOfWork;
-      do {
-        unitOfWork = unwindWork(root.alternate, root);
-        if (null !== unitOfWork) {
-          unitOfWork.flags &= 32767;
-          workInProgress = unitOfWork;
-          break a;
-        }
-        if (0 !== (root.mode & 2)) {
-          stopProfilerTimerIfRunningAndRecordDelta(root, !1);
-          unitOfWork = root.actualDuration;
-          for (thrownValue = root.child; null !== thrownValue; )
-            (unitOfWork += thrownValue.actualDuration),
-              (thrownValue = thrownValue.sibling);
-          root.actualDuration = unitOfWork;
+        for (var i = 0; i < updateQueue.length; i++) {
+          var check = updateQueue[i],
+            getSnapshot = check.getSnapshot;
+          check = check.value;
+          try {
+            if (!objectIs(getSnapshot(), check)) return !1;
+          } catch (error) {
+            return !1;
+          }
         }
-        root = root.return;
-        null !== root &&
-          ((root.flags |= 32768),
-          (root.subtreeFlags = 0),
-          (root.deletions = null));
-        workInProgress = root;
-      } while (null !== root);
-      workInProgressRootExitStatus = 6;
-      workInProgress = null;
-    }
-  else completeUnitOfWork(unitOfWork);
-}
-function completeUnitOfWork(unitOfWork) {
-  var completedWork = unitOfWork;
-  do {
-    var current = completedWork.alternate;
-    unitOfWork = completedWork.return;
-    0 === (completedWork.mode & 2)
-      ? (current = completeWork(current, completedWork, entangledRenderLanes))
-      : (startProfilerTimer(completedWork),
-        (current = completeWork(current, completedWork, entangledRenderLanes)),
-        stopProfilerTimerIfRunningAndRecordDelta(completedWork, !1));
-    if (null !== current) {
-      workInProgress = current;
-      return;
     }
-    completedWork = completedWork.sibling;
-    if (null !== completedWork) {
-      workInProgress = completedWork;
-      return;
+    updateQueue = node.child;
+    if (node.subtreeFlags & 16384 && null !== updateQueue)
+      (updateQueue.return = node), (node = updateQueue);
+    else {
+      if (node === finishedWork) break;
+      for (; null === node.sibling; ) {
+        if (null === node.return || node.return === finishedWork) return !0;
+        node = node.return;
+      }
+      node.sibling.return = node.return;
+      node = node.sibling;
     }
-    workInProgress = completedWork = unitOfWork;
-  } while (null !== completedWork);
-  0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
+  }
+  return !0;
 }
-function commitRoot(root, recoverableErrors, transitions, spawnedLane) {
-  var previousUpdateLanePriority = currentUpdatePriority,
-    prevTransition = ReactCurrentBatchConfig.transition;
-  try {
-    (ReactCurrentBatchConfig.transition = null),
-      (currentUpdatePriority = 2),
-      commitRootImpl(
-        root,
-        recoverableErrors,
-        transitions,
-        previousUpdateLanePriority,
-        spawnedLane
-      );
-  } finally {
-    (ReactCurrentBatchConfig.transition = prevTransition),
-      (currentUpdatePriority = previousUpdateLanePriority);
+function markRootSuspended(root, suspendedLanes, spawnedLane) {
+  suspendedLanes &= ~workInProgressRootPingedLanes;
+  suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
+  root.suspendedLanes |= suspendedLanes;
+  root.pingedLanes &= ~suspendedLanes;
+  for (
+    var expirationTimes = root.expirationTimes, lanes = suspendedLanes;
+    0 < lanes;
+
+  ) {
+    var index$6 = 31 - clz32(lanes),
+      lane = 1 << index$6;
+    expirationTimes[index$6] = -1;
+    lanes &= ~lane;
+  }
+  0 !== spawnedLane &&
+    markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
+}
+function resetWorkInProgressStack() {
+  if (null !== workInProgress) {
+    if (0 === workInProgressSuspendedReason)
+      var interruptedWork = workInProgress.return;
+    else
+      (interruptedWork = workInProgress),
+        resetContextDependencies(),
+        resetHooksOnUnwind(interruptedWork),
+        (thenableState$1 = null),
+        (thenableIndexCounter$1 = 0),
+        (interruptedWork = workInProgress);
+    for (; null !== interruptedWork; )
+      unwindInterruptedWork(interruptedWork.alternate, interruptedWork),
+        (interruptedWork = interruptedWork.return);
+    workInProgress = null;
   }
-  return null;
 }
-function commitRootImpl(
-  root,
-  recoverableErrors,
-  transitions,
-  renderPriorityLevel,
-  spawnedLane
-) {
-  do flushPassiveEffects();
-  while (null !== rootWithPendingPassiveEffects);
-  if (0 !== (executionContext & 6))
-    throw Error("Should not already be working.");
-  var finishedWork = root.finishedWork;
-  transitions = root.finishedLanes;
-  if (null === finishedWork) return null;
+function prepareFreshStack(root, lanes) {
   root.finishedWork = null;
   root.finishedLanes = 0;
-  if (finishedWork === root.current)
-    throw Error(
-      "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
-    );
-  root.callbackNode = null;
-  root.callbackPriority = 0;
-  root.cancelPendingCommit = null;
-  var remainingLanes = finishedWork.lanes | finishedWork.childLanes;
-  remainingLanes |= concurrentlyUpdatedLanes;
-  markRootFinished(root, remainingLanes, spawnedLane);
-  root === workInProgressRoot &&
-    ((workInProgress = workInProgressRoot = null),
-    (workInProgressRootRenderLanes = 0));
-  (0 === (finishedWork.subtreeFlags & 10256) &&
-    0 === (finishedWork.flags & 10256)) ||
-    rootDoesHavePassiveEffects ||
-    ((rootDoesHavePassiveEffects = !0),
-    scheduleCallback(NormalPriority, function () {
-      flushPassiveEffects();
-      return null;
-    }));
-  spawnedLane = 0 !== (finishedWork.flags & 15990);
-  if (0 !== (finishedWork.subtreeFlags & 15990) || spawnedLane) {
-    spawnedLane = ReactCurrentBatchConfig.transition;
-    ReactCurrentBatchConfig.transition = null;
-    remainingLanes = currentUpdatePriority;
-    currentUpdatePriority = 2;
-    var prevExecutionContext = executionContext;
-    executionContext |= 4;
-    ReactCurrentOwner.current = null;
-    commitBeforeMutationEffects(root, finishedWork);
-    commitTime = now();
-    commitMutationEffects(root, finishedWork, transitions);
-    root.current = finishedWork;
-    commitLayoutEffects(finishedWork, root, transitions);
-    requestPaint();
-    executionContext = prevExecutionContext;
-    currentUpdatePriority = remainingLanes;
-    ReactCurrentBatchConfig.transition = spawnedLane;
-  } else (root.current = finishedWork), (commitTime = now());
-  rootDoesHavePassiveEffects &&
-    ((rootDoesHavePassiveEffects = !1),
-    (rootWithPendingPassiveEffects = root),
-    (pendingPassiveEffectsLanes = transitions));
-  remainingLanes = root.pendingLanes;
-  0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
-  onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
-  isDevToolsPresent && root.memoizedUpdaters.clear();
-  ensureRootIsScheduled(root);
-  if (null !== recoverableErrors)
+  var timeoutHandle = root.timeoutHandle;
+  -1 !== timeoutHandle &&
+    ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle));
+  timeoutHandle = root.cancelPendingCommit;
+  null !== timeoutHandle &&
+    ((root.cancelPendingCommit = null), timeoutHandle());
+  resetWorkInProgressStack();
+  workInProgressRoot = root;
+  workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
+  workInProgressRootRenderLanes = lanes;
+  workInProgressSuspendedReason = 0;
+  workInProgressThrownValue = null;
+  workInProgressRootDidAttachPingListener = !1;
+  workInProgressRootExitStatus = 0;
+  workInProgressRootFatalError = null;
+  workInProgressDeferredLane =
+    workInProgressRootPingedLanes =
+    workInProgressRootInterleavedUpdatedLanes =
+    workInProgressRootSkippedLanes =
+      0;
+  workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors =
+    null;
+  workInProgressRootDidIncludeRecursiveRenderUpdate = !1;
+  0 !== (lanes & 8) && (lanes |= lanes & 32);
+  var allEntangledLanes = root.entangledLanes;
+  if (0 !== allEntangledLanes)
     for (
-      renderPriorityLevel = root.onRecoverableError, finishedWork = 0;
-      finishedWork < recoverableErrors.length;
-      finishedWork++
-    )
-      (spawnedLane = recoverableErrors[finishedWork]),
-        (remainingLanes = {
-          digest: spawnedLane.digest,
-          componentStack: spawnedLane.stack
-        }),
-        renderPriorityLevel(spawnedLane.value, remainingLanes);
-  if (hasUncaughtError)
-    throw (
-      ((hasUncaughtError = !1),
-      (root = firstUncaughtError),
-      (firstUncaughtError = null),
-      root)
+      root = root.entanglements, allEntangledLanes &= lanes;
+      0 < allEntangledLanes;
+
+    ) {
+      var index$4 = 31 - clz32(allEntangledLanes),
+        lane = 1 << index$4;
+      lanes |= root[index$4];
+      allEntangledLanes &= ~lane;
+    }
+  entangledRenderLanes = lanes;
+  finishQueueingConcurrentUpdates();
+  return timeoutHandle;
+}
+function handleThrow(root, thrownValue) {
+  currentlyRenderingFiber$1 = null;
+  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
+  ReactCurrentOwner.current = null;
+  thrownValue === SuspenseException
+    ? ((thrownValue = getSuspendedThenable()),
+      (root = suspenseHandlerStackCursor.current),
+      (workInProgressSuspendedReason =
+        (null !== root &&
+          ((workInProgressRootRenderLanes & 4194176) ===
+          workInProgressRootRenderLanes
+            ? null !== shellBoundary
+            : ((workInProgressRootRenderLanes & 62914560) !==
+                workInProgressRootRenderLanes &&
+                0 === (workInProgressRootRenderLanes & 536870912)) ||
+              root !== shellBoundary)) ||
+        0 !== (workInProgressRootSkippedLanes & 134217727) ||
+        0 !== (workInProgressRootInterleavedUpdatedLanes & 134217727)
+          ? 3
+          : 2))
+    : thrownValue === SuspenseyCommitException
+    ? ((thrownValue = getSuspendedThenable()),
+      (workInProgressSuspendedReason = 4))
+    : (workInProgressSuspendedReason =
+        thrownValue === SelectiveHydrationException
+          ? 8
+          : null !== thrownValue &&
+            "object" === typeof thrownValue &&
+            "function" === typeof thrownValue.then
+          ? 6
+          : 1);
+  workInProgressThrownValue = thrownValue;
+  root = workInProgress;
+  null === root
+    ? ((workInProgressRootExitStatus = 1),
+      (workInProgressRootFatalError = thrownValue))
+    : root.mode & 2 && stopProfilerTimerIfRunningAndRecordDelta(root, !0);
+}
+function pushDispatcher() {
+  var prevDispatcher = ReactCurrentDispatcher.current;
+  ReactCurrentDispatcher.current = ContextOnlyDispatcher;
+  return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
+}
+function renderDidSuspendDelayIfPossible() {
+  workInProgressRootExitStatus = 4;
+  (0 === (workInProgressRootSkippedLanes & 134217727) &&
+    0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||
+    null === workInProgressRoot ||
+    markRootSuspended(
+      workInProgressRoot,
+      workInProgressRootRenderLanes,
+      workInProgressDeferredLane
     );
-  0 !== (pendingPassiveEffectsLanes & 3) &&
-    0 !== root.tag &&
-    flushPassiveEffects();
-  remainingLanes = root.pendingLanes;
-  0 !== (transitions & 4194218) && 0 !== (remainingLanes & 42)
-    ? ((nestedUpdateScheduled = !0),
-      root === rootWithNestedUpdates
-        ? nestedUpdateCount++
-        : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root)))
-    : (nestedUpdateCount = 0);
-  flushSyncWorkAcrossRoots_impl(!1);
-  return null;
 }
-function flushPassiveEffects() {
-  if (null !== rootWithPendingPassiveEffects) {
-    var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes),
-      prevTransition = ReactCurrentBatchConfig.transition,
-      previousPriority = currentUpdatePriority;
+function renderRootSync(root, lanes) {
+  var prevExecutionContext = executionContext;
+  executionContext |= 2;
+  var prevDispatcher = pushDispatcher();
+  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
+    if (isDevToolsPresent) {
+      var memoizedUpdaters = root.memoizedUpdaters;
+      0 < memoizedUpdaters.size &&
+        (restorePendingUpdaters(root, workInProgressRootRenderLanes),
+        memoizedUpdaters.clear());
+      movePendingFibersToMemoized(root, lanes);
+    }
+    workInProgressTransitions = null;
+    prepareFreshStack(root, lanes);
+  }
+  lanes = !1;
+  a: do
     try {
-      ReactCurrentBatchConfig.transition = null;
-      currentUpdatePriority = 32 > renderPriority ? 32 : renderPriority;
-      if (null === rootWithPendingPassiveEffects)
-        var JSCompiler_inline_result = !1;
-      else {
-        renderPriority = rootWithPendingPassiveEffects;
-        rootWithPendingPassiveEffects = null;
-        pendingPassiveEffectsLanes = 0;
-        if (0 !== (executionContext & 6))
-          throw Error("Cannot flush passive effects while already rendering.");
-        var prevExecutionContext = executionContext;
-        executionContext |= 4;
-        commitPassiveUnmountOnFiber(renderPriority.current);
-        commitPassiveMountOnFiber(renderPriority, renderPriority.current);
-        var profilerEffects = pendingPassiveProfilerEffects;
-        pendingPassiveProfilerEffects = [];
-        for (var i = 0; i < profilerEffects.length; i++) {
-          var finishedWork = profilerEffects[i];
-          if (executionContext & 4 && 0 !== (finishedWork.flags & 4))
-            switch (finishedWork.tag) {
-              case 12:
-                var passiveEffectDuration =
-                    finishedWork.stateNode.passiveEffectDuration,
-                  _finishedWork$memoize = finishedWork.memoizedProps,
-                  id = _finishedWork$memoize.id,
-                  onPostCommit = _finishedWork$memoize.onPostCommit,
-                  commitTime$87 = commitTime,
-                  phase = null === finishedWork.alternate ? "mount" : "update";
-                currentUpdateIsNested && (phase = "nested-update");
-                "function" === typeof onPostCommit &&
-                  onPostCommit(id, phase, passiveEffectDuration, commitTime$87);
-                var parentFiber = finishedWork.return;
-                b: for (; null !== parentFiber; ) {
-                  switch (parentFiber.tag) {
-                    case 3:
-                      parentFiber.stateNode.passiveEffectDuration +=
-                        passiveEffectDuration;
-                      break b;
-                    case 12:
-                      parentFiber.stateNode.passiveEffectDuration +=
-                        passiveEffectDuration;
-                      break b;
-                  }
-                  parentFiber = parentFiber.return;
-                }
-            }
+      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
+        memoizedUpdaters = workInProgress;
+        var thrownValue = workInProgressThrownValue;
+        switch (workInProgressSuspendedReason) {
+          case 8:
+            resetWorkInProgressStack();
+            workInProgressRootExitStatus = 6;
+            break a;
+          case 3:
+          case 2:
+            lanes ||
+              null !== suspenseHandlerStackCursor.current ||
+              (lanes = !0);
+          default:
+            (workInProgressSuspendedReason = 0),
+              (workInProgressThrownValue = null),
+              throwAndUnwindWorkLoop(root, memoizedUpdaters, thrownValue);
         }
-        executionContext = prevExecutionContext;
-        flushSyncWorkAcrossRoots_impl(!1);
-        if (
-          injectedHook &&
-          "function" === typeof injectedHook.onPostCommitFiberRoot
-        )
-          try {
-            injectedHook.onPostCommitFiberRoot(rendererID, renderPriority);
-          } catch (err) {}
-        var stateNode = renderPriority.current.stateNode;
-        stateNode.effectDuration = 0;
-        stateNode.passiveEffectDuration = 0;
-        JSCompiler_inline_result = !0;
       }
-      return JSCompiler_inline_result;
-    } finally {
-      (currentUpdatePriority = previousPriority),
-        (ReactCurrentBatchConfig.transition = prevTransition);
+      workLoopSync();
+      break;
+    } catch (thrownValue$109) {
+      handleThrow(root, thrownValue$109);
     }
-  }
-  return !1;
-}
-function enqueuePendingPassiveProfilerEffect(fiber) {
-  pendingPassiveProfilerEffects.push(fiber);
-  rootDoesHavePassiveEffects ||
-    ((rootDoesHavePassiveEffects = !0),
-    scheduleCallback(NormalPriority, function () {
-      flushPassiveEffects();
-      return null;
-    }));
+  while (1);
+  lanes && root.shellSuspendCounter++;
+  resetContextDependencies();
+  executionContext = prevExecutionContext;
+  ReactCurrentDispatcher.current = prevDispatcher;
+  if (null !== workInProgress)
+    throw Error(
+      "Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue."
+    );
+  workInProgressRoot = null;
+  workInProgressRootRenderLanes = 0;
+  finishQueueingConcurrentUpdates();
+  return workInProgressRootExitStatus;
 }
-function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
-  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
-  sourceFiber = createRootErrorUpdate(rootFiber, sourceFiber, 2);
-  rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
-  null !== rootFiber &&
-    (markRootUpdated(rootFiber, 2), ensureRootIsScheduled(rootFiber));
+function workLoopSync() {
+  for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
 }
-function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
-  if (3 === sourceFiber.tag)
-    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
-  else
-    for (; null !== nearestMountedAncestor; ) {
-      if (3 === nearestMountedAncestor.tag) {
-        captureCommitPhaseErrorOnRoot(
-          nearestMountedAncestor,
-          sourceFiber,
-          error
-        );
-        break;
-      } else if (1 === nearestMountedAncestor.tag) {
-        var instance = nearestMountedAncestor.stateNode;
-        if (
-          "function" ===
-            typeof nearestMountedAncestor.type.getDerivedStateFromError ||
-          ("function" === typeof instance.componentDidCatch &&
-            (null === legacyErrorBoundariesThatAlreadyFailed ||
-              !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
+function renderRootConcurrent(root, lanes) {
+  var prevExecutionContext = executionContext;
+  executionContext |= 2;
+  var prevDispatcher = pushDispatcher();
+  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
+    if (isDevToolsPresent) {
+      var memoizedUpdaters = root.memoizedUpdaters;
+      0 < memoizedUpdaters.size &&
+        (restorePendingUpdaters(root, workInProgressRootRenderLanes),
+        memoizedUpdaters.clear());
+      movePendingFibersToMemoized(root, lanes);
+    }
+    workInProgressTransitions = null;
+    workInProgressRootRenderTargetTime = now$1() + 500;
+    prepareFreshStack(root, lanes);
+  }
+  a: do
+    try {
+      if (0 !== workInProgressSuspendedReason && null !== workInProgress)
+        b: switch (
+          ((lanes = workInProgress),
+          (memoizedUpdaters = workInProgressThrownValue),
+          workInProgressSuspendedReason)
         ) {
-          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
-          sourceFiber = createClassErrorUpdate(
-            nearestMountedAncestor,
-            sourceFiber,
-            2
-          );
-          nearestMountedAncestor = enqueueUpdate(
-            nearestMountedAncestor,
-            sourceFiber,
-            2
-          );
-          null !== nearestMountedAncestor &&
-            (markRootUpdated(nearestMountedAncestor, 2),
-            ensureRootIsScheduled(nearestMountedAncestor));
-          break;
+          case 1:
+            workInProgressSuspendedReason = 0;
+            workInProgressThrownValue = null;
+            throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters);
+            break;
+          case 2:
+            if (isThenableResolved(memoizedUpdaters)) {
+              workInProgressSuspendedReason = 0;
+              workInProgressThrownValue = null;
+              replaySuspendedUnitOfWork(lanes);
+              break;
+            }
+            lanes = function () {
+              2 === workInProgressSuspendedReason &&
+                workInProgressRoot === root &&
+                (workInProgressSuspendedReason = 7);
+              ensureRootIsScheduled(root);
+            };
+            memoizedUpdaters.then(lanes, lanes);
+            break a;
+          case 3:
+            workInProgressSuspendedReason = 7;
+            break a;
+          case 4:
+            workInProgressSuspendedReason = 5;
+            break a;
+          case 7:
+            isThenableResolved(memoizedUpdaters)
+              ? ((workInProgressSuspendedReason = 0),
+                (workInProgressThrownValue = null),
+                replaySuspendedUnitOfWork(lanes))
+              : ((workInProgressSuspendedReason = 0),
+                (workInProgressThrownValue = null),
+                throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters));
+            break;
+          case 5:
+            switch (workInProgress.tag) {
+              case 5:
+              case 26:
+              case 27:
+                lanes = workInProgress;
+                workInProgressSuspendedReason = 0;
+                workInProgressThrownValue = null;
+                var sibling = lanes.sibling;
+                if (null !== sibling) workInProgress = sibling;
+                else {
+                  var returnFiber = lanes.return;
+                  null !== returnFiber
+                    ? ((workInProgress = returnFiber),
+                      completeUnitOfWork(returnFiber))
+                    : (workInProgress = null);
+                }
+                break b;
+            }
+            workInProgressSuspendedReason = 0;
+            workInProgressThrownValue = null;
+            throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters);
+            break;
+          case 6:
+            workInProgressSuspendedReason = 0;
+            workInProgressThrownValue = null;
+            throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters);
+            break;
+          case 8:
+            resetWorkInProgressStack();
+            workInProgressRootExitStatus = 6;
+            break a;
+          default:
+            throw Error("Unexpected SuspendedReason. This is a bug in React.");
         }
-      }
-      nearestMountedAncestor = nearestMountedAncestor.return;
+      workLoopConcurrent();
+      break;
+    } catch (thrownValue$111) {
+      handleThrow(root, thrownValue$111);
     }
+  while (1);
+  resetContextDependencies();
+  ReactCurrentDispatcher.current = prevDispatcher;
+  executionContext = prevExecutionContext;
+  if (null !== workInProgress) return 0;
+  workInProgressRoot = null;
+  workInProgressRootRenderLanes = 0;
+  finishQueueingConcurrentUpdates();
+  return workInProgressRootExitStatus;
 }
-function attachPingListener(root, wakeable, lanes) {
-  var pingCache = root.pingCache;
-  if (null === pingCache) {
-    pingCache = root.pingCache = new PossiblyWeakMap();
-    var threadIDs = new Set();
-    pingCache.set(wakeable, threadIDs);
-  } else
-    (threadIDs = pingCache.get(wakeable)),
-      void 0 === threadIDs &&
-        ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs));
-  threadIDs.has(lanes) ||
-    ((workInProgressRootDidAttachPingListener = !0),
-    threadIDs.add(lanes),
-    (pingCache = pingSuspendedRoot.bind(null, root, wakeable, lanes)),
-    isDevToolsPresent && restorePendingUpdaters(root, lanes),
-    wakeable.then(pingCache, pingCache));
-}
-function pingSuspendedRoot(root, wakeable, pingedLanes) {
-  var pingCache = root.pingCache;
-  null !== pingCache && pingCache.delete(wakeable);
-  root.pingedLanes |= root.suspendedLanes & pingedLanes;
-  workInProgressRoot === root &&
-    (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&
-    (4 === workInProgressRootExitStatus ||
-    (3 === workInProgressRootExitStatus &&
-      (workInProgressRootRenderLanes & 62914560) ===
-        workInProgressRootRenderLanes &&
-      300 > now$1() - globalMostRecentFallbackTime)
-      ? 0 === (executionContext & 2) && prepareFreshStack(root, 0)
-      : (workInProgressRootPingedLanes |= pingedLanes));
-  ensureRootIsScheduled(root);
-}
-function retryTimedOutBoundary(boundaryFiber, retryLane) {
-  0 === retryLane &&
-    (retryLane = 0 === (boundaryFiber.mode & 1) ? 2 : claimNextRetryLane());
-  boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
-  null !== boundaryFiber &&
-    (markRootUpdated(boundaryFiber, retryLane),
-    ensureRootIsScheduled(boundaryFiber));
-}
-function retryDehydratedSuspenseBoundary(boundaryFiber) {
-  var suspenseState = boundaryFiber.memoizedState,
-    retryLane = 0;
-  null !== suspenseState && (retryLane = suspenseState.retryLane);
-  retryTimedOutBoundary(boundaryFiber, retryLane);
+function workLoopConcurrent() {
+  for (; null !== workInProgress && !shouldYield(); )
+    performUnitOfWork(workInProgress);
 }
-function resolveRetryWakeable(boundaryFiber, wakeable) {
-  var retryLane = 0;
-  switch (boundaryFiber.tag) {
-    case 13:
-      var retryCache = boundaryFiber.stateNode;
-      var suspenseState = boundaryFiber.memoizedState;
-      null !== suspenseState && (retryLane = suspenseState.retryLane);
-      break;
-    case 19:
-      retryCache = boundaryFiber.stateNode;
+function performUnitOfWork(unitOfWork) {
+  var current = unitOfWork.alternate;
+  0 !== (unitOfWork.mode & 2)
+    ? (startProfilerTimer(unitOfWork),
+      (current = beginWork(current, unitOfWork, entangledRenderLanes)),
+      stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, !0))
+    : (current = beginWork(current, unitOfWork, entangledRenderLanes));
+  unitOfWork.memoizedProps = unitOfWork.pendingProps;
+  null === current
+    ? completeUnitOfWork(unitOfWork)
+    : (workInProgress = current);
+  ReactCurrentOwner.current = null;
+}
+function replaySuspendedUnitOfWork(unitOfWork) {
+  var current = unitOfWork.alternate,
+    isProfilingMode = 0 !== (unitOfWork.mode & 2);
+  isProfilingMode && startProfilerTimer(unitOfWork);
+  switch (unitOfWork.tag) {
+    case 2:
+      unitOfWork.tag = 0;
+    case 15:
+    case 0:
+      var Component = unitOfWork.type,
+        unresolvedProps = unitOfWork.pendingProps;
+      unresolvedProps =
+        unitOfWork.elementType === Component
+          ? unresolvedProps
+          : resolveDefaultProps(Component, unresolvedProps);
+      current = replayFunctionComponent(
+        current,
+        unitOfWork,
+        unresolvedProps,
+        Component,
+        void 0,
+        workInProgressRootRenderLanes
+      );
       break;
-    case 22:
-      retryCache = boundaryFiber.stateNode._retryCache;
+    case 11:
+      Component = unitOfWork.type.render;
+      unresolvedProps = unitOfWork.pendingProps;
+      unresolvedProps =
+        unitOfWork.elementType === Component
+          ? unresolvedProps
+          : resolveDefaultProps(Component, unresolvedProps);
+      current = replayFunctionComponent(
+        current,
+        unitOfWork,
+        unresolvedProps,
+        Component,
+        unitOfWork.ref,
+        workInProgressRootRenderLanes
+      );
       break;
+    case 5:
+      resetHooksOnUnwind(unitOfWork);
     default:
-      throw Error(
-        "Pinged unknown suspense boundary type. This is probably a bug in React."
-      );
+      unwindInterruptedWork(current, unitOfWork),
+        (unitOfWork = workInProgress =
+          resetWorkInProgress(unitOfWork, entangledRenderLanes)),
+        (current = beginWork(current, unitOfWork, entangledRenderLanes));
   }
-  null !== retryCache && retryCache.delete(wakeable);
-  retryTimedOutBoundary(boundaryFiber, retryLane);
+  isProfilingMode && stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, !0);
+  unitOfWork.memoizedProps = unitOfWork.pendingProps;
+  null === current
+    ? completeUnitOfWork(unitOfWork)
+    : (workInProgress = current);
+  ReactCurrentOwner.current = null;
 }
-var beginWork;
-beginWork = function (current, workInProgress, renderLanes) {
-  if (null !== current)
+function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue) {
+  resetContextDependencies();
+  resetHooksOnUnwind(unitOfWork);
+  thenableState$1 = null;
+  thenableIndexCounter$1 = 0;
+  var returnFiber = unitOfWork.return;
+  try {
     if (
-      current.memoizedProps !== workInProgress.pendingProps ||
-      didPerformWorkStackCursor.current
-    )
-      didReceiveUpdate = !0;
-    else {
-      if (
-        0 === (current.lanes & renderLanes) &&
-        0 === (workInProgress.flags & 128)
+      throwException(
+        root,
+        returnFiber,
+        unitOfWork,
+        thrownValue,
+        workInProgressRootRenderLanes
       )
-        return (
-          (didReceiveUpdate = !1),
-          attemptEarlyBailoutIfNoScheduledUpdate(
-            current,
-            workInProgress,
-            renderLanes
-          )
-        );
-      didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;
+    ) {
+      workInProgressRootExitStatus = 1;
+      workInProgressRootFatalError = thrownValue;
+      workInProgress = null;
+      return;
     }
-  else didReceiveUpdate = !1;
-  workInProgress.lanes = 0;
-  switch (workInProgress.tag) {
-    case 2:
-      var Component = workInProgress.type;
-      resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress);
-      current = workInProgress.pendingProps;
-      var context = getMaskedContext(
-        workInProgress,
-        contextStackCursor$1.current
-      );
-      prepareToReadContext(workInProgress, renderLanes);
-      context = renderWithHooks(
-        null,
-        workInProgress,
-        Component,
-        current,
-        context,
-        renderLanes
-      );
-      workInProgress.flags |= 1;
-      if (
-        "object" === typeof context &&
-        null !== context &&
-        "function" === typeof context.render &&
-        void 0 === context.$$typeof
-      ) {
-        workInProgress.tag = 1;
-        workInProgress.memoizedState = null;
-        workInProgress.updateQueue = null;
-        if (isContextProvider(Component)) {
-          var hasContext = !0;
-          pushContextProvider(workInProgress);
-        } else hasContext = !1;
-        workInProgress.memoizedState =
-          null !== context.state && void 0 !== context.state
-            ? context.state
-            : null;
-        initializeUpdateQueue(workInProgress);
-        context.updater = classComponentUpdater;
-        workInProgress.stateNode = context;
-        context._reactInternals = workInProgress;
-        mountClassInstance(workInProgress, Component, current, renderLanes);
-        workInProgress = finishClassComponent(
-          null,
-          workInProgress,
-          Component,
-          !0,
-          hasContext,
-          renderLanes
-        );
-      } else
-        (workInProgress.tag = 0),
-          reconcileChildren(null, workInProgress, context, renderLanes),
-          (workInProgress = workInProgress.child);
-      return workInProgress;
-    case 16:
-      Component = workInProgress.elementType;
-      a: {
-        resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress);
-        current = workInProgress.pendingProps;
-        context = Component._init;
-        Component = context(Component._payload);
-        workInProgress.type = Component;
-        context = workInProgress.tag = resolveLazyComponentTag(Component);
-        current = resolveDefaultProps(Component, current);
-        switch (context) {
-          case 0:
-            workInProgress = updateFunctionComponent(
-              null,
-              workInProgress,
-              Component,
-              current,
-              renderLanes
-            );
-            break a;
-          case 1:
-            workInProgress = updateClassComponent(
-              null,
-              workInProgress,
-              Component,
-              current,
-              renderLanes
-            );
-            break a;
-          case 11:
-            workInProgress = updateForwardRef(
-              null,
-              workInProgress,
-              Component,
-              current,
-              renderLanes
-            );
-            break a;
-          case 14:
-            workInProgress = updateMemoComponent(
-              null,
-              workInProgress,
-              Component,
-              resolveDefaultProps(Component.type, current),
-              renderLanes
-            );
-            break a;
+  } catch (error) {
+    if (null !== returnFiber) throw ((workInProgress = returnFiber), error);
+    workInProgressRootExitStatus = 1;
+    workInProgressRootFatalError = thrownValue;
+    workInProgress = null;
+    return;
+  }
+  if (unitOfWork.flags & 32768)
+    a: {
+      root = unitOfWork;
+      do {
+        unitOfWork = unwindWork(root.alternate, root);
+        if (null !== unitOfWork) {
+          unitOfWork.flags &= 32767;
+          workInProgress = unitOfWork;
+          break a;
         }
-        throw Error(
-          "Element type is invalid. Received a promise that resolves to: " +
-            Component +
-            ". Lazy element type must resolve to a class or function."
-        );
-      }
-      return workInProgress;
-    case 0:
-      return (
-        (Component = workInProgress.type),
-        (context = workInProgress.pendingProps),
-        (context =
-          workInProgress.elementType === Component
-            ? context
-            : resolveDefaultProps(Component, context)),
-        updateFunctionComponent(
-          current,
-          workInProgress,
-          Component,
-          context,
-          renderLanes
-        )
-      );
-    case 1:
-      return (
-        (Component = workInProgress.type),
-        (context = workInProgress.pendingProps),
-        (context =
-          workInProgress.elementType === Component
-            ? context
-            : resolveDefaultProps(Component, context)),
-        updateClassComponent(
-          current,
-          workInProgress,
-          Component,
-          context,
-          renderLanes
-        )
-      );
-    case 3:
-      pushHostRootContext(workInProgress);
-      if (null === current)
-        throw Error("Should have a current fiber. This is a bug in React.");
-      context = workInProgress.pendingProps;
-      Component = workInProgress.memoizedState.element;
-      cloneUpdateQueue(current, workInProgress);
-      processUpdateQueue(workInProgress, context, null, renderLanes);
-      context = workInProgress.memoizedState.element;
-      context === Component
-        ? (workInProgress = bailoutOnAlreadyFinishedWork(
-            current,
-            workInProgress,
-            renderLanes
-          ))
-        : (reconcileChildren(current, workInProgress, context, renderLanes),
-          (workInProgress = workInProgress.child));
-      return workInProgress;
-    case 26:
-    case 27:
-    case 5:
-      return (
-        pushHostContext(workInProgress),
-        (Component = workInProgress.pendingProps.children),
-        markRef$1(current, workInProgress),
-        reconcileChildren(current, workInProgress, Component, renderLanes),
-        workInProgress.child
+        if (0 !== (root.mode & 2)) {
+          stopProfilerTimerIfRunningAndRecordDelta(root, !1);
+          unitOfWork = root.actualDuration;
+          for (thrownValue = root.child; null !== thrownValue; )
+            (unitOfWork += thrownValue.actualDuration),
+              (thrownValue = thrownValue.sibling);
+          root.actualDuration = unitOfWork;
+        }
+        root = root.return;
+        null !== root &&
+          ((root.flags |= 32768),
+          (root.subtreeFlags = 0),
+          (root.deletions = null));
+        workInProgress = root;
+      } while (null !== root);
+      workInProgressRootExitStatus = 6;
+      workInProgress = null;
+    }
+  else completeUnitOfWork(unitOfWork);
+}
+function completeUnitOfWork(unitOfWork) {
+  var completedWork = unitOfWork;
+  do {
+    var current = completedWork.alternate;
+    unitOfWork = completedWork.return;
+    0 === (completedWork.mode & 2)
+      ? (current = completeWork(current, completedWork, entangledRenderLanes))
+      : (startProfilerTimer(completedWork),
+        (current = completeWork(current, completedWork, entangledRenderLanes)),
+        stopProfilerTimerIfRunningAndRecordDelta(completedWork, !1));
+    if (null !== current) {
+      workInProgress = current;
+      return;
+    }
+    completedWork = completedWork.sibling;
+    if (null !== completedWork) {
+      workInProgress = completedWork;
+      return;
+    }
+    workInProgress = completedWork = unitOfWork;
+  } while (null !== completedWork);
+  0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
+}
+function commitRoot(
+  root,
+  recoverableErrors,
+  transitions,
+  didIncludeRenderPhaseUpdate,
+  spawnedLane
+) {
+  var previousUpdateLanePriority = currentUpdatePriority,
+    prevTransition = ReactCurrentBatchConfig.transition;
+  try {
+    (ReactCurrentBatchConfig.transition = null),
+      (currentUpdatePriority = 2),
+      commitRootImpl(
+        root,
+        recoverableErrors,
+        transitions,
+        didIncludeRenderPhaseUpdate,
+        previousUpdateLanePriority,
+        spawnedLane
       );
-    case 6:
+  } finally {
+    (ReactCurrentBatchConfig.transition = prevTransition),
+      (currentUpdatePriority = previousUpdateLanePriority);
+  }
+  return null;
+}
+function commitRootImpl(
+  root,
+  recoverableErrors,
+  transitions,
+  didIncludeRenderPhaseUpdate,
+  renderPriorityLevel,
+  spawnedLane
+) {
+  do flushPassiveEffects();
+  while (null !== rootWithPendingPassiveEffects);
+  if (0 !== (executionContext & 6))
+    throw Error("Should not already be working.");
+  didIncludeRenderPhaseUpdate = root.finishedWork;
+  transitions = root.finishedLanes;
+  if (null === didIncludeRenderPhaseUpdate) return null;
+  root.finishedWork = null;
+  root.finishedLanes = 0;
+  if (didIncludeRenderPhaseUpdate === root.current)
+    throw Error(
+      "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
+    );
+  root.callbackNode = null;
+  root.callbackPriority = 0;
+  root.cancelPendingCommit = null;
+  var remainingLanes =
+    didIncludeRenderPhaseUpdate.lanes | didIncludeRenderPhaseUpdate.childLanes;
+  remainingLanes |= concurrentlyUpdatedLanes;
+  markRootFinished(root, remainingLanes, spawnedLane);
+  root === workInProgressRoot &&
+    ((workInProgress = workInProgressRoot = null),
+    (workInProgressRootRenderLanes = 0));
+  (0 === (didIncludeRenderPhaseUpdate.subtreeFlags & 10256) &&
+    0 === (didIncludeRenderPhaseUpdate.flags & 10256)) ||
+    rootDoesHavePassiveEffects ||
+    ((rootDoesHavePassiveEffects = !0),
+    scheduleCallback(NormalPriority, function () {
+      flushPassiveEffects();
       return null;
-    case 13:
-      return updateSuspenseComponent(current, workInProgress, renderLanes);
-    case 4:
-      return (
-        pushHostContainer(
-          workInProgress,
-          workInProgress.stateNode.containerInfo
-        ),
-        (Component = workInProgress.pendingProps),
-        null === current
-          ? (workInProgress.child = reconcileChildFibers(
-              workInProgress,
-              null,
-              Component,
-              renderLanes
-            ))
-          : reconcileChildren(current, workInProgress, Component, renderLanes),
-        workInProgress.child
-      );
-    case 11:
-      return (
-        (Component = workInProgress.type),
-        (context = workInProgress.pendingProps),
-        (context =
-          workInProgress.elementType === Component
-            ? context
-            : resolveDefaultProps(Component, context)),
-        updateForwardRef(
-          current,
-          workInProgress,
-          Component,
-          context,
-          renderLanes
-        )
-      );
-    case 7:
-      return (
-        reconcileChildren(
-          current,
-          workInProgress,
-          workInProgress.pendingProps,
-          renderLanes
-        ),
-        workInProgress.child
-      );
-    case 8:
-      return (
-        reconcileChildren(
-          current,
-          workInProgress,
-          workInProgress.pendingProps.children,
-          renderLanes
-        ),
-        workInProgress.child
-      );
-    case 12:
-      return (
-        (workInProgress.flags |= 4),
-        (Component = workInProgress.stateNode),
-        (Component.effectDuration = 0),
-        (Component.passiveEffectDuration = 0),
-        reconcileChildren(
-          current,
-          workInProgress,
-          workInProgress.pendingProps.children,
-          renderLanes
-        ),
-        workInProgress.child
-      );
-    case 10:
-      a: {
-        Component = workInProgress.type._context;
-        context = workInProgress.pendingProps;
-        hasContext = workInProgress.memoizedProps;
-        var newValue = context.value;
-        push(valueCursor, Component._currentValue);
-        Component._currentValue = newValue;
-        if (null !== hasContext)
-          if (objectIs(hasContext.value, newValue)) {
-            if (
-              hasContext.children === context.children &&
-              !didPerformWorkStackCursor.current
-            ) {
-              workInProgress = bailoutOnAlreadyFinishedWork(
-                current,
-                workInProgress,
-                renderLanes
-              );
-              break a;
-            }
-          } else
-            for (
-              hasContext = workInProgress.child,
-                null !== hasContext && (hasContext.return = workInProgress);
-              null !== hasContext;
-
-            ) {
-              var list = hasContext.dependencies;
-              if (null !== list) {
-                newValue = hasContext.child;
-                for (
-                  var dependency = list.firstContext;
-                  null !== dependency;
-
-                ) {
-                  if (dependency.context === Component) {
-                    if (1 === hasContext.tag) {
-                      dependency = createUpdate(renderLanes & -renderLanes);
-                      dependency.tag = 2;
-                      var updateQueue = hasContext.updateQueue;
-                      if (null !== updateQueue) {
-                        updateQueue = updateQueue.shared;
-                        var pending = updateQueue.pending;
-                        null === pending
-                          ? (dependency.next = dependency)
-                          : ((dependency.next = pending.next),
-                            (pending.next = dependency));
-                        updateQueue.pending = dependency;
-                      }
-                    }
-                    hasContext.lanes |= renderLanes;
-                    dependency = hasContext.alternate;
-                    null !== dependency && (dependency.lanes |= renderLanes);
-                    scheduleContextWorkOnParentPath(
-                      hasContext.return,
-                      renderLanes,
-                      workInProgress
-                    );
-                    list.lanes |= renderLanes;
-                    break;
-                  }
-                  dependency = dependency.next;
-                }
-              } else if (10 === hasContext.tag)
-                newValue =
-                  hasContext.type === workInProgress.type
-                    ? null
-                    : hasContext.child;
-              else if (18 === hasContext.tag) {
-                newValue = hasContext.return;
-                if (null === newValue)
-                  throw Error(
-                    "We just came from a parent so we must have had a parent. This is a bug in React."
-                  );
-                newValue.lanes |= renderLanes;
-                list = newValue.alternate;
-                null !== list && (list.lanes |= renderLanes);
-                scheduleContextWorkOnParentPath(
-                  newValue,
-                  renderLanes,
-                  workInProgress
-                );
-                newValue = hasContext.sibling;
-              } else newValue = hasContext.child;
-              if (null !== newValue) newValue.return = hasContext;
-              else
-                for (newValue = hasContext; null !== newValue; ) {
-                  if (newValue === workInProgress) {
-                    newValue = null;
-                    break;
-                  }
-                  hasContext = newValue.sibling;
-                  if (null !== hasContext) {
-                    hasContext.return = newValue.return;
-                    newValue = hasContext;
-                    break;
+    }));
+  spawnedLane = 0 !== (didIncludeRenderPhaseUpdate.flags & 15990);
+  if (0 !== (didIncludeRenderPhaseUpdate.subtreeFlags & 15990) || spawnedLane) {
+    spawnedLane = ReactCurrentBatchConfig.transition;
+    ReactCurrentBatchConfig.transition = null;
+    remainingLanes = currentUpdatePriority;
+    currentUpdatePriority = 2;
+    var prevExecutionContext = executionContext;
+    executionContext |= 4;
+    ReactCurrentOwner.current = null;
+    commitBeforeMutationEffects(root, didIncludeRenderPhaseUpdate);
+    commitTime = now();
+    commitMutationEffects(root, didIncludeRenderPhaseUpdate, transitions);
+    root.current = didIncludeRenderPhaseUpdate;
+    commitLayoutEffects(didIncludeRenderPhaseUpdate, root, transitions);
+    requestPaint();
+    executionContext = prevExecutionContext;
+    currentUpdatePriority = remainingLanes;
+    ReactCurrentBatchConfig.transition = spawnedLane;
+  } else (root.current = didIncludeRenderPhaseUpdate), (commitTime = now());
+  rootDoesHavePassiveEffects &&
+    ((rootDoesHavePassiveEffects = !1),
+    (rootWithPendingPassiveEffects = root),
+    (pendingPassiveEffectsLanes = transitions));
+  remainingLanes = root.pendingLanes;
+  0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
+  onCommitRoot(didIncludeRenderPhaseUpdate.stateNode, renderPriorityLevel);
+  isDevToolsPresent && root.memoizedUpdaters.clear();
+  ensureRootIsScheduled(root);
+  if (null !== recoverableErrors)
+    for (
+      renderPriorityLevel = root.onRecoverableError,
+        didIncludeRenderPhaseUpdate = 0;
+      didIncludeRenderPhaseUpdate < recoverableErrors.length;
+      didIncludeRenderPhaseUpdate++
+    )
+      (spawnedLane = recoverableErrors[didIncludeRenderPhaseUpdate]),
+        (remainingLanes = {
+          digest: spawnedLane.digest,
+          componentStack: spawnedLane.stack
+        }),
+        renderPriorityLevel(spawnedLane.value, remainingLanes);
+  if (hasUncaughtError)
+    throw (
+      ((hasUncaughtError = !1),
+      (root = firstUncaughtError),
+      (firstUncaughtError = null),
+      root)
+    );
+  0 !== (pendingPassiveEffectsLanes & 3) &&
+    0 !== root.tag &&
+    flushPassiveEffects();
+  remainingLanes = root.pendingLanes;
+  0 !== (transitions & 4194218) && 0 !== (remainingLanes & 42)
+    ? ((nestedUpdateScheduled = !0),
+      root === rootWithNestedUpdates
+        ? nestedUpdateCount++
+        : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root)))
+    : (nestedUpdateCount = 0);
+  flushSyncWorkAcrossRoots_impl(!1);
+  return null;
+}
+function flushPassiveEffects() {
+  if (null !== rootWithPendingPassiveEffects) {
+    var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes),
+      prevTransition = ReactCurrentBatchConfig.transition,
+      previousPriority = currentUpdatePriority;
+    try {
+      ReactCurrentBatchConfig.transition = null;
+      currentUpdatePriority = 32 > renderPriority ? 32 : renderPriority;
+      if (null === rootWithPendingPassiveEffects)
+        var JSCompiler_inline_result = !1;
+      else {
+        renderPriority = rootWithPendingPassiveEffects;
+        rootWithPendingPassiveEffects = null;
+        pendingPassiveEffectsLanes = 0;
+        if (0 !== (executionContext & 6))
+          throw Error("Cannot flush passive effects while already rendering.");
+        var prevExecutionContext = executionContext;
+        executionContext |= 4;
+        commitPassiveUnmountOnFiber(renderPriority.current);
+        commitPassiveMountOnFiber(renderPriority, renderPriority.current);
+        var profilerEffects = pendingPassiveProfilerEffects;
+        pendingPassiveProfilerEffects = [];
+        for (var i = 0; i < profilerEffects.length; i++) {
+          var finishedWork = profilerEffects[i];
+          if (executionContext & 4 && 0 !== (finishedWork.flags & 4))
+            switch (finishedWork.tag) {
+              case 12:
+                var passiveEffectDuration =
+                    finishedWork.stateNode.passiveEffectDuration,
+                  _finishedWork$memoize = finishedWork.memoizedProps,
+                  id = _finishedWork$memoize.id,
+                  onPostCommit = _finishedWork$memoize.onPostCommit,
+                  commitTime$86 = commitTime,
+                  phase = null === finishedWork.alternate ? "mount" : "update";
+                currentUpdateIsNested && (phase = "nested-update");
+                "function" === typeof onPostCommit &&
+                  onPostCommit(id, phase, passiveEffectDuration, commitTime$86);
+                var parentFiber = finishedWork.return;
+                b: for (; null !== parentFiber; ) {
+                  switch (parentFiber.tag) {
+                    case 3:
+                      parentFiber.stateNode.passiveEffectDuration +=
+                        passiveEffectDuration;
+                      break b;
+                    case 12:
+                      parentFiber.stateNode.passiveEffectDuration +=
+                        passiveEffectDuration;
+                      break b;
                   }
-                  newValue = newValue.return;
+                  parentFiber = parentFiber.return;
                 }
-              hasContext = newValue;
             }
-        reconcileChildren(
-          current,
-          workInProgress,
-          context.children,
-          renderLanes
+        }
+        executionContext = prevExecutionContext;
+        flushSyncWorkAcrossRoots_impl(!1);
+        if (
+          injectedHook &&
+          "function" === typeof injectedHook.onPostCommitFiberRoot
+        )
+          try {
+            injectedHook.onPostCommitFiberRoot(rendererID, renderPriority);
+          } catch (err) {}
+        var stateNode = renderPriority.current.stateNode;
+        stateNode.effectDuration = 0;
+        stateNode.passiveEffectDuration = 0;
+        JSCompiler_inline_result = !0;
+      }
+      return JSCompiler_inline_result;
+    } finally {
+      (currentUpdatePriority = previousPriority),
+        (ReactCurrentBatchConfig.transition = prevTransition);
+    }
+  }
+  return !1;
+}
+function enqueuePendingPassiveProfilerEffect(fiber) {
+  pendingPassiveProfilerEffects.push(fiber);
+  rootDoesHavePassiveEffects ||
+    ((rootDoesHavePassiveEffects = !0),
+    scheduleCallback(NormalPriority, function () {
+      flushPassiveEffects();
+      return null;
+    }));
+}
+function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
+  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
+  sourceFiber = createRootErrorUpdate(rootFiber, sourceFiber, 2);
+  rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
+  null !== rootFiber &&
+    (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
+}
+function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
+  if (3 === sourceFiber.tag)
+    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
+  else
+    for (; null !== nearestMountedAncestor; ) {
+      if (3 === nearestMountedAncestor.tag) {
+        captureCommitPhaseErrorOnRoot(
+          nearestMountedAncestor,
+          sourceFiber,
+          error
         );
-        workInProgress = workInProgress.child;
+        break;
+      } else if (1 === nearestMountedAncestor.tag) {
+        var instance = nearestMountedAncestor.stateNode;
+        if (
+          "function" ===
+            typeof nearestMountedAncestor.type.getDerivedStateFromError ||
+          ("function" === typeof instance.componentDidCatch &&
+            (null === legacyErrorBoundariesThatAlreadyFailed ||
+              !legacyErrorBoundariesThatAlreadyFailed.has(instance)))
+        ) {
+          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
+          sourceFiber = createClassErrorUpdate(
+            nearestMountedAncestor,
+            sourceFiber,
+            2
+          );
+          nearestMountedAncestor = enqueueUpdate(
+            nearestMountedAncestor,
+            sourceFiber,
+            2
+          );
+          null !== nearestMountedAncestor &&
+            (markRootUpdated$1(nearestMountedAncestor, 2),
+            ensureRootIsScheduled(nearestMountedAncestor));
+          break;
+        }
       }
-      return workInProgress;
-    case 9:
-      return (
-        (context = workInProgress.type),
-        (Component = workInProgress.pendingProps.children),
-        prepareToReadContext(workInProgress, renderLanes),
-        (context = readContext(context)),
-        (Component = Component(context)),
-        (workInProgress.flags |= 1),
-        reconcileChildren(current, workInProgress, Component, renderLanes),
-        workInProgress.child
-      );
-    case 14:
-      return (
-        (Component = workInProgress.type),
-        (context = resolveDefaultProps(Component, workInProgress.pendingProps)),
-        (context = resolveDefaultProps(Component.type, context)),
-        updateMemoComponent(
-          current,
-          workInProgress,
-          Component,
-          context,
-          renderLanes
-        )
-      );
-    case 15:
-      return updateSimpleMemoComponent(
-        current,
-        workInProgress,
-        workInProgress.type,
-        workInProgress.pendingProps,
-        renderLanes
-      );
-    case 17:
-      return (
-        (Component = workInProgress.type),
-        (context = workInProgress.pendingProps),
-        (context =
-          workInProgress.elementType === Component
-            ? context
-            : resolveDefaultProps(Component, context)),
-        resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress),
-        (workInProgress.tag = 1),
-        isContextProvider(Component)
-          ? ((current = !0), pushContextProvider(workInProgress))
-          : (current = !1),
-        prepareToReadContext(workInProgress, renderLanes),
-        constructClassInstance(workInProgress, Component, context),
-        mountClassInstance(workInProgress, Component, context, renderLanes),
-        finishClassComponent(
-          null,
-          workInProgress,
-          Component,
-          !0,
-          current,
-          renderLanes
-        )
-      );
+      nearestMountedAncestor = nearestMountedAncestor.return;
+    }
+}
+function attachPingListener(root, wakeable, lanes) {
+  var pingCache = root.pingCache;
+  if (null === pingCache) {
+    pingCache = root.pingCache = new PossiblyWeakMap();
+    var threadIDs = new Set();
+    pingCache.set(wakeable, threadIDs);
+  } else
+    (threadIDs = pingCache.get(wakeable)),
+      void 0 === threadIDs &&
+        ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs));
+  threadIDs.has(lanes) ||
+    ((workInProgressRootDidAttachPingListener = !0),
+    threadIDs.add(lanes),
+    (pingCache = pingSuspendedRoot.bind(null, root, wakeable, lanes)),
+    isDevToolsPresent && restorePendingUpdaters(root, lanes),
+    wakeable.then(pingCache, pingCache));
+}
+function pingSuspendedRoot(root, wakeable, pingedLanes) {
+  var pingCache = root.pingCache;
+  null !== pingCache && pingCache.delete(wakeable);
+  root.pingedLanes |= root.suspendedLanes & pingedLanes;
+  workInProgressRoot === root &&
+    (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&
+    (4 === workInProgressRootExitStatus ||
+    (3 === workInProgressRootExitStatus &&
+      (workInProgressRootRenderLanes & 62914560) ===
+        workInProgressRootRenderLanes &&
+      300 > now$1() - globalMostRecentFallbackTime)
+      ? 0 === (executionContext & 2) && prepareFreshStack(root, 0)
+      : (workInProgressRootPingedLanes |= pingedLanes));
+  ensureRootIsScheduled(root);
+}
+function retryTimedOutBoundary(boundaryFiber, retryLane) {
+  0 === retryLane &&
+    (retryLane = 0 === (boundaryFiber.mode & 1) ? 2 : claimNextRetryLane());
+  boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
+  null !== boundaryFiber &&
+    (markRootUpdated$1(boundaryFiber, retryLane),
+    ensureRootIsScheduled(boundaryFiber));
+}
+function retryDehydratedSuspenseBoundary(boundaryFiber) {
+  var suspenseState = boundaryFiber.memoizedState,
+    retryLane = 0;
+  null !== suspenseState && (retryLane = suspenseState.retryLane);
+  retryTimedOutBoundary(boundaryFiber, retryLane);
+}
+function resolveRetryWakeable(boundaryFiber, wakeable) {
+  var retryLane = 0;
+  switch (boundaryFiber.tag) {
+    case 13:
+      var retryCache = boundaryFiber.stateNode;
+      var suspenseState = boundaryFiber.memoizedState;
+      null !== suspenseState && (retryLane = suspenseState.retryLane);
+      break;
     case 19:
-      return updateSuspenseListComponent(current, workInProgress, renderLanes);
+      retryCache = boundaryFiber.stateNode;
+      break;
     case 22:
-      return updateOffscreenComponent(current, workInProgress, renderLanes);
+      retryCache = boundaryFiber.stateNode._retryCache;
+      break;
+    default:
+      throw Error(
+        "Pinged unknown suspense boundary type. This is probably a bug in React."
+      );
   }
-  throw Error(
-    "Unknown unit of work tag (" +
-      workInProgress.tag +
-      "). This error is likely caused by a bug in React. Please file an issue."
-  );
-};
+  null !== retryCache && retryCache.delete(wakeable);
+  retryTimedOutBoundary(boundaryFiber, retryLane);
+}
 function restorePendingUpdaters(root, lanes) {
   isDevToolsPresent &&
     root.memoizedUpdaters.forEach(function (schedulingFiber) {
@@ -9831,6 +9510,7 @@ function createFiberFromTypeAndProps(
             case REACT_CONTEXT_TYPE:
               fiberTag = 9;
               break a;
+            case REACT_CONSUMER_TYPE:
             case REACT_FORWARD_REF_TYPE:
               fiberTag = 11;
               break a;
@@ -9988,63 +9668,19 @@ function findHostInstance(component) {
   return null === component ? null : getPublicInstance(component.stateNode);
 }
 function updateContainer(element, container, parentComponent, callback) {
-  var current = container.current,
-    lane = requestUpdateLane(current);
-  a: if (parentComponent) {
-    parentComponent = parentComponent._reactInternals;
-    b: {
-      if (
-        getNearestMountedFiber(parentComponent) !== parentComponent ||
-        1 !== parentComponent.tag
-      )
-        throw Error(
-          "Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue."
-        );
-      var JSCompiler_inline_result = parentComponent;
-      do {
-        switch (JSCompiler_inline_result.tag) {
-          case 3:
-            JSCompiler_inline_result =
-              JSCompiler_inline_result.stateNode.context;
-            break b;
-          case 1:
-            if (isContextProvider(JSCompiler_inline_result.type)) {
-              JSCompiler_inline_result =
-                JSCompiler_inline_result.stateNode
-                  .__reactInternalMemoizedMergedChildContext;
-              break b;
-            }
-        }
-        JSCompiler_inline_result = JSCompiler_inline_result.return;
-      } while (null !== JSCompiler_inline_result);
-      throw Error(
-        "Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue."
-      );
-    }
-    if (1 === parentComponent.tag) {
-      var Component = parentComponent.type;
-      if (isContextProvider(Component)) {
-        parentComponent = processChildContext(
-          parentComponent,
-          Component,
-          JSCompiler_inline_result
-        );
-        break a;
-      }
-    }
-    parentComponent = JSCompiler_inline_result;
-  } else parentComponent = emptyContextObject;
+  parentComponent = container.current;
+  var lane = requestUpdateLane(parentComponent);
   null === container.context
-    ? (container.context = parentComponent)
-    : (container.pendingContext = parentComponent);
+    ? (container.context = emptyContextObject)
+    : (container.pendingContext = emptyContextObject);
   container = createUpdate(lane);
   container.payload = { element: element };
   callback = void 0 === callback ? null : callback;
   null !== callback && (container.callback = callback);
-  element = enqueueUpdate(current, container, lane);
+  element = enqueueUpdate(parentComponent, container, lane);
   null !== element &&
-    (scheduleUpdateOnFiber(element, current, lane),
-    entangleTransitions(element, current, lane));
+    (scheduleUpdateOnFiber(element, parentComponent, lane),
+    entangleTransitions(element, parentComponent, lane));
   return lane;
 }
 function emptyFindFiberByHostInstance() {
@@ -10099,10 +9735,10 @@ batchedUpdatesImpl = function (fn, a) {
   }
 };
 var roots = new Map(),
-  devToolsConfig$jscomp$inline_1154 = {
+  devToolsConfig$jscomp$inline_1140 = {
     findFiberByHostInstance: getInstanceFromTag,
     bundleType: 0,
-    version: "18.3.0-canary-03d6f7cf0-20240209",
+    version: "18.3.0-canary-9372c6311-20240315",
     rendererPackageName: "react-native-renderer",
     rendererConfig: {
       getInspectorDataForInstance: getInspectorDataForInstance,
@@ -10118,11 +9754,11 @@ var roots = new Map(),
       }.bind(null, findNodeHandle)
     }
   };
-var internals$jscomp$inline_1389 = {
-  bundleType: devToolsConfig$jscomp$inline_1154.bundleType,
-  version: devToolsConfig$jscomp$inline_1154.version,
-  rendererPackageName: devToolsConfig$jscomp$inline_1154.rendererPackageName,
-  rendererConfig: devToolsConfig$jscomp$inline_1154.rendererConfig,
+var internals$jscomp$inline_1378 = {
+  bundleType: devToolsConfig$jscomp$inline_1140.bundleType,
+  version: devToolsConfig$jscomp$inline_1140.version,
+  rendererPackageName: devToolsConfig$jscomp$inline_1140.rendererPackageName,
+  rendererConfig: devToolsConfig$jscomp$inline_1140.rendererConfig,
   overrideHookState: null,
   overrideHookStateDeletePath: null,
   overrideHookStateRenamePath: null,
@@ -10138,26 +9774,26 @@ var internals$jscomp$inline_1389 = {
     return null === fiber ? null : fiber.stateNode;
   },
   findFiberByHostInstance:
-    devToolsConfig$jscomp$inline_1154.findFiberByHostInstance ||
+    devToolsConfig$jscomp$inline_1140.findFiberByHostInstance ||
     emptyFindFiberByHostInstance,
   findHostInstancesForRefresh: null,
   scheduleRefresh: null,
   scheduleRoot: null,
   setRefreshHandler: null,
   getCurrentFiber: null,
-  reconcilerVersion: "18.3.0-canary-03d6f7cf0-20240209"
+  reconcilerVersion: "18.3.0-canary-9372c6311-20240315"
 };
 if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
-  var hook$jscomp$inline_1390 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
+  var hook$jscomp$inline_1379 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
   if (
-    !hook$jscomp$inline_1390.isDisabled &&
-    hook$jscomp$inline_1390.supportsFiber
+    !hook$jscomp$inline_1379.isDisabled &&
+    hook$jscomp$inline_1379.supportsFiber
   )
     try {
-      (rendererID = hook$jscomp$inline_1390.inject(
-        internals$jscomp$inline_1389
+      (rendererID = hook$jscomp$inline_1379.inject(
+        internals$jscomp$inline_1378
       )),
-        (injectedHook = hook$jscomp$inline_1390);
+        (injectedHook = hook$jscomp$inline_1379);
     } catch (err) {}
 }
 exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = {
